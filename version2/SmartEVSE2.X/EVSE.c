/*
; Project:       Smart EVSE
; Date:          21 February 2019
;
; Changes:
;
; 2.00  New v2 hardware (18F26K22), Graphic 128x64 LCD , MPLAB X IDE, and the XC8 compiler
; 2.01  Fix: Charge current in normal mode was limited to MaxMains setting.
;       Fix: Load Balancing-Master can now adjust MaxMains and MinCharge settings from the LCD menu.
;       Fix: SmartMode can now charge at a higher current then set by MaxMains, using surplus power generated by Solar.
;            i.e. -15A PV power +45A MaxMains results in charging current of 60A.
;       Bugfixes to load balancing code (only affects v2)
; 2.02  Fix: Slave Max charge current was set to Cable limit instead of MaxCurrent
;       Fix: Charging sometimes stopped because State C control pilot ranges were too strict. 
; 2.03  Changed lowest MaxMains setting to 10A, lowest CT calibration value to 6A.
; 2.04  Fix: In Normal mode, the MAX charge current was limited by the MAINS setting (which is not shown in this mode).
;       Fix: default LoadBl EEPROM setting was not set correctly.
;       MAX charge current can be adjusted while charging in Normal mode.
;       ACCESS menu option added. Allows to Start/Stop charging by connecting a button/switch to IO2.
;       if the ACCESS option is set to disabled, the button can be used to stop charging.
;       On IO1 a LED can be connected, which acts as a charging/error indicator.
; 2.05  Fix: Using a 16A charge cable would limit MaxCurrent to 16A, until a reset of the module or adjusting the MAX value using the menu. 
;       Fix: Increased number of times a STATE change needs to be valid, before the actual STATE change takes place.
;            this to fix erratic behavior on a Renault Zoe.
;       LCD Backlight will now be activated on any key press, and will turn off after 30 seconds of inactivity (except when charging).  
;       CT's default values can be restored by holding both < and > keys while in the CAL menu.
;       RCMON menu option added. This adds support for DC Residual Current sensors, as required by IEC62955.
;            IO3 is used as the fault input (active high).
;            The error state can be reset by pressing any module button, or the pushbutton on IO2
; 2.06  Added check in EEprom write routine for disabled interrupts.
;
;   Use XC8 compiler version 1.45, version 2.x currently does not work.
;
;   set XC8 linker memory model settings to: double 32 bit, float 32 bit
;   extended instruction set is not used on XC8
;   add the following XC8 linker option to reserve space for the bootloader:
:   --rom=0-FCFB
;
;
;   (C) 2013-2019  Michael Stegen / Stegen Electronics
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in
; all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
; THE SOFTWARE.
*/
#include <xc.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "EVSE.h"

void SetCurrent(unsigned int);
unsigned int CalcCurrent();


// Configuration settings
#pragma	config FCMEN = OFF,	IESO = OFF, PRICLKEN = ON
#pragma config PLLCFG = OFF, FOSC = HSMP                                        // High Speed Medium power (4-16Mhz), PLL Off
#pragma	config BORV = 285, BOREN = ON, PWRTEN = ON
#pragma	config WDTPS = 2048, WDTEN = OFF                                        // WDT timeout
#pragma config CCP2MX = PORTB3, PBADEN = OFF, CCP3MX = PORTC6                   // PortB digital IO
#pragma config HFOFST = OFF, T3CMX = PORTB5, P2BMX = PORTC0, MCLRE = INTMCLR

#pragma config XINST = OFF, DEBUG = OFF, LVP = OFF, STVREN = ON
#pragma	config CP0 = OFF, CP1 = OFF, CP2 = OFF, CP3 = OFF, CPD = OFF, CPB = OFF
#pragma	config WRT0 = OFF, WRT1 = OFF, WRT2 = OFF, WRT3 = OFF
#pragma	config WRTC = OFF, WRTB = OFF, WRTD = OFF
#pragma	config EBTR0 = OFF, EBTR1 = OFF, EBTR2 = OFF, EBTR3 = OFF
#pragma	config EBTRB = OFF


const unsigned int EE_MaxMains @ 0xf00000 = MAX_MAINS;
const unsigned int EE_MaxCurrent @ 0xf00002 = MAX_CURRENT;
const unsigned int EE_MinCurrent @ 0xf00004 = MIN_CURRENT;
const double EE_ICal @ 0xf00006 = ICAL;
const unsigned int EE_Mode @ 0xf0000a = MODE + (LOCK<<8);
const unsigned int EE_CableLimit @ 0xf0000c = CABLE_LIMIT;
const unsigned int EE_Config_LoadBl @ 0xf0000e = CONFIG + (LOADBL<<8);
const unsigned int EE_Access @ 0xf00010 = ACCESS;
const unsigned int EE_RCmon @ 0xf00012 = RC_MON;

// Global data
char    U1buffer[50];                                                           // Uart1 Receive buffer /RS485
char    U1TXbuffer[50];                                                         // Uart1 Transmit buffer /RS485
char    U2buffer[50];                                                           // Uart2 buffer /Serial CLI
char    Tbuffer[50];                                                            // temp buffer
char    GLCDbuf[256];                                                           // GLCD buffer (one row double height text only)


// The following data will be updated by eeprom data at powerup:
unsigned int MaxMains;                                                          // Max Mains Amps (hard limit, limited by the MAINS connection)
unsigned int MaxCurrent;                                                        // Max Charge current
unsigned int MinCurrent;                                                        // Minimal current the EV is happy with
double ICal;                                                                    // CT calibration value
char Mode;                                                                      // EVSE mode
char Lock;                                                                      // Cable lock enable/disable
unsigned int CableLimit;                                                        // Fixed Cable Current limit (only used when config is set to Fixed Cable)
char Config;                                                                    // Configuration (Fixed Cable or Type 2 Socket)
char LoadBl;                                                                    // Load Balance Setting (Disable, Master or Slave1-3)
char Access;                                                                    // External Start/Stop button on I/O 2
char RCmon;                                                                     // Residual Current Monitor on I/O 3

// total 17 bytes

double Irms[3]={0,0,0};                                                         // Momentary current per Phase (Amps *10) (23= 2.3A)
                                                                                // Max 3 phases supported

unsigned int crc16;
unsigned char State = STATE_A;
unsigned char Error = NO_ERROR;
unsigned char NextState;

unsigned int MaxCapacity;                                                       // Cable limit (Amps)(limited by the wire in the charge cable, set automatically, or manually if Config=Fixed Cable)
unsigned int ChargeCurrent;                                                     // Calculated Charge Current
unsigned int Imeasured=0;                                                       // Max of all CT inputs (Amps *10)
// Load Balance variables
int IsetBalanced=0;                                                             // Max calculated current available for all EVSE's
int Balanced[4]={0,0,0,0};                                                      // Amps value per EVSE (max 4)
int BalancedMax[4]={0,0,0,0};                                                   // Max Amps value per EVSE (max 4)
char BalancedState[4]={0,0,0,0};                                                // State of all EVSE's 0=not active (state A), 1=charge request (State B), 2= Charging (State C) 

unsigned char RX1byte, TX1byte;
unsigned char idx=0,idx2=0,ISRFLAG=0,ISR2FLAG=0,ISRTXFLAG=0;
unsigned char menu=0;
unsigned int locktimer=0,unlocktimer=0;                                         // solenoid timers
unsigned long Timer=0;                                                          // mS counter
unsigned char BacklightTimer=0;                                                 // Backlight timer (sec)
unsigned int ChargeTimer=0;                                                     // Counts seconds in STATE C (Charging) (unused)
unsigned char LCDTimer=0;
unsigned char TempEVSE=0;                                                       // Temperature EVSE in deg C (0-125)
unsigned char ButtonState=0x0f;                                                 // Holds latest push Buttons state (LSB 3:0)
unsigned char OldButtonState=0x0f;                                              // Holds previous push Buttons state (LSB 3:0)
unsigned char LCDNav=0;
unsigned char SubMenu=0;
unsigned long ScrollTimer=0;
unsigned char LCDpos=8;
unsigned char ChargeDelay=0;                                                    // Delays charging at least 60 seconds in case of not enough current available.
unsigned char NoCurrent=0;                                                      // counts overcurrent situations.
unsigned char TestState=0;
unsigned char LedTimer=0;                                                       // LED on I01 uses TMR2 and a PWM signal to fade in/out
unsigned char LedUpdate=0;                                                      // Flag that LED PWM data has been updated
unsigned char LedCount=0;                                                       // Raw Counter before being converted to PWM value
unsigned char LedPwm=0;                                                         // PWM value 0-255

unsigned char Access_bit=0;
unsigned int AccessTimer=0;         

const far char MenuConfig[] = "CONFIG - Set to Fixed Cable or Type 2 Socket";
const far char MenuMode[]   = "MODE   - Set to Smart mode or Normal EVSE mode";
const far char MenuLoadBl[] = "LOADBL - Set Load Balancing mode";
const far char MenuMains[]  = "MAINS  - Set Max MAINS Current";
const far char MenuMax[]    = "MAX    - Set MAX Charge Current for the EV";
const far char MenuMin[]    = "MIN    - Set MIN Charge Current the EV will accept";
const far char MenuCable[]  = "CABLE  - Set Fixed Cable Current limit";
const far char MenuLock[]   = "LOCK   - Cable locking actuator type";
const far char MenuCal[]    = "CAL    - Calibrate CT1 (CT2+3 will also change)";
const far char MenuAccess[] = "ACCESS - Access control on IO2";
const far char MenuRCmon[]  = "RCMON  - Residual Current Monitor on IO3";


void interrupt high_isr(void)
{
    // Determine what caused the interrupt
    while (PIR1bits.RC1IF)                                                      // Uart1 receive interrupt? RS485
    {
        RX1byte = RCREG1;                                                       // copy received byte	
    // check for start/end of data packet byte, and max number of bytes in buffer 
        if (idx == 50) idx--;
        if (RX1byte == 0x7E)                                                    // max 50 bytes in buffer
        {
            if (idx > 7)                                                        // end of packet detected?
            {
                ISRFLAG = idx;                                                  // flag complete packet for main routine
            }
            idx = 0;                                                            // reset index
        } else if (RX1byte == 0x7D)                                             // escape character found?
        {
            ISRFLAG = 1;                                                        // yes, mark next byte
        } else                                                                  // normal characters
        {
            if (ISRFLAG == 1)                                                   // was previous byte a escape character?
            {
                ISRFLAG = 0;
                RX1byte = 0x20 ^ RX1byte;
            }
            U1buffer[idx++] = RX1byte;
        }
    }

    if (PIR1bits.TX1IF && PIE1bits.TX1IE)                                       // Uart1 transmit interrupt? RS485
    {
        TX1byte = U1TXbuffer[ISRTXFLAG];
        TXREG1 = TX1byte;                                                       // send character
        if ((ISRTXFLAG && TX1byte == 0x7E) || ISRTXFLAG == 49)                  // end of buffer
        {
            PIE1bits.TX1IE = 0;                                                 // clear transmit Interrupt for RS485 after sending last character
            ISRTXFLAG = 0;                                                      // end of transmission.
            // we switch of the transmitter in the main loop, after the final character has been sent..
        } else ISRTXFLAG++;
    }

    // Uart2 receive interrupt?
    while (PIR3bits.RC2IF)                                                      
    {
        // Check for BREAK character, then Reset

        if (RCSTA2bits.FERR && RCONbits.POR && State == STATE_A) {              // Make sure any data during a POR is ignored
            RX1byte = RCREG2;                                                   // copy received byte
            if (!RX1byte) Reset();                                              // Only reset if not charging...
        } else RX1byte = RCREG2;
        
        TXREG2 = RX1byte;                                                       // echo to UART2 port, don't check for overflow here.
        if (idx2 == 50) idx2--;
        if ((RX1byte == 0x08) && (idx2 > 0)) {
            idx2--;                                                             // backspace
        } else {
            if (RX1byte == 0x0d || RX1byte == 0x0a)                             // CR or LF?
            {
                RX1byte = 0;
                ISR2FLAG = idx2 + 1;                                            // ENTER, process data
            }
            U2buffer[idx2++] = RX1byte;                                         // store byte
        }
    }

    // Timer 4 interrupt, called 1000 times/sec
    while (PIR5bits.TMR4IF)                                                     
    {
        if (Lock == 1)                                                          // Cable lock type Solenoid?
        {
            if (Error || (State != STATE_C)) {
                if (unlocktimer < 300)                                          // 300ms pulse		
                {
                    SOLENOID_UNLOCK;
                } else SOLENOID_OFF;
                if (unlocktimer++ > 400) {
                    if (PORTCbits.RC1 == 0)                                     // still locked...
                    {
                        if (unlocktimer > 5000) unlocktimer = 0;                //try to unlock again in 5 seconds
                    } else unlocktimer = 400;
                }
                locktimer = 0;
            }
            else                                                                // State C
            {
                if (locktimer < 300)                                            // 300ms pulse
                {
                    SOLENOID_LOCK;
                }
                else SOLENOID_OFF;
                if (locktimer++ > 400) {
                    if (PORTCbits.RC1 == 1)                                     // still unlocked...
                    {
                        if (locktimer > 5000) locktimer = 0;                    //try to lock again in 5 seconds
                    } else locktimer = 400;
                }
                unlocktimer = 0;
            }
        }
        else if (Lock == 2)                                                     // Cable lock type Motor?
        {
            if (Error || (State != STATE_C)) {
                if (unlocktimer < 600)                                          // 600ms pulse		
                {
                    SOLENOID_UNLOCK;
                } else SOLENOID_OFF;
                if (unlocktimer++ > 700) {
                    if (PORTCbits.RC1 == 1)                                     // still locked...
                    {
                        if (unlocktimer > 5000) unlocktimer = 0;                //try to unlock again in 5 seconds
                    } else unlocktimer = 700;
                }
                locktimer = 0;
            }
            else                                                                // State C
            {
                if (locktimer < 600)                                            // 600ms pulse
                {
                    SOLENOID_LOCK;
                }
                else SOLENOID_OFF;
                if (locktimer++ > 700) {
                    if (PORTCbits.RC1 == 0)                                     // still unlocked...
                    {
                        if (locktimer > 5000) locktimer = 0;                    //try to lock again in 5 seconds
                    } else locktimer = 700;
                }
                unlocktimer = 0;
            }
        }
         

        Timer++;                                                                // mSec counter (overflows in 1193 hours)
        if (AccessTimer) AccessTimer--;

        if (LedTimer-- == 0) {
            CCPR2L = LedPwm;                                                    // MSB of DutyCycle, Lsb 0-1 are part of CCP2CON, but not used
                                                                                // LedPwm is calculated in the main loop
            LedTimer = 10;                                                      // Led is updated every 10ms (1ms*10)
            LedUpdate = 1;                                                      // Flag that LED PWM value has been updated
        }
        PIR5bits.TMR4IF = 0;                                                    // clear interrupt flag
    }

}

/* triwave8: triangle (sawtooth) wave generator.  Useful for
           turning a one-byte ever-increasing value into a
           one-byte value that oscillates up and down.

           input         output
           0..127        0..254 (positive slope)
           128..255      254..0 (negative slope)
 */
unsigned char triwave8(unsigned char in) {
    if (in & 0x80) {
        in = 255 - in;
    }
    unsigned char out = in << 1;
    return out;
}

unsigned char scale8(unsigned char i, unsigned char scale) {
    return (((unsigned int) i) * (1 + (unsigned int) (scale))) >> 8;
}

/* easing functions; see http://easings.net

    ease8InOutQuad: 8-bit quadratic ease-in / ease-out function
 */
unsigned char ease8InOutQuad(unsigned char i) {
    unsigned char j = i;
    if (j & 0x80) {
        j = 255 - j;
    }
    unsigned char jj = scale8(j, j);
    unsigned char jj2 = jj << 1;
    if (i & 0x80) {
        jj2 = 255 - jj2;
    }
    return jj2;
}



// calculates 16-bit CRC of given data
// used for Frame Check Sequence on data frame
// Poly used is x^16+x^12+x^5+x

unsigned int calc_crc16(char* start, char len) {
    unsigned int crc = 0xffff, c;
    int i;
    while (len--) {
        c = *start;
        for (i = 0; i < 8; i++) {
            if ((crc ^ c) & 1) crc = (crc >> 1)^0x8408;
            else crc >>= 1;
            c >>= 1;
        }
        start++;
    }
    crc = (unsigned int) (crc ^ 0xFFFF);
    return (crc);
}

void eeprom_read_object(void *obj_p, size_t obj_size) {
    unsigned char *p = obj_p;

    EECON1 = 0;                                                                 // select EEprom
                                                                                // EEADR needs to be initialized
    while (obj_size--) {
        EECON1bits.RD = 1;
        *p++ = EEDATA;
        EEADR++;
    }
}

void eeprom_write_object(void *obj_p, size_t obj_size) {
    unsigned char *p = obj_p;

    while (obj_size--) {
        EECON1 = 0;                                                             //ensure CFGS=0 and EEPGD=0
        EECON1bits.WREN = 1;                                                    //enable write to EEPROM

        EEDATA = *p++;                                                          // set data
        if (!INTCONbits.GIE)                                                    // Interrupts should have been disabled!
        {
            EECON2 = 0x55;                                                      // required sequence #1
            EECON2 = 0xAA;                                                      // #2
            EECON1bits.WR = 1;                                                  // #3 = actual write
            while (EECON1bits.WR);                                              // blocking
        }    
        EECON1bits.WREN = 0;                                                    // disable write to EEPROM
        EEADR++;
    }
}

void read_settings(void) {
    char savint;

    savint = INTCON;                                                            // Save interrupts state
    INTCONbits.GIE = 0;                                                         // Disable interrupts

    EEADR = 0;                                                                  // start from adr 0 in eeprom
    EEADRH = 0;                                                                 // we only use the first 256 bytes for now.

    eeprom_read_object(&MaxMains, sizeof MaxMains);
    eeprom_read_object(&MaxCurrent, sizeof MaxCurrent);
    eeprom_read_object(&MinCurrent, sizeof MinCurrent);
    eeprom_read_object(&ICal, sizeof ICal);
    eeprom_read_object(&Mode, sizeof Mode);
    eeprom_read_object(&Lock, sizeof Lock);
    eeprom_read_object(&CableLimit, sizeof CableLimit);
    eeprom_read_object(&Config, sizeof Config);
    eeprom_read_object(&LoadBl, sizeof LoadBl);
    eeprom_read_object(&Access, sizeof Access);
    eeprom_read_object(&RCmon, sizeof RCmon);

    INTCON = savint; // Restore interrupts
}

void write_settings(void) {
    char savint;

    savint = INTCON;                                                            // Save interrupts state
    INTCONbits.GIE = 0;                                                         // Disable interrupts

    EEADR = 0;                                                                  // start from adr 0 in eeprom
    EEADRH = 0;                                                                 // we only use the first 256 bytes for now.

    eeprom_write_object(&MaxMains, sizeof MaxMains);
    eeprom_write_object(&MaxCurrent, sizeof MaxCurrent);
    eeprom_write_object(&MinCurrent, sizeof MinCurrent);
    eeprom_write_object(&ICal, sizeof ICal);
    eeprom_write_object(&Mode, sizeof Mode);
    eeprom_write_object(&Lock, sizeof Lock);
    eeprom_write_object(&CableLimit, sizeof CableLimit);
    eeprom_write_object(&Config, sizeof Config);
    eeprom_write_object(&LoadBl, sizeof LoadBl);
    eeprom_write_object(&Access, sizeof Access);
    eeprom_write_object(&RCmon, sizeof RCmon);

    INTCON = savint;                                                            // Restore interrupts
    printf("\r\nsettings saved\r\n");

}

void putch(unsigned char byte)                                                  // user defined printf support on uart2
{
    // output one byte on UART2
    while (!PIR3bits.TX2IF)                                                     // set when register is empty 
        continue;
    TXREG2 = byte;

}


// Create HDLC frame from data, and copy to output buffer
// Start RS485 transmission, by enabling TX interrupt

void RS485SendBuf(char* buffer, unsigned char len) {
    char ch, index = 0;
    unsigned long tmr;

    while (ISRTXFLAG) {
    }                                                                           // wait if we are still transmitting over RS485

    U1TXbuffer[index++] = 0x7E;                                                 // copy sync flag to output buffer
    while (len--) {
        ch = *buffer++;                                                         // load next byte
        if ((ch == 0x11) || (ch == 0x12) || (ch == 0x13) || (ch == 0x7E) || (ch == 0x7D)) // check for escape character
        {
            ch = ch^0x20;
            U1TXbuffer[index++] = 0x7D;                                         // copy escape character
        }
        U1TXbuffer[index++] = ch;                                               // copy data to buffer
    }
    U1TXbuffer[index++] = 0x7E;                                                 // copy sync flag

    tmr = Timer + 1000;
    while (idx && (tmr > Timer)) {
    }                                                                           // wait for RS485 reception to finish, with 1000ms timeout

    LATBbits.LATB5 = 1;                                                         // set RS485 transceiver to transmit
    PIE1bits.TX1IE = 1;                                                         // enable transmit Interrupt for RS485
}

unsigned char ReadPilot(void)                                                   // Read Pilot Signal 
{
    ADCON0bits.GO = 1;                                                          // initiate ADC conversion on the selected channel
    while (ADCON0bits.GO);
    if (ADRES > 980) return PILOT_12V;                                          // Pilot at 12V (min 11.0V)
    if ((ADRES > 860) && (ADRES < 915)) return PILOT_9V;                        // Pilot at 9V
    if ((ADRES > 720) && (ADRES < 800)) return PILOT_6V;                        // Pilot at 6V
    if ((ADRES > 25) && (ADRES < 95)) return PILOT_DIODE;                       // Diode Check OK
    return PILOT_NOK;                                                           // Pilot NOT ok
}

void ProximityPin(void) {
    ADCON0 = 0b00000101;                                                        // ADC input AN1 (Proximity Pin)
    ADCON2 = 0b10100101;                                                        // Right justify, Tacq = 8 uS, FOSC/16
    delay(100);
    ADCON0bits.GO = 1;                                                          // initiate ADC conversion on the selected channel
    while (ADCON0bits.GO);

    MaxCapacity = 13;                                                           // No resistor, Max cable current = 13A
    if ((ADRES > 394) && (ADRES < 434)) MaxCapacity = 16;                       // Max cable current = 16A	680R
    if ((ADRES > 175) && (ADRES < 193)) MaxCapacity = 32;                       // Max cable current = 32A	220R
    if ((ADRES > 88) && (ADRES < 98)) MaxCapacity = 63;                         // Max cable current = 63A	100R

    if (Config) MaxCapacity = CableLimit;                                       // Override when Fixed Cable is used.  

    ADCON0 = 0b00000001;                                                        // ADC input AN0 (Pilot)
    ADCON2 = 0b10000101;                                                        // Right justify, Tacq = 0 uS, FOSC/16
}

void Temp(void)                                                                 // Measure Temperature EVSE (0-125 C)
{
    unsigned int temp;

    ADCON0 = 0b00001001;                                                        // ADC input AN2 (Temperature Sensor)
    ADCON1 = 0b00001000;                                                        // Use VREF 2.048V
    ADCON2 = 0b10111101;                                                        // Right justify, Tacq = 20 uS, FOSC/16
    ADCON0bits.GO = 1;                                                          // initiate ADC conversion on the selected channel
    while (ADCON0bits.GO);

    temp = ADRES / 5;                                                           // ADRES= 2mv / ADC step
                                                                                // temp = gr/C (including offset of 50)
    ADCON0 = 0b00000001;                                                        // ADC input AN0 (Pilot)
    ADCON1 = 0b00000000;                                                        // Use standard Voltage ref = VCC
    ADCON2 = 0b10000101;                                                        // Right justify, Tacq = 0 uS, FOSC/16

    if (temp < 50) TempEVSE = 0;                                                // set to 0 deg C
    else TempEVSE = temp - 50;                                                  // set Temp (1-125 deg C), and remove offset
}

void BlinkLed(void) {
    if (Error || ChargeDelay) {
        if (LedUpdate) {
            if (Error == RCD_TRIPPED) LedCount += 20;                           // Very rapid flashing, RCD tripped.
            else if (Error && ChargeDelay) LedCount += 10;                      // Rapid flashing indicates ERROR
            else LedCount = LedCount + 3;                                       // short Blinks indicate waiting for ChargeDelay to clear

            if (Error && LedCount > 128) LedPwm = 255;                          // LED 50% of time on, full brightness
            else if (ChargeDelay && LedCount > 200) LedPwm = 255;               // LED 22% of time on, full brightness
            else LedPwm = 0;                                                    // LED off
            LedUpdate = 0;
        }
    } else if (Access && Access_bit == 0) LedPwm = 0;                           // No Access, LED off
    else if (State == STATE_A) LedPwm = 40;                                     // STATE A, LED on (dimmed)
    else if (State == STATE_B) {
        LedPwm = 255;                                                           // STATE B, LED on (full brightness)
        LedCount = 128;                                                         // When switching to STATE C, start at full brightness
    } else if (State == STATE_C && LedUpdate)                                   // STATE C, LED fades in/out
    {
        LedCount = LedCount + 2;
        LedPwm = ease8InOutQuad(triwave8(LedCount));                            // pre calculate new LedPwm value
        LedUpdate = 0;
    }
}

void SetCurrent(unsigned int current)                                           // current in Amps (16= 16A)
{
    unsigned int DutyCycle;

    current = current * 10;                                                     // multiply by 10 (current in Amps x10	(160= 16A) )
    if ((current >= 60) && (current <= 510)) DutyCycle = (unsigned int) (current / 0.6);
                                                                                // calculate DutyCycle from current
    else if ((current > 510) && (current <= 800)) DutyCycle = (unsigned int) (current / 2.5) + 640;
    else DutyCycle = 100;                                                       // invalid, use 6A
    CCPR1L = DutyCycle >> 2;                                                    // Msb of DutyCycle
                                                                                // 2 Lsb are part of CCP1CON, use Timer 2	
    CCP1CON = (((DutyCycle & 0x03) << 4) | 0x0C);                               // PWM Pilot signal enabled
}

// Is there atleast 6A(configurable MinCurrent) available for a EVSE?

char IsCurrentAvailable(void) {
    unsigned char n, ActiveEVSE = 0;
    int Baseload, TotalCurrent = 0;

    for (n = 0; n < 4; n++) if (BalancedState[n] == 2)                          // must be in STATE_C
    {
        ActiveEVSE++;                                                           // Count nr of Active EVSE's
        TotalCurrent += Balanced[n];                                            // Calculate total max charge current for all active EVSE's
    }
    if (ActiveEVSE == 0) {
        if (Imeasured > ((MaxMains - MinCurrent)*10)) {
            return 1;                                                           // Not enough current available!, return with error
        }
    } else {
        ActiveEVSE++;                                                           // Do calculations with one more EVSE
        Baseload = Imeasured - (TotalCurrent * 10);                             // Calculate Baseload (load without any active EVSE)
        if (Baseload < 0) Baseload = 0;

        if (ActiveEVSE > 4) ActiveEVSE = 4;
        if ((ActiveEVSE * (MinCurrent * 10) + Baseload) > (MaxMains * 10)) {
            return 1;                                                           // Not enough current available!, return with error
        }
    }
    return 0;
}


// Calculates Balanced PWM current for each EVSE
// mod =0 normal
// mod =1 we have a new EVSE requesting to start charging.

void CalcBalancedCurrent(char mod) {
    int Average, MaxBalanced, Idifference;
    int BalancedLeft = 0;
    int ActiveMax = 0, TotalCurrent = 0, Baseload;
    char CurrentSet[4] = {0, 0, 0, 0};
    char n;

    if (!LoadBl)                                                                // Load balancing disabled?
    {
        for (n = 1; n < 4; n++) BalancedState[n] = 0;                           // Yes, disable old active Slave states
    }
                                                                                // Do not modify MaxCurrent as it is a config setting. (fix 2.05)
    if (BalancedState[0] == 2 && MaxCurrent > MaxCapacity) ChargeCurrent = MaxCapacity;
    else ChargeCurrent = MaxCurrent;                                            // Instead use new variable ChargeCurrent.

    if (LoadBl < 2) BalancedMax[0] = ChargeCurrent;                             // Load Balancing Disabled or Master: 
                                                                                // update BalancedMax[0] if the MAX current was adjusted using buttons or CLI

    for (n = 0; n < 4; n++) if (BalancedState[n] == 2) {
            BalancedLeft++;                                                     // Count nr of Active (Charging) EVSE's
            ActiveMax += BalancedMax[n];                                        // Calculate total Max Amps for all active EVSEs
            TotalCurrent += Balanced[n];                                        // Calculate total of all set charge currents
        }

    if (!mod) {
        Idifference = (MaxMains * 10) - Imeasured;                              // Difference between MaxMains and Measured current (can be negative)

        if (Idifference > 0) IsetBalanced += (Idifference / 4);                 // increase with 1/4th of difference (slowly increase current)
        else IsetBalanced += Idifference;                                       // last PWM setting + difference (immediately decrease current)
        if (IsetBalanced < 0) IsetBalanced = 0;
    }

    Baseload = Imeasured - (TotalCurrent * 10);                                 // Calculate Baseload (load without any active EVSE)
    if (Baseload < 0) Baseload = 0;

    if (!Mode)                                                                  // Normal Mode
    {
        if (LoadBl) IsetBalanced = MaxMains * 10;                               // Load Balancing active? MAINS is max current for all active EVSE's
        else IsetBalanced = ChargeCurrent * 10;                                 // No Load Balancing in Normal Mode. Set current to ChargeCurrent (fix: v2.05)
    }

    if (BalancedLeft)                                                           // Only if we have active EVSE's
    {

        if (mod) IsetBalanced = (MaxMains * 10) - Baseload;                     // Set max combined charge current to MaxMains - Baseload		

        if (IsetBalanced < 0 || IsetBalanced < (BalancedLeft * (MinCurrent * 10))) {
            NoCurrent++;                                                        // Flag NoCurrent left
            printf("No Current!!\n\r");
            IsetBalanced = (BalancedLeft * (MinCurrent * 10));                  // set minimal "MinCurrent" charge per active EVSE
        } else NoCurrent = 0;

        if (IsetBalanced > (ActiveMax * 10)) IsetBalanced = ActiveMax * 10;     // limit to total maximum Amps (of all active EVSE's)

        MaxBalanced = (IsetBalanced / 10);                                      // convert to Amps

        DEBUG_PRINT(("Imeasured:%3u IsetBalanced:%3i Baseload:%3u ", Imeasured, IsetBalanced, Baseload));

        // Calculate average current per EVSE
        n = 0;
        do {
            Average = MaxBalanced / BalancedLeft;                               // Average current for all active EVSE's

        // Check for EVSE's that have a lower MAX current
            if ((BalancedState[n] == 2) && (!CurrentSet[n]) && (Average >= BalancedMax[n])) // Active EVSE, and current not yet calculated?
            {
                Balanced[n] = BalancedMax[n];                                   // Set current to Maximum allowed for this EVSE
                CurrentSet[n] = 1;                                              // mark this EVSE as set.
                BalancedLeft--;                                                 // decrease counter of active EVSE's
                MaxBalanced -= Balanced[n];                                     // Update total current to new (lower) value
                n = 0;                                                          // check all EVSE's again
            } else n++;
        } while (n < 4 && BalancedLeft);

        // All EVSE's which had a Max current lower then the average are set.
        // Now calculate the current for the EVSE's which had a higher Max current
        n = 0;
        if (BalancedLeft)                                                       // Any Active EVSE's left?
        {
            do {                                                                // Check for EVSE's that are not set yet
                if ((BalancedState[n] == 2) && (!CurrentSet[n]))                // Active EVSE, and current not yet calculated?
                {
                    Balanced[n] = MaxBalanced / BalancedLeft;                   // Set current to Average
                    CurrentSet[n] = 1;                                          // mark this EVSE as set.
                    BalancedLeft--;                                             // decrease counter of active EVSE's
                    MaxBalanced -= Balanced[n];                                 // Update total current to new (lower) value
                }
            } while (++n < 4 && BalancedLeft);
        }

        for (n = 0; n < 4; n++) DEBUG_PRINT(("EVSE%u[%u]:%2uA  ", n, BalancedState[n], Balanced[n]));
        DEBUG_PRINT(("\n\r"));
    } // BalancedLeft

}

// Broadcast momentary currents to all Slave EVSE's

void BroadcastCurrent(void) 
{
    char n, x;
    unsigned int cs;

    Tbuffer[0] = 0xff;                                                          // Address Field = ff
    Tbuffer[1] = 0x03;                                                          // Control Field = 03
    Tbuffer[2] = 0x50;                                                          // Protocol = 0x5002
    Tbuffer[3] = 0x02;
    Tbuffer[4] = 0x01;                                                          // Version
    Tbuffer[5] = 0x00;                                                          // Broadcast Address
    Tbuffer[6] = 0x01;                                                          // Command

    n = 7;
    for (x = 1; x < 4; x++) {
        Tbuffer[n++] = 0x00;
        Tbuffer[n++] = Balanced[x];
    }
                                                                                // Frame Check Sequence (FCS) Field
    cs = calc_crc16(Tbuffer, n);                                                // calculate CRC16 from data			
    Tbuffer[n++] = ((unsigned char) (cs));
    Tbuffer[n++] = ((unsigned char) (cs >> 8));

    RS485SendBuf(Tbuffer, n);                                                   // send buffer to RS485 port
}

void SendRS485(char address, char command, char data, char data2)               // Send command over RS485
{
    unsigned int cs;

    Tbuffer[0] = 0xff;                                                          // Address Field = ff
    Tbuffer[1] = 0x03;                                                          // Control Field = 03
    Tbuffer[2] = 0x50;                                                          // Protocol = 0x5002
    Tbuffer[3] = 0x02;
    Tbuffer[4] = 0x01;                                                          // Version
    Tbuffer[5] = address;                                                       // Slave or Broadcast Address
    Tbuffer[6] = command;                                                       // Command

    Tbuffer[7] = data;                                                          // only used in error command
    Tbuffer[8] = data2;                                                         // charge current
                                                                                // Frame Check Sequence (FCS) Field
    cs = calc_crc16(Tbuffer, 9);                                                // calculate CRC16 from data			
    Tbuffer[9] = ((unsigned char) (cs));
    Tbuffer[10] = ((unsigned char) (cs >> 8));

    RS485SendBuf(Tbuffer, 11);                                                  // send buffer to RS485 port
}



// Serial Command line interface
// Display Menu, and process input.
//------------------------------------------------
// Smart EVSE
// -- Main menu --
// CONFIG - Set to Fixed Cable or Type 2 Socket
// MODE   - Set to Smart mode, or Normal EVSE mode
// LOADBL - Set Load Balancing to Disabled, Master or Slave1-3
// MAINS  - Set max MAINS Current (25-100)
// MAX    - Set MAX Charge Current for the EV (16-80)
// MIN    - Set MIN Charge Current the EV will accept
// CAL    - Calibrate CT1
// LOCK   - Cable lock Disable/Solenoid/Motor
// ACCESS - Access control on IO2                    
// RCMON  - Residual Current Monitor on IO3
// L1: 1.2A L2: 5.3A L3: 0.4A (MAX:26A MIN:10A)
//

void RS232cli(void) 
{
    unsigned int n;
    double Inew, Iold;

    printf("\r\n");
    if (menu == 0)                                                              // menu = Main Menu
    {
        if ((strcmp(U2buffer, (const far char *) "MAINS") == 0) && (Mode || (LoadBl == 1))) menu = 1; // Switch to Set Max Mains Capacity (Smart mode or Master)
        if (strcmp(U2buffer, (const far char *) "MAX") == 0) menu = 2;          // Switch to Set Max Current
        if ((strcmp(U2buffer, (const far char *) "MIN") == 0) && (Mode || (LoadBl == 1))) menu = 3; // Switch to Set Min Current (Smart mode or Master)
        if ((strcmp(U2buffer, (const far char *) "CAL") == 0) && Mode) menu = 4;// Switch to Calibrate CT1 (Smart mode)
        if (strcmp(U2buffer, (const far char *) "MODE") == 0) menu = 5;         // Switch to Normal or Smart mode
        if ((strcmp(U2buffer, (const far char *) "LOCK") == 0) && !Config) menu = 6; // Switch to Enable/Disable Cable Lock (Config=Socket)
        if (strcmp(U2buffer, (const far char *) "CONFIG") == 0) menu = 7;       // Switch to Fixed cable or Type 2 Socket
        if ((strcmp(U2buffer, (const far char *) "CABLE") == 0) && Config) menu = 8; // Switch to Set fixed Cable Current limit (Config=Fixed)
        if (strcmp(U2buffer, (const far char *) "LOADBL") == 0) menu = 9;       // Switch to Set Load Balancing
        if (strcmp(U2buffer, (const far char *) "ACCESS") == 0) menu = 10;      // External Start/Stop button on I/O 2
        if (strcmp(U2buffer, (const far char *) "RCMON") == 0) menu = 11;       // Residual Current monitor on I/O 3
    } else if (U2buffer[0] == 0) menu = 0;
    else                                                                        // menu = 1,2,3,4 read entered value from cli
    {
        if (menu == 1 || menu == 2 || menu == 3 || menu == 8) {
            n = (unsigned int) atoi(U2buffer);
            if ((menu == 1) && (n > 9) && (n < 101)) {
                MaxMains = n;                                                   // Set new MaxMains
                write_settings();                                               // Write to eeprom
            } else if ((menu == 2) && (n > 9) && (n < 81)) {
                MaxCurrent = n;                                                 // Set new MaxCurrent
                write_settings();                                               // Write to eeprom
            } else if ((menu == 3) && (n > 5) && (n < 17)) {
                MinCurrent = n;                                                 // Set new MinCurrent
                write_settings();                                               // Write to eeprom
            } else if ((menu == 8) && (n > 12) && (n < 81)) {
                CableLimit = n;                                                 // Set new CableLimit
                write_settings();                                               // Write to eeprom
            } else printf("\r\nError! please check limits\r\n");
        } else if (menu == 4) {
            Inew = atof(U2buffer);
            if ((Inew < 6) || (Inew > 80)) printf("\r\nError! please calibrate with atleast 6A\r\n");
            else {
                Iold = Irms[0] / ICal;
                ICal = (Inew * 10) / Iold;                                      // Calculate new Calibration value
                write_settings();                                               // Write to eeprom
            }
        } else if (menu == 5)                                                   // EVSE Mode
        {
            if (strcmp(U2buffer, (const far char *) "SMART") == 0) {
                Mode = 1;
                write_settings();                                               // Write to eeprom
            } else if (strcmp(U2buffer, (const far char *) "NORMAL") == 0) {
                Mode = 0;
                write_settings();                                               // Write to eeprom
                Error = NO_ERROR;                                               // Clear Errors
            }

        } else if (menu == 6)                                                   // Cable Lock
        {
            if (strcmp(U2buffer, (const far char *) "SOLENOID") == 0) {
                Lock = 1;
                write_settings();                                               // Write to eeprom
            } else if (strcmp(U2buffer, (const far char *) "MOTOR") == 0) {
                Lock = 2;
                write_settings();                                               // Write to eeprom
            } else if (strcmp(U2buffer, (const far char *) "DISABLE") == 0) {
                Lock = 0;
                write_settings();                                               // Write to eeprom
            }
        } else if (menu == 7)                                                   // Configuration Mode
        {
            if (strcmp(U2buffer, (const far char *) "FIXED") == 0) {
                Config = 1;
                write_settings();                                               // Write to eeprom
            } else if (strcmp(U2buffer, (const far char *) "SOCKET") == 0) {
                Config = 0;
                write_settings();                                               // Write to eeprom
            }
        } else if (menu == 9)                                                   // Load Balancing Mode
        {
            if (strcmp(U2buffer, (const far char *) "DISABLE") == 0) {
                LoadBl = 0;
                write_settings();                                               // Write to eeprom
            } else if (strcmp(U2buffer, (const far char *) "MASTER") == 0) {
                LoadBl = 1;
                write_settings();                                               // Write to eeprom
            } else if (strcmp(U2buffer, (const far char *) "SLAVE1") == 0) {
                LoadBl = 2;
                write_settings();                                               // Write to eeprom
            } else if (strcmp(U2buffer, (const far char *) "SLAVE2") == 0) {
                LoadBl = 3;
                write_settings();                                               // Write to eeprom
            } else if (strcmp(U2buffer, (const far char *) "SLAVE3") == 0) {
                LoadBl = 4;
                write_settings();                                               // Write to eeprom
            }
        } else if (menu == 10)                                                  // Start/Stop button on I/O 2
        {
            if (strcmp(U2buffer, (const far char *) "DISABLE") == 0) {
                Access = 0;
                write_settings();                                               // Write to eeprom
            } else if (strcmp(U2buffer, (const far char *) "SWITCH") == 0) {
                Access = 1;
                write_settings();                                               // Write to eeprom
            }
        } else if (menu == 11)                                                  // RCD on I/O 3
        {
            if (strcmp(U2buffer, (const far char *) "DISABLE") == 0) {
                RCmon = 0;
                write_settings();                                               // Write to eeprom
            } else if (strcmp(U2buffer, (const far char *) "ENABLE") == 0) {
                RCmon = 1;
                write_settings();                                               // Write to eeprom
            }
        }

        menu = 0;
    }


    if (menu == 0) {
        printf("\r\n---------------------- SMART EVSE  ----------------------\r\n v");
        printf(VERSION);
        printf(" for detailed instructions, see www.smartevse.org\r\n");
        printf(" Internal Temperature: %2u C\r\n", TempEVSE);
        printf("---------------------------------------------------------\r\n");
        //printf("CONFIG - Set to Fixed Cable or Type 2 Socket       (");
        printf(MenuConfig);
        printf("      - ");
        if (Config) printf("Fixed Cable\r\n");
        else printf("Type 2 Socket\r\n");
        //printf("MODE   - Set to Smart mode or Normal EVSE mode     (");
        printf(MenuMode);
        printf("    - ");
        if (Mode) printf("Smart\r\n");
        else printf("Normal\r\n");
                                                                                // Load Balancing menu item
        printf(MenuLoadBl);
        printf("                  - ");
        if (LoadBl == 0) printf("Disabled\r\n");
        else if (LoadBl == 1) printf("Master\r\n");
        else if (LoadBl == 2) printf("Slave1\r\n");
        else if (LoadBl == 3) printf("Slave2\r\n");
        else printf("Slave3\r\n");


        if (Mode || LoadBl == 1) {
        //printf("MAINS  - Set Max MAINS Current (Smart mode)        (%3u A)\r\n",MaxMains);
            printf(MenuMains);
            printf("                    - %3u A\r\n", MaxMains);
        }
        //printf("MAX    - Set MAX Charge Current for the EV         ( %2u A)\r\n",MaxCurrent);
        printf(MenuMax);
        printf("        -  %2u A\r\n", MaxCurrent);
        if (Mode || (LoadBl == 1)) {
        //printf("MIN    - Set MIN Charge Current the EV will accept ( %2u A)\r\n",MinCurrent);
            printf(MenuMin);
            printf("-  %2u A\r\n", MinCurrent);
        }
        if (Config) {
        //printf("CABLE  - Set Fixed Cable Current limit             ( %2u A)\r\n",CableLimit);
            printf(MenuCable);
            printf("            -  %2u A\r\n", CableLimit);
        } else {
        //printf("LOCK   - Cable lock Enable/Disable                 (");
            printf(MenuLock);
            printf("              - ");
            if (Lock == 1) printf("Solenoid\r\n");
            else if (Lock == 2) printf("Motor\r\n");
            else printf("Disabled\r\n");
        }
        if (Mode) printf("CAL    - Calibrate CT1  (CT1:%3u.%01uA CT2:%3u.%01uA CT3:%3u.%01uA)\r\n", (unsigned int) Irms[0] / 10, (unsigned int) Irms[0] % 10, (unsigned int) Irms[1] / 10, (unsigned int) Irms[1] % 10, (unsigned int) Irms[2] / 10, (unsigned int) Irms[2] % 10);

        printf(MenuAccess);
        printf("                    - ");                                       //Access control on IO2
        if (Access == 0) printf("Disabled\r\n");
        else printf("Switch\r\n");

        printf(MenuRCmon);
        printf("          - ");                                                 // Residual current monitor on IO3
        if (RCmon == 0) printf("Disabled\r\n");
        else printf("Enabled\r\n");

        printf(">");
    } else if (menu == 1) {
        printf("WARNING - DO NOT SET CURRENT HIGHER THAN YOUR CIRCUIT BREAKER\r\n");
        printf("OR GREATER THAN THE RATED VALUE OF THE EVSE\r\n");
        printf("MAINS Current set to: %u A\r\nEnter new max MAINS Current (10-100): ", MaxMains);
    } else if (menu == 2) {
        printf("WARNING - DO NOT SET CURRENT HIGHER THAN YOUR CIRCUIT BREAKER\r\n");
        printf("OR GREATER THAN THE RATED VALUE OF THE EVSE\r\n");
        printf("MAX Current set to: %u A\r\nEnter new MAX Charge Current (10-80): ", MaxCurrent);
    }
    else if (menu == 3) {
        printf("MIN Charge Current set to: %u A\r\nEnter new MIN Charge Current (6-16): ", MinCurrent);
    } else if (menu == 4) {
        printf("CT1 reads: %3u.%01u A\r\nEnter new Measured Current for CT1: ", (unsigned int) Irms[0] / 10, (unsigned int) Irms[0] % 10);
    } else if (menu == 5) {
        printf("EVSE set to : ");
        if (Mode) printf("Smart mode\r\n");
        else printf("Normal mode\r\n");
        printf("Enter new EVSE Mode (SMART/NORMAL): ");
    } else if (menu == 6) {
        printf("Cable lock set to : ");
        if (Lock == 2) printf("Motor\r\n");
        else if (Lock == 1) printf("Solenoid\r\n");
        else printf("Disable\r\n");
        printf("Enter new Cable lock mode (DISABLE/SOLENOID/MOTOR): ");
    } else if (menu == 7) {
        printf("Configuration : ");
        if (Config) printf("Fixed Cable\r\n");
        else printf("Type 2 Socket\r\n");
        printf("Enter new Configuration (FIXED/SOCKET): ");
    } else if (menu == 8) {
        printf("WARNING - DO NOT SET CURRENT HIGHER THAN YOUR CIRCUIT BREAKER\r\n");
        printf("OR GREATER THAN THE RATED VALUE OF THE CHARGING CABLE\r\n");
        printf("Fixed Cable Current limit set to: %u A\r\nEnter new limit (13-80): ", CableLimit);
    } else if (menu == 9) {
        printf("Load Balancing set to : ");
        if (LoadBl == 0) printf("Disabled\r\n");
        else if (LoadBl == 1) printf("Master\r\n");
        else printf("Slave%u\r\n", LoadBl - 1);
        printf("Enter Load Balancing mode (DISABLE/MASTER/SLAVE1/SLAVE2/SLAVE3): ");
    } else if (menu == 10) {
        printf("Access Control on I/O 2 set to : ");
        if (Access == 0) printf("Disabled\r\n");
        else printf("Switch\r\n");
        printf("Access Control on IO2 (DISABLE/SWITCH): ");
    } else if (menu == 11) {
        printf("Residual Current Monitor on I/O 3 set to : ");
        if (RCmon == 0) printf("Disabled\r\n");
        else printf("Enabled\r\n");
        printf("Residual Current Monitor on IO3 (DISABLE/ENABLE): ");
    }

    ISR2FLAG = 0;                                                               // clear flag
    idx2 = 0;                                                                   // reset buffer pointer

}

void delay(unsigned int d) {
    unsigned long x;
    x = Timer;                                                                  // read Timer value (increased every ms)
    while (Timer < (x + d)) {
    }
}



// TestIO will be called after a special RS485 command has been received.

void TestIO(void)                                                               // Test connector should be connected to CON1
{
    unsigned char error = 0;

    if (TestState == 1) {
        CCP2CON = 0;                                                            // Disable PWM on LED output
        LATBbits.LATB3 = 0;                                                     // set IO1 to low, State B

        SOLENOID_OFF;
        delay(2000);                                                            // wait 2 seconds for capacitor to charge

        CCP1CON = 0;                                                            // PWM off
        PORTCbits.RC2 = 0;                                                      // Control pilot static -12V
        delay(100);                                                             // wait 100 msec
        if (ReadPilot() == PILOT_DIODE) TestState = STATE_B;                    // should be -12V
        else error = 1;
    } else if (TestState == STATE_B && State == STATE_B)                        // +9V (B state) OK, now test PP input
    {
        ProximityPin();
        if (MaxCapacity != 32) error ^= 2;                                      // error!
        TestState = STATE_C;
        LATBbits.LATB3 = 1;                                                     // set IO1 to high State B->State C 
    } else if (TestState == STATE_C && State == STATE_C)                        //+6V (C state) OK
    {
        Lock = 1;                                                               // enable Lock
        TRISB = 0b10000101;                                                     // RB7(RX2), RB0,2 inputs. all other output
        LATBbits.LATB1 = 1;                                                     // set IO3 to high
        delay(5000);                                                            // wait 5 seconds for capacitor to charge
        if (PORTCbits.RC1 == 1) error ^= 4;                                     // error, Solenoid not activated !

        delay(10);
                                                                                // Contactor + I/O test
        if (PORTBbits.RB2 == 1)                                                 // sample input PIN IO2
        {
            LATBbits.LATB1 = 0;
            delay(10);
            if (PORTBbits.RB2 != 0) error ^= 8;                                 // error
        } else error ^= 8;                                                      // error

        TestState = STATE_CB;
        LATBbits.LATB3 = 0;                                                     // set IO1 to low State C->State B 
    } else if (TestState == STATE_CB && State == STATE_B) {
        TRISB = 0b10000001;                                                     // RB7(RX2), RB0 inputs. all other output
        delay(1000);
        if (PORTCbits.RC1 == 0) error ^= 4;                                     // Solenoid FAIL!!
        else if (!error) {
            TestState = 80;
            Lock = 0;
            GLCD();
        }
    }

    if (error) {
        TRISB = 0b10000001;                                                     // Reset all IO to default values
        LATBbits.LATB1 = 0;
        LATBbits.LATB2 = 0;
        LATBbits.LATB3 = 0;                                                     // set IO1 to low State C->State B 
        Lock = 0;
        Error = Test_IO;
        TestState = error;
        State = STATE_A;
    }
}

void init(void) {
    OSCCON = 0b01101100;                                                        // setup external oscillator
    OSCCON2 = 0b00000100;                                                       // primary Oscillator On.

    RCON = 0b10011111;                                                          // Set Interrupt priority 

    PMD0 = 0b00000000;                                                          // Perhiperal Module Enable/Disable
    PMD1 = 0b00000000;                                                          // All enabled
    PMD2 = 0b00000000;

    PORTA = 0;                                                                  // Init PORTA
    ANSELA = 0b00000111;                                                        // RA0, RA1, RA2 are analog inputs (pin 2,3,4)
    TRISA = 0b00000111;                                                         // Set RA0,RA1,RA2 as inputs

    PORTB = 0;
    ANSELB = 0;                                                                 // All digital IO
    TRISB = 0b10000111;                                                         // RB7(RX2), RB0-RB2 inputs. all other output
    WPUB = 0b10000111;                                                          // weak pullup on RB7 and RB0-RB2    
    INTCON2bits.RBPU = 0;                                                       // Enable weak pullups on PORTB

    PORTC = 0;
    ANSELC = 0;                                                                 // All digital IO
    TRISC = 0b10000010;                                                         // RC1 and RC7 input (RX1), all other output

    SPBRGH1 = 13;                                                               // Initialize UART 1 (RS485)
    SPBRG1 = 4;                                                                 // Baudrate 1200 
    BAUDCON1 = 0b00001000;                                                      // 16 bit Baudrate register is used
    TXSTA1 = 0b00100100;                                                        // Enable TX, 8 bit, Asynchronous mode
    RCSTA1 = 0b10010000;                                                        // Enable serial port TX and RX, 8 bit. 

    SPBRGH2 = 0;                                                                // Initialize UART 2
    SPBRG2 = 34;                                                                // Baudrate 115k2 (114285)
    //	SPBRG2 = 207;                                                           // Baudrate 19k2
    BAUDCON2 = 0b00001000;                                                      // 16 bit Baudrate register is used
    TXSTA2 = 0b00100100;                                                        // Enable TX, 8 bit, Asynchronous mode
    RCSTA2 = 0b10010000;                                                        // Enable serial port TX and RX, 8 bit. 

    VREFCON0 = 0b10100000;                                                      // Fixed Voltage reference set to 2.048V

    ADCON0 = 0b00000001;                                                        // ADC On input AN0 (Pilot)
    ADCON1 = 0;
    ADCON2 = 0b10000101;                                                        // Right justify, Tacq = 0 uS, FOSC/16

    T0CON = 0b10000111;                                                         // Timer 0 @ 16Mhz => 32 uS Timer0, 16 bit counter, 1:256 prescaler

    PR2 = 249;                                                                  // Timer 2 frequency value -> 1Khz @ 16 Mhz
    T2CON = 0b00000110;                                                         // Timer 2 ON, prescaler 1:16
    CCP1CON = 0;                                                                // PWM off (Control Pilot signal)
    CCP2CON = 0;                                                                // PWM off (Led on I/O 1)

    PR4 = 249;                                                                  // Timer 4 frequency value -> 1Khz @ 16 Mhz
    T4CON = 0b00000110;                                                         // Timer 4 ON, prescaler 1:16

    // SPI registers
    SSP1STAT = 0b00000000;                                                      // 0 = Input data sampled at middle of data output time
                                                                                // 0 = Transmit occurs on transition from Idle to active clock state
    SSP1CON1 = 0b00010000;                                                      // Idle state for clock is a high level, SPI Master mode, clock = FOSC/4
    SSP1CON1 = 0b00110000;                                                      // SPI enabled,Idle state for clock is a high level, SPI Master mode, clock = FOSC/4

    PIE1bits.RC1IE = 1;                                                         // enable receive Interrupt for UART1
    PIE3bits.RC2IE = 1;                                                         // enable receive Interrupt for UART2
    PIE5bits.TMR4IE = 1;                                                        // enable Timer4 Interrupt


    INTCONbits.GIEH = 1;                                                        // global High Priority interrupts enabled
    INTCONbits.GIEL = 0;                                                        // global Low Priority interrupts disabled

    SOLENOID_OFF;                                                               // R and W outputs held at Capacitor voltage (+12V) 

    CCPR2L = 0;                                                                 // LED DutyCycle 0%
    CCP2CON = 0x0C;                                                             // LED PWM on

    printf("\r\nSmart EVSE powerup.\r\n");

}

void main(void) {
    char *pBytes;
    char x, n;
    unsigned char pilot, count = 0, timeout = 5;
    char DiodeCheck = 0;
    char SlaveAdr, Command, Broadcast = 0, Switch_count = 0;
    unsigned int Current;

    init();                                                                     // initialize ports, ADC, UARTs etc

    read_settings();                                                            // from EEprom
    IsetBalanced = MaxMains * 10;                                               // Initially set to MaxMains

    GLCD_init();
    GLCD_version();                                                             // Display Version

    RCONbits.POR = 1;                                                           // flag that future resets are not POR resets

    while (1)                                                                   // MAIN loop
    {

                
        if (TestState) TestIO();                                                // TestMode. Test all I/O of Module

        if (ISR2FLAG) RS232cli();                                               // RS232 command line interface

        if (!ISRTXFLAG && TXSTA1bits.TRMT) LATBbits.LATB5 = 0;                  // set RS485 transceiver to receive if the last character has been sent

        BlinkLed();                                                             // Handle the blinking of the 12V LED

        TRISC = 0b10100011;                                                     // Set RC5 and RC0 to input. Make sure there are pull-ups on these pins.
        NOP();
        NOP();
        x = (PORTC & 0b00100001);                                               // Read Two Button Inputs on RC5(>) and RC0(select)
        ButtonState = (x >> 3);
        ButtonState = ButtonState | ((x << 1) & 0x02);                          // arranged to lowest bits
        ButtonState = ButtonState | (PORTB & 0x01);                             // Read the state of the last button RB0(<).
        TRISC = 0b10000010;                                                     // RC1 and RC7 input (RX1), all other output

        //printf("ButtonState %02x\r",ButtonState);

        if ((ButtonState != 0x07) || (ButtonState != OldButtonState)) GLCDMenu(ButtonState); // Any button pressed or just released?

        if (LCDNav > 1 && (ScrollTimer + 5000 < Timer) && (!SubMenu)) GLCDHelp();   // Update/Show Helpmenu


        if (PORTBbits.RB2 == 0)                                                 // Switch input pulled low?
        {
            if (Switch_count++ > 5) {
                if (AccessTimer == 0) {
                    if (Access)                                                 // Menu option Access is enabled (set to Switch))
                    {
                        if (Access_bit) {
                            Access_bit = 0;                                     // Toggle Access bit on/off
                            State = STATE_A;                                    // Switch back to state A
                        } else Access_bit = 1;

                        printf("access: %d ", Access_bit);
                    } else if (State == STATE_C)                                // Menu option Access is set to Disabled
                    {                                                           // We only use the switch/button now to STOP charging
                        State = STATE_A;
                        if (!TestState) ChargeDelay = 15;                       // Keep in State A for 15 seconds, so the Charge cable can be removed.
                    }

                    if (RCmon == 1 && Error == RCD_TRIPPED && PORTBbits.RB1 == 0) // RCD was tripped, but RCD level is back to normal
                    {
                        Error = NO_ERROR;                                       // Clear error , by pressing the button
                    }
                }                                                               // Reset timer while button is pressed.
                AccessTimer = 200;                                              // this de-bounces the switch, and makes sure we don't toggle between Access and No-Access.    
                Switch_count = 0;                                               // make sure that noise on the input does not switch off charging
            }
        } else Switch_count = 0;

        if (RCmon == 1 && PORTBbits.RB1 == 1)                                   // RCD monitor active, and RCD DC current > 6mA ?
        {
            State = STATE_A;
            Error = RCD_TRIPPED;
            LCDTimer = 0;                                                       // display the correct error message on the LCD
        }


        if ((State == STATE_COMM_A) && (Timer > ACK_TIMEOUT))                   // Wait for response from Master
        {
            SendRS485(LoadBl - 1, 0x01, 0x00, 0x00);                            // Send command to Master
            printf("01 sent to Master, charging stopped\r\n");
            Timer = 0;                                                          // Clear the Timer
        }

        if (State == STATE_A)                                                   // ############### EVSE State A #################
        {
            CCP1CON = 0;                                                        // PWM off
            PORTCbits.RC2 = 1;                                                  // Control pilot static +12V
            CONTACTOR_OFF;                                                      // Contactor OFF
            BalancedState[0] = 0;                                               // Mark as inactive

            pilot = ReadPilot();
            if (pilot == PILOT_12V)                                             // Check if we are disconnected, or forced to State A, but still connected to the EV
            {
                ChargeDelay = 0;                                                // Clear ChargeDelay when disconnected.
            }
            if (pilot == PILOT_9V)                                              // switch to State B ?
            {
                if ((NextState == STATE_B) && (Access_bit || Access == 0))      // Access is permitted when Access is disabled or Access_bit=1
                {
                    if (count++ > 25)                                           // repeat 25 times (changed in v2.05)
                    {
                        if (IsCurrentAvailable() == 1) Error = NOCURRENT;       // Enough current available to start Charging?

                        if (ChargeDelay == 0 && Error == NO_ERROR) {
                            DiodeCheck = 0;
                            ProximityPin();                                     // Sample Proximity Pin
                            printf("Cable limit: %uA  Max: %uA \r\n", MaxCapacity, MaxCurrent);
                            if (MaxCurrent > MaxCapacity) ChargeCurrent = MaxCapacity; // Do not modify Max Cable Capacity or MaxCurrent (fix 2.05)
                            else ChargeCurrent = MaxCurrent;                    // Instead use new variable ChargeCurrent

                            if (LoadBl > 1)                                     // Load Balancing : Slave 
                            {
                                SendRS485(LoadBl - 1, 0x02, 0x00, ChargeCurrent); // Send command to Master, followed by Max Charge Current
                                printf("02 sent to Master, requested %uA\r\n", ChargeCurrent);
                                State = STATE_COMM_B;
                                Timer = 0;                                      // Clear the Timer
                            } else {                                            // Load Balancing: Master or Disabled
                                BalancedMax[0] = MaxCapacity;
                                BalancedState[0] = 1;                           // Mark as active
                                State = STATE_B;                                // switch to State B
                                BacklightTimer = BACKLIGHT;                     // Backlight ON
                                BACKLIGHT_ON;
                                printf("STATE A->B\r\n");
                            }
                        }
                    }
                } else {
                    NextState = STATE_B;
                    count = 0;
                }

            }
        }

        if (State == STATE_COMM_B)                                              // Wait for response from Master
        {
            if (Timer > ACK_TIMEOUT) State = STATE_A;
        }


        if (State == STATE_B)                                                   // ############### EVSE State B #################
        {
                                                                                // measure voltage at ~5% and ~90% of PWM cycle
            if ((TMR2 > 7) && (TMR2 < 24))                                      // PWM cycle 3% - 9% (should be high)
            {
                pilot = ReadPilot();
                if (pilot == PILOT_12V)                                         // Disconnected?
                {
                    if (NextState == STATE_A) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            State = STATE_A;                                    // switch to STATE_A
                            printf("STATE B->A\r\n");
                            if (LoadBl > 1)                                     // Load Balancing : Slave 
                            {
                                State = STATE_COMM_A;                           // Tell Master we switched to State A
                                Timer = ACK_TIMEOUT + 1;                        // Set the timer to Timeout value, so that it expires immediately
                            }
                        }
                    } else {
                        NextState = STATE_A;
                        count = 0;
                    }
                } else if (pilot == PILOT_6V) {
                    if ((NextState == STATE_C) && (DiodeCheck == 1)) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            if ((Error == NO_ERROR) && (ChargeDelay == 0)) {
                                if (LoadBl > 1)                                 // Load Balancing : Slave 
                                {
                                    SendRS485(LoadBl - 1, 0x03, 0x00, ChargeCurrent); // Send command to Master, followed by Charge Current
                                    printf("03 sent to Master, requested %uA\r\n", ChargeCurrent);
                                    State = STATE_COMM_C;
                                    Timer = 0;                                  // Clear the Timer
                                } else {                                        // Load Balancing: Master or Disabled
                                    BalancedMax[0] = ChargeCurrent;
                                    if (IsCurrentAvailable() == 0) {
                                        BalancedState[0] = 2;                   // Mark as Charging
                                        Balanced[0] = 0;                        // For correct baseload calculation set current to zero
                                        CalcBalancedCurrent(1);                 // Calculate charge current for all connected EVSE's

                                        CONTACTOR_ON;                           // Contactor ON
                                        DiodeCheck = 0;
                                        State = STATE_C;                        // switch to STATE_C
                                        LCDTimer = 0;
                                        Timer = 0;                              // reset msTimer and ChargeTimer
                                        if (!LCDNav)                            // Don't update the LCD if we are navigating the menu
                                        {
                                            GLCD();                             // immediately update LCD
                                        }
                                        printf("STATE B->C\r\n");
                                    }
                                    else Error = NOCURRENT;
                                }
                            }
                        }
                    } else {
                        NextState = STATE_C;
                        count = 0;
                    }
                } else                                                          // PILOT_9V
                {
                    if (NextState == STATE_B)                                   // Did the EV switch from State_C to State_B?
                    {                                                           // then there was probably not enough current available
                                                                                // or the charging was finished.
                    } else NextState = 0;                                       // no State to switch to
                }
            }
            if (TMR2 > 230)                                                     // PWM > 92%
            {
                while (TMR2 < 242);                                             // wait till TMR2 is in range, otherwise we'll miss it (blocking)
                if ((TMR2 > 241) && (TMR2 < 249));                              // PWM cycle >= 96% (should be low)
                {
                    pilot = ReadPilot();
                    if (pilot == PILOT_DIODE) DiodeCheck = 1;                   // Diode found, OK
                    else DiodeCheck = 0;
                }
            }
        }

        if ((State == STATE_COMM_C) && (Timer > ACK_TIMEOUT)) {
            DiodeCheck = 0;
            State = STATE_B;                                                    // switch back to STATE_B
            printf("No ack, STATE C->B\r\n");
        }


        if (State == STATE_C)                                                   // ############### EVSE State C #################
        {
                                                                                // measure voltage at ~5% of PWM cycle
            if ((TMR2 > 7) && (TMR2 < 24))                                      // cycle 3% - 9% (should be high)
            {
                pilot = ReadPilot();
                if ((pilot == PILOT_12V) || (pilot == PILOT_NOK))               // Disconnected or Error?
                {
                    if (NextState == STATE_A) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            State = STATE_A;                                    // switch back to STATE_A
                            printf("STATE C->A\r\n");
                            GLCD_init();                                        // Re-init LCD
                            if (LoadBl > 1)                                     // Load Balancing : Slave 
                            {
                                State = STATE_COMM_A;                           // Tell Master we switched to State A
                                Timer = ACK_TIMEOUT + 1;                        // Set the timer to Timeout value, so that it expires immediately
                            }
                            else BalancedState[0] = 0;                          // Master or Disabled
                                                                                // Mark EVSE as disconnected
                        }
                    } else {
                        NextState = STATE_A;
                        count = 0;
                    }
                } else if (pilot == PILOT_9V) {
                    if (NextState == STATE_B) {
                        if (count++ > 25)                                       // repeat 25 times
                        {

                            CONTACTOR_OFF;                                      // Contactor OFF
                            GLCD_init();                                        // Re-init LCD
                            DiodeCheck = 0;
                            State = STATE_B;                                    // switch back to STATE_B
                            if (LoadBl > 1)                                     // Load Balancing : Slave 
                            {
                                State = STATE_COMM_CB;                          // Send 04 command to Master
                                Timer = ACK_TIMEOUT + 1;                        // Set the timer to Timeout value, so that it expires immediately
                            } else BalancedState[0] = 0;                        // Master or Disabled
                                                                                // Mark EVSE as inactive (still State B)
                            printf("STATE C->B\r\n");
                        }
                    } else {
                        NextState = STATE_B;
                        count = 0;
                    }
                } else                                                          // PILOT_6V
                {
                    NextState = 0;                                              // no State to switch to					
                }
            }

        } // end of State C code

        if ((State == STATE_COMM_CB) && (Timer > ACK_TIMEOUT)) {
            SendRS485(LoadBl - 1, 0x04, 0x00, 0x00);                            // Send command to Master
            printf("04 sent to Master, charging stopped\r\n");
            Timer = 0;                                                          // Clear the Timer
        }

        if (Error == NOCURRENT) {
            if (ChargeDelay == 0) printf("Not enough current available!\r\n");
            Error = LESS_6A;
            State = STATE_A;
            ChargeDelay = CHARGEDELAY;                                          // Set Chargedelay after the error clears
        }

        if (RCSTA1bits.OERR)                                                    // Uart1 Overrun Error?
        {
            RCSTA1bits.CREN = 0;
            RCSTA1bits.CREN = 1;                                                // Restart Uart
        }
        if (RCSTA2bits.OERR)                                                    // Uart2 Overrun Error?
        {
            RCSTA2bits.CREN = 0;
            RCSTA2bits.CREN = 1;                                                // Restart Uart
        }

        x = TMR0L;
        if (TMR0H >= 0x3d)                                                      // 1 second timer
        {
            TMR0H = 0;
            TMR0L = 0;

            Temp();                                                             // once a second, measure temperature

            if (ChargeDelay > 0) ChargeDelay--;                                 // Decrease Charge Delay counter

            if ((TempEVSE < 55) && (Error == TEMP_HIGH))                        // Temperature below limit?
            {
                Error = NO_ERROR;                                               // clear Error
            }

            if ((Error == LESS_6A) && (LoadBl < 2) && (IsCurrentAvailable() == 0)) {
                Error = NO_ERROR;                                               // Clear Errors if there is enough current available
            }

            if ((timeout == 0) && (Error == NO_ERROR))                          // timeout if CT current measurement takes > 10 secs
            {
                Error = CT_NOCOMM;
                State = STATE_A;                                                // switch back to state A
                printf("Error, communication error!\r\n");
                for (x = 0; x < 4; x++) BalancedState[x] = 0;                   // reset all states
            } else if (timeout) timeout--;

            if (TempEVSE >= 65)                                                 // Temperature too High?
            {
                Error = TEMP_HIGH;
                State = STATE_A;                                                // ERROR, switch back to STATE_A
                printf("Temperature too High!\r\n");
                for (x = 0; x < 4; x++) BalancedState[x] = 0;                   // reset all states
            }

            GLCD();                                                             // once a second, update LCD

            //			if (State==STATE_C) ChargeTimer=Timer/1000;	// Update ChargeTimer (unused)
            //			printf("STATE:%c Pilot:%u ChargeDelay:%u CT1:%3u.%01uA CT2:%3u.%01uA CT3:%3u.%01uA Imeas:%3u.%01uA Iset:%u.%01uA\r\n",State-1+'A',pilottest, ChargeDelay, (unsigned int)Irms[0]/10, (unsigned int)Irms[0]%10, (unsigned int)Irms[1]/10, (unsigned int)Irms[1]%10, (unsigned int)Irms[2]/10, (unsigned int)Irms[2]%10,(unsigned int)Imeasured/10,(unsigned int)Imeasured%10,(unsigned int)Iset/10,(unsigned int)Iset%10);

            if (!Mode)                                                          // Normal mode
            {
                Imeasured = 0;                                                  // No measurements, so we set it to zero
                if (Broadcast) Broadcast--;                                     // once every two seconds, Broadcast charge current to all EVSE's

                if (LoadBl < 2 && !Broadcast)                                   // Load Balancing mode: Master or Disabled
                {
                    CalcBalancedCurrent(0);                                     // Calculate charge current for connected EVSE's
                    if (LoadBl == 1) BroadcastCurrent();                        // Send to all EVSE's (only in Master mode)

                    if ((State == STATE_B) || (State == STATE_C)) SetCurrent(Balanced[0]); // set PWM output for Master
                    Broadcast = 2;                                              // reset counter to 2 seconds
                    timeout = 10;                                               // reset timeout counter (not checked for Master)
                }
            }

        } // end 1 second timer



        /*  RS485 serial data is received by the ISR routine, and processed here..
            Reads serial packet with Raw Current values, measured from 1-N CT's, over a RS485 serial line
            baudrate is 1200 bps

            packet structure from sensorbox: 	
            <protocol>,<version>,<nr of samples>,<sample 1>...<sample n>,<crc16>
            protocol = 0x5001 (2 bytes)
            version = 1 (1 byte)
            nr of samples = 1 byte
            samples are 4 bytes (double)
            crc16 is 2 bytes
            total 4+(n*4)+2 bytes (+ HDLC overhead)


            Load balancing RS485 commands:
            protocol  0x5002		= load balancing commands
            version 	0x01
            adress		0x01		= slave 1 (communication always to/from master)
                                    = broadcast from master = 0x00 
            command		0x02		= request to charge
            data	  0x0020		= @ 32A
            data	  0x0000		= unused data bytes

            commands Slave -> Master: 
                        0x01		= State A
                        0x02		= request to charge , next two bytes = requested charge current
                        0x03		= charging (State C) next two bytes = requested charge current
                        0x04		= charging stopped (state C->B), followed by two empty bytes

            commands Master -> Slave:
                        0x81		= Ack, State A
                        0x82		= ack request to charge , next two bytes = calculated charge current
                        0x83		= ACK charging , next two bytes = calculated charge current
                        0x84		= ACK charging done.
			
            broadcast commands:
                        0x01		= Charge current for each Slave EVSE (Smart mode: sent every 2 seconds, Normal mode: sent when needed)
                                      followed by 6 bytes of data (2 bytes per EVSE)
                        0x02		= Error occurred, switch to State A. Error code in next databyte.
         */

        if (ISRFLAG > 1)                                                        // complete packet detected?
        {
            crc16 = calc_crc16(U1buffer, ISRFLAG);

            if (ISRFLAG > 10 && U1buffer[2] == 0x50 && U1buffer[3] == 0x01 && crc16 == GOODFCS16) // check CRC
            {                                                                   // We have received a data packet from the sensorbox
                n = 6;
                Imeasured = 0;                                                  // reset Imeasured value
                if (U1buffer[5] > 3) U1buffer[5] = 3;                           // protect against buffer overflow
                for (x = 0; x < U1buffer[5]; x++)                               // Nr of CTs    
                {
                    pBytes = (char*) &Irms[x];
                    *pBytes++ = (unsigned char) U1buffer[n++];
                    *pBytes++ = (unsigned char) U1buffer[n++];
                    *pBytes++ = (unsigned char) U1buffer[n++];
                    *pBytes = (unsigned char) U1buffer[n++];
                    Irms[x] = Irms[x] * ICal;                                   // adjust CT values with Calibration value
                    if (Irms[x] > Imeasured) Imeasured = (unsigned int) Irms[x]; // Imeasured holds highest Irms of all channels
                }
                if (U1buffer[4] == 0xA5 && !TestState) TestState = 1;           // TestIO command received, perform selfcheck (test interface required)

                if (Mode && LoadBl < 2)                                         // Load Balancing mode: Smart/Master or Disabled
                {
                    CalcBalancedCurrent(0);                                     // Calculate dynamic charge current for connected EVSE's

                    if (NoCurrent > 2 || (Imeasured > (MaxMains * 20)))         // No current left, or Overload (2x Maxmains)?
                    {                                                           // STOP charging for all EVSE's
                        Error = NOCURRENT;                                      // Display error message
                        for (x = 0; x < 4; x++) BalancedState[x] = 0;           // Set all EVSE's to State A

                        SendRS485(0x00, 0x02, LESS_6A, ChargeDelay);            // Broadcast Error code over RS485
                        NoCurrent = 0;
                    } else if (LoadBl) BroadcastCurrent();                      // Master sends current to all connected EVSE's

                    if ((State == STATE_B) || (State == STATE_C)) {
                        SetCurrent(Balanced[0]);                                // Set current for Master EVSE in Smart Mode
                    }
                    //printf("STATE:%c ChargeDelay:%u NoCurrent:%u CT1:%3u.%01uA CT2:%3u.%01uA CT3:%3u.%01uA Imeas:%3u.%01uA IsetBalanced:%u.%01uA\r\n",State-1+'A', ChargeDelay, NoCurrent, (unsigned int)Irms[0]/10, (unsigned int)Irms[0]%10, (unsigned int)Irms[1]/10, (unsigned int)Irms[1]%10, (unsigned int)Irms[2]/10, (unsigned int)Irms[2]%10,(unsigned int)Imeasured/10,(unsigned int)Imeasured%10,(unsigned int)IsetBalanced/10,(unsigned int)IsetBalanced%10);

                    timeout = 10;                                               // reset 10 second timeout
                } else Imeasured = 0;                                           // In case Sensorbox is connected in Normal mode. Clear measurement.

            } else if (ISRFLAG > 6 && U1buffer[2] == 0x50 && U1buffer[3] == 0x02 && crc16 == GOODFCS16) // We received a command
            {
                SlaveAdr = U1buffer[5];                                         //EVSE 0x01 - 0x03 (slaves) 
                Command = U1buffer[6];
                Current = U1buffer[8];

                timeout = 10;                                                   // reset 10 second timeout

                if (SlaveAdr == 0x00 && Command == 0x01 && LoadBl > 1)          // Broadcast message from Master->Slaves, Set Charge current
                {
                    Balanced[0] = U1buffer[4 + (LoadBl * 2)];
                    if ((State == STATE_B) || (State == STATE_C)) SetCurrent(Balanced[0]); // Set charge current, and PWM output
                    DEBUG_PRINT(("Broadcast received, Slave %uA \r\n", Balanced[0]));
                }
                else if (SlaveAdr == 0x00 && Command == 0x02 && LoadBl > 1)     // Broadcast message from Master->Slaves, Error Occured!
                {
                    State = STATE_A;
                    Error = U1buffer[7];
                    ChargeDelay = CHARGEDELAY;
                    DEBUG_PRINT(("Broadcast Error message received!\r\n"));
                }

                if (SlaveAdr == (LoadBl - 1))                                   // We are a Slave, Direct commands from the Master are handled here
                {
                    if (Command == 0x81)                                        // SLAVE: ACK State A
                    {
                        State = STATE_A;
                        DEBUG_PRINT(("81 ACK State A\r\n"));
                    } else if (Command == 0x82)                                 // ACK received, followed by assigned charge current
                    {
                        if (Current == 0)                                       // If charge current is zero, No current is available.
                        {
                            Error = NOCURRENT;
                            DEBUG_PRINT(("82 ACK "));                           // No current available
                        } else {
                            SetCurrent(Current);
                            State = STATE_B;
                            DEBUG_PRINT(("82 ACK State A->B, charge current: %uA\r\n", Current));
                        }
                    } else if (Command == 0x83)                                 // ACK received, state C followed by charge current
                    {
                        if (Current == 0)                                       // If chargecurrent is zero, No current is available.
                        {
                            Error = NOCURRENT;
                            DEBUG_PRINT(("83 ACK "));                           // No current available
                        } else {
                            SetCurrent(Current);
                            CONTACTOR_ON;                                       // Contactor ON
                            DiodeCheck = 0;
                            State = STATE_C;                                    // switch to STATE_C
                            LCDTimer = 0;
                            Timer = 0;                                          // reset msTimer and ChargeTimer
                            if (!LCDNav)                                        // Don't update the LCD if we are navigating the menu
                            {
                                GLCD();                                         // immediately update LCD
                            }
                            DEBUG_PRINT(("83 ACK State C charge current: %uA\r\n", Current));
                            printf("STATE B->C\r\n");
                        }
                    } else if (Command == 0x84)                                 // Charging Stopped, State B
                    {
                        State = STATE_B;
                        DEBUG_PRINT(("84 ACK State C->B, charging stopped\r\n"));
                    }

                }
                
                                
                if (LoadBl == 1)                                                // We are the Master, commands received from the Slaves are handled here
                {
                    if (Command == 0x01)                                        // Slave state changed to State A
                    {
                        BalancedState[SlaveAdr] = 0;                            // Keep track of the state and store it.		
                        CalcBalancedCurrent(0);                                 // Calculate dynamic charge current for connected EVSE's
                        printf("01 Slave %u State A\r\n", SlaveAdr);
                        SendRS485(SlaveAdr, 0x81, 0x00, 0x00);                  // Send ACK to Slave, followed by two dummy bytes
                    } else if (Command == 0x02)                                 // Request to charge , next two bytes = requested charge current
                    {
                        if (IsCurrentAvailable() == 0)                          // check if we have enough current
                        {                                                       // Yes enough current..
                            BalancedState[SlaveAdr] = 1;                        // Mark Slave EVSE as active (State B)
                            BalancedMax[SlaveAdr] = Current;                    // Set requested charge current.
                            Balanced[SlaveAdr] = MinCurrent;                    // Initially set current to lowest setting
                        } else Balanced[SlaveAdr] = 0;                          // Make sure the Slave does not start charging by setting current to 0
                        printf("02 Slave %u requested:%uA\r\n", SlaveAdr, Current);
                        SendRS485(SlaveAdr, 0x82, 0x00, Balanced[SlaveAdr]);    // Send ACK to Slave, followed by assigned current
                    } else if (Command == 0x03)                                 // Charging, next two bytes = requested charge current
                    {
                        if (IsCurrentAvailable() == 0)                          // check if we have enough current
                        {                                                       // Yes
                            BalancedState[SlaveAdr] = 2;                        // Mark Slave EVSE as Charging (State C)
                            BalancedMax[SlaveAdr] = Current;                    // Set requested charge current.
                            Balanced[SlaveAdr] = 0;                             // For correct baseload calculation set current to zero
                            CalcBalancedCurrent(1);                             // Calculate charge current for all connected EVSE's
                        } else Balanced[SlaveAdr] = 0;                          // Make sure the Slave does not start charging by setting current to 0
                        printf("03 Slave %u charging: %uA\r\n", SlaveAdr, Balanced[SlaveAdr]);
                        SendRS485(SlaveAdr, 0x83, 0x00, Balanced[SlaveAdr]);    // Send ACK to Slave, followed by assigned current
                    } else if (Command == 0x04)                                 // charging stopped (state C->B), followed by two empty bytes
                    {
                        BalancedState[SlaveAdr] = 0;                            // Mark Slave EVSE as inactive (still State B)
                        CalcBalancedCurrent(0);                                 // Calculate dynamic charge current for connected EVSE's
                        printf("04 C->B Slave %u inactive\r\n", SlaveAdr);
                        SendRS485(SlaveAdr, 0x84, 0x00, 0x00);                  // Send ACK to Slave
                    }

                } // commands for Master

            }
            ISRFLAG = 0;                                                        // ready to receive new data
            if (Error == CT_NOCOMM && timeout == 10) Error = NO_ERROR;          // Clear communication error, if present
            if (Error == LESS_6A && ChargeDelay == 0 && LoadBl > 1)
                Error = NO_ERROR;                                               // Clear Error after delay (Slave)

        } // (ISRFLAG > 1)


    } // end of while(1) loop
}
