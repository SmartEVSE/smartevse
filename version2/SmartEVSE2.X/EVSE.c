/*
; Project:       Smart EVSE
; Date:          8 June 2020
;
; Changes:
;
; 2.00  New v2 hardware (18F26K22), Graphic 128x64 LCD , MPLAB X IDE, and the XC8 compiler
; 2.01  Fix: Charge current in normal mode was limited to MaxMains setting.
;       Fix: Load Balancing-Master can now adjust MaxMains and MinCharge settings from the LCD menu.
;       Fix: SmartMode can now charge at a higher current then set by MaxMains, using surplus power generated by Solar.
;            i.e. -15A PV power +45A MaxMains results in charging current of 60A.
;       Bugfixes to load balancing code (only affects v2)
; 2.02  Fix: Slave Max charge current was set to Cable limit instead of MaxCurrent
;       Fix: Charging sometimes stopped because State C control pilot ranges were too strict. 
; 2.03  Changed lowest MaxMains setting to 10A, lowest CT calibration value to 6A.
; 2.04  Fix: In Normal mode, the MAX charge current was limited by the MAINS setting (which is not shown in this mode).
;       Fix: default LoadBl EEPROM setting was not set correctly.
;       MAX charge current can be adjusted while charging in Normal mode.
;       ACCESS menu option added. Allows to Start/Stop charging by connecting a button/switch to IO2.
;       if the ACCESS option is set to disabled, the button can be used to stop charging.
;       On IO1 a LED can be connected, which acts as a charging/error indicator.
; 2.05  Fix: Using a 16A charge cable would limit MaxCurrent to 16A, until a reset of the module or adjusting the MAX value using the menu. 
;       Fix: Increased number of times a STATE change needs to be valid, before the actual STATE change takes place.
;            this to fix erratic behavior on a Renault Zoe.
;       LCD Backlight will now be activated on any key press, and will turn off after 60 seconds of inactivity (except when charging).  
;       CT's default values can be restored by holding both < and > keys while in the CAL menu.
;       RCMON menu option added. This adds support for DC Residual Current sensors, as required by IEC62955.
;            IO3 is used as the fault input (active high).
;            The error state can be reset by pressing any module button, or the pushbutton on IO2
; 2.06  Added check in EEprom write routine for disabled interrupts.
; 2.07  Fix: The RCD was tripped by inductive loads/ voltage spikes on the mains line. Checking twice for a tripped RCD fixed this.
;       Bootloader can now only be entered when also the right button on top of the module is pressed.
;       Added Compile time option to switch directly from STATE_A to STATE_C.
;
; 2.10  Modbus version. 
;       Please note that the old sensorbox will -not- work with this version.
;       Use Sensorbox 1.5 or Sensorbox 2, or use a Phoenix, Finder or Eastrom modbus kWh meter for measuring the current on your mains wiring.
;       Thanks to Robert Heel for his work on this code.
;       Added MODE Solar option. Maximize charging on Solar power.
;       Added START menu option. Start Charging when surplus solar power is above 4A (configurable 1-16 A). EV will always charge at minimal MIN Current per phase
;       Added STOP menu option. Stop Charging after XX minutes at MIN charge current (configurable 0-60 min) (0= keep charging)
;       EEprom initialization done at first power-up.
;       Bugfixes in Master/Slave code.
;       Automatic CT Calibration reset when upgrading from 2.0x to this version.
;       LCD Backlight will now be lit for 60 seconds, when pressing the external button.
;       CABLE option removed, just set MAX to the cable capacity.
;       CIRCUIT menu option added. Used when multiple EVSE's share the same circuit. Set this to the max current of the EVSE circuit. 
;       Switching between Solar/Smart mode with left button on the module.
; 2.11  Fixed rare corrupted flash issue, seems to happen sometimes at power on. 
;       The microcontroller would start at a random address, if this happened to be the flash erase code, the flash will become corrupted.
;       Now using two variables that hold the unlock sequence. So that power up glitches will not trigger a flash erase/write.
;       Bootloader also gets updated to fix this issue (now v1.06)
;       MAX setting now starts at 6A
; 2.12  Fixed garbled LCD. When charging is stopped the the LCD is re-initialized after a 200ms delay.
; 2.13  Various Master/Slave communication bug fixes.
; 2.14  Fixed Broadcast error clear message handling on slave.
;       Added check in Solar mode for overloading the MAINS.
;       Removed START and STOP menu options from the slave, as it is determined by the master.
; 2.15  Added check to see if Sensorbox data contains new measurement data.
;       Added IMPORT menu option, which allows for power import from the grid when solar charging.
;       Added compile time option to compensate for 230V-400V transformers.
;       Added Activation mode, which is triggered if state C is not entered within 30 seconds. 
;       If an external push button is used as Smart/Solar mode switch, holding this button for 1.5 seconds will now stop charging.
; 2.16  Fixed Smart/Solar mode switch, it would force Solar or Smart mode, even in Normal mode.
;       Added GRID menu option. Configures the Sensorbox2 for use with 4Wire (L1,L2,L3 and Neutral) or 3Wire (L1,L2,L3 no Neutral)
;       Speeded up State C->B detection, by removing (blocking) delays. The Renault ZOE will show an error if this takes > 100ms.
; 2.17  Fixed state switch bug while in solar mode.
;       Hides CAL menu option when CT's are not used.
;
;
;   Build with MPLAB X v5.25 and XC8 compiler version 2.10
;
;   If you get "(902) no chip name specified" error messages, make sure the xc8-cc compiler is used.
;
;   set in XC8 global options the C standard to "C90"
;   set XC8 linker memory model settings to: double 32 bit, float 32 bit
;   and reserve space for the bootloader by setting ROM range to 0-FCFB 
;
;
;   (C) 2013-2020  Michael Stegen / Stegen Electronics
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in
; all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
; THE SOFTWARE.
*/
#include <xc.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "EVSE.h"
#include "bootloader.h"
#include "utils.h"

void SetCurrent(unsigned int);
unsigned int CalcCurrent();


// Configuration settings
#pragma	config FCMEN = OFF,	IESO = OFF, PRICLKEN = ON
#pragma config PLLCFG = OFF, FOSC = HSMP                                        // High Speed Medium power (4-16Mhz), PLL Off
#pragma	config BORV = 285, BOREN = ON, PWRTEN = ON
#pragma	config WDTPS = 2048, WDTEN = OFF                                        // WDT timeout
#pragma config CCP2MX = PORTB3, PBADEN = OFF, CCP3MX = PORTC6                   // PortB digital IO
#pragma config HFOFST = OFF, T3CMX = PORTB5, P2BMX = PORTC0, MCLRE = INTMCLR

#pragma config XINST = OFF, DEBUG = OFF, LVP = OFF, STVREN = ON
#pragma	config CP0 = OFF, CP1 = OFF, CP2 = OFF, CP3 = OFF, CPD = OFF, CPB = OFF
#pragma	config WRT0 = OFF, WRT1 = OFF, WRT2 = OFF, WRT3 = OFF
#pragma	config WRTC = OFF, WRTB = OFF, WRTD = OFF
#pragma	config EBTR0 = OFF, EBTR1 = OFF, EBTR2 = OFF, EBTR3 = OFF
#pragma	config EBTRB = OFF


// Text
const far char StrFixed[]   = "Fixed";
const far char StrSocket[]  = "Socket";
const far char StrSmart[]   = "Smart";
const far char StrNormal[]  = "Normal";
const far char StrSolar[]   = "Solar";
const far char StrSolenoid[] = "Solenoid";
const far char StrMotor[]   = "Motor";
const far char StrDisabled[] = "Disabled";
const far char StrLoadBl[5][9]  = {"Disabled", "Master", "Slave 1", "Slave 2", "Slave 3"};
const far char StrSwitch[5][10] = {"Disabled", "Access B", "Access S", "Sma-Sol B", "Sma-Sol S"};
const far char StrGrid[2][10] = {"4Wire", "3Wire"};
const far char StrEnabled[] = "Enabled";
const far char StrExitMenu[] = "MENU";
const far char StrMainsAll[] = "All"; // Everything
const far char StrMainsHomeEVSE[] = "Home+EVSE";
const far char StrRFIDReader[5][10] = {"Disabled", "Enabled", "Learn", "Delete", "DeleteAll"};

// Global data
char U1buffer[50],U1packet[50];                                                 // Uart1 Receive buffer /RS485
char U1TXbuffer[50];                                                            // Uart1 Transmit buffer /RS485
char U2buffer[50];                                                              // Uart2 buffer /Serial CLI
char Tbuffer[50];                                                               // temp buffer
char GLCDbuf[512];                                                              // GLCD buffer (half of the display)
char RFIDlist[120];                                                             // holds up to 20 RFIDs


// The following data will be updated by eeprom data at powerup:
unsigned int MaxMains = MAX_MAINS;                                              // Max Mains Amps (hard limit, limited by the MAINS connection) (A)
unsigned int MaxCurrent = MAX_CURRENT;                                          // Max Charge current (A)
unsigned int MinCurrent = MIN_CURRENT;                                          // Minimal current the EV is happy with (A)
double ICal = ICAL;                                                             // CT calibration value
char Mode = MODE;                                                               // EVSE mode (0:Normal / 1:Smart)
char Lock = LOCK;                                                               // Cable lock (0:Disable / 1:Solenoid / 2:Motor)
unsigned int MaxCircuit = MAX_CIRCUIT;                                          // Max current of the EVSE circuit (A)
char Config = CONFIG;                                                           // Configuration (0:Socket / 1:Fixed Cable)
char LoadBl = LOADBL;                                                           // Load Balance Setting (0:Disable / 1:Master / 2-4:Slave)
char Switch = SWITCH;                                                           // External Switch on I/O 2 (0:Disable / 1:Access / 2:Smart-Solar)
char RCmon = RC_MON;                                                            // Residual Current Monitor on I/O 3 (0:Disable / 1:Enable)
unsigned int StartCurrent = START_CURRENT;
unsigned int StopTime = STOP_TIME;
unsigned int ImportCurrent = IMPORT_CURRENT;
unsigned char MainsMeter = MAINS_METER;                                         // Type of Mains electric meter (0: Disabled / Constants EM_*)
unsigned char MainsMeterAddress = MAINS_METER_ADDRESS;
unsigned char MainsMeterMeasure = MAINS_METER_MEASURE;                          // What does Mains electric meter measure (0: Mains (Home+EVSE+PV) / 1: Home+EVSE / 2: Home)
unsigned char PVMeter = PV_METER;                                               // Type of PV electric meter (0: Disabled / Constants EM_*)
unsigned char PVMeterAddress = PV_METER_ADDRESS;
char Grid = GRID;                                                               // Type of Grid connected to Sensorbox (0:4Wire / 1:3Wire )
unsigned char EVMeter = EV_METER;                                               // Type of EV electric meter (0: Disabled / Constants EM_*)
unsigned char EVMeterAddress = EV_METER_ADDRESS;
unsigned char RFIDReader = RFID_READER;                                         // RFID Reader Disabled/Enabled (Learn / Delete, Delete All)

signed double Irms[3]={0, 0, 0};                                                // Momentary current per Phase (Amps *10) (23 = 2.3A)
                                                                                // Max 3 phases supported
unsigned char State = STATE_A;
unsigned char Error = NO_ERROR;
unsigned char NextState;

unsigned int MaxCapacity;                                                       // Cable limit (A) (limited by the wire in the charge cable, set automatically, or manually if Config=Fixed Cable)
unsigned int ChargeCurrent;                                                     // Calculated Charge Current (Amps *10)
unsigned int OverrideCurrent = 0;                                               // Temporary assigned current (Amps *10) (modbus)
unsigned int Imeasured = 0;                                                     // Max of all Phases (Amps *10) of mains power
signed int ImeasuredNegative = 0;                                               // Max of all Phases (Amps *10) of generated surplus power (negative)
signed int Isum = 0;                                                            // Sum of all measured Phases (Amps *10) (can be negative)

// Load Balance variables
signed int IsetBalanced = 0;                                                    // Max calculated current (Amps *10) available for all EVSE's
unsigned int Balanced[NR_SLAVES] = {0, 0, 0, 0, 0, 0, 0, 0};                    // Amps value per EVSE
unsigned int BalancedMax[NR_SLAVES] = {0, 0, 0, 0, 0, 0, 0, 0};                 // Max Amps value per EVSE
char BalancedState[NR_SLAVES] = {0, 0, 0, 0, 0, 0, 0, 0};                       // State of all EVSE's 0=not active (state A), 1=charge request (State B), 2= Charging (State C) 
unsigned int BalancedError[NR_SLAVES] = {0, 0, 0, 0, 0, 0, 0, 0};               // Error state of EVSE

unsigned char RX1byte;
unsigned char idx = 0, idx2 = 0, ISRFLAG = 0, ISR2FLAG = 0, ISRTXFLAG = 0, ISRTXLEN = 0;
unsigned char menu = 0;
unsigned int locktimer = 0, unlocktimer = 0;                                    // solenoid timers
unsigned char lock1 = 0, lock2 = 0;
unsigned long Timer = 0;                                                        // mS counter
unsigned long ModbusTimer;
unsigned char BacklightTimer = 0;                                               // Backlight timer (sec)
unsigned int ChargeTimer = 0;                                                   // Counts seconds in STATE C (Charging) (unused)
unsigned char LCDTimer = 0;
signed char TempEVSE = 0;                                                       // Temperature EVSE in deg C (-50 to +125)
unsigned char ButtonState = 0x0f;                                               // Holds latest push Buttons state (LSB 3:0)
unsigned char OldButtonState = 0x0f;                                            // Holds previous push Buttons state (LSB 3:0)
unsigned char LCDNav = 0;
unsigned char SubMenu = 0;
unsigned long ScrollTimer = 0;
unsigned char LCDpos = 0;
unsigned char ChargeDelay = 0;                                                  // Delays charging at least 60 seconds in case of not enough current available.
unsigned char NoCurrent = 0;                                                    // counts overcurrent situations.
unsigned char TestState = 0;
unsigned char LedTimer = 0;                                                     // LED on I01 uses TMR2 and a PWM signal to fade in/out
unsigned char LedUpdate = 0;                                                    // Flag that LED PWM data has been updated
unsigned char LedCount = 0;                                                     // Raw Counter before being converted to PWM value
unsigned char LedPwm = 0;                                                       // PWM value 0-255
unsigned char ModbusRequest = 0;                                                // Flag to request Modbus information
unsigned char MenuItems[MENU_EXIT];
unsigned char unlockMagic = 0;
unsigned char unlock55 = 0;                                                     // unlock bytes set to 0 to prevent flash write at por   
unsigned char unlockAA = 0;                                                     // unlock bytes set to 0 to prevent flash write at por
unsigned char Access_bit = 0;
unsigned int serialnr = 0;
unsigned char GridActive = 0;                                                   // When the CT's are used on Sensorbox2, it enables the GRID menu option.
unsigned char CalActive = 0;                                                    // When the CT's are used on Sensorbox(1.5 or 2), it enables the CAL menu option.

unsigned int SolarStopTimer = 0;
unsigned char SolarTimerEnable = 0;
unsigned char DelayedRS485SendBuf = 0;
signed double EnergyCharged = 0;                                                // kWh value energy charged. (*10) (will reset if state changes from A->B)
signed double EnergyMeterStart = 0;                                             // kWh meter value is stored once EV is connected to EVSE (kWh)
unsigned int PowerMeasured = 0;                                                 // Measured Charge power in Watt by kWh meter
unsigned char RFID[8] = {0, 0, 0, 0, 0, 0, 0, 0};
unsigned char RFIDstatus = 0;


struct  {
    unsigned char Address;
    unsigned char Function;
    unsigned int Register;
    unsigned int RegisterCount;
    unsigned int Value;
    unsigned char *Data;
    unsigned char DataLength;
    unsigned char Type;
    unsigned char RequestAddress;
    unsigned char RequestFunction;
    unsigned int RequestRegister;
    unsigned char Requested;
    unsigned char Exception;
} Modbus;

void interrupt high_isr(void)
{
    // Determine what caused the interrupt
    while (PIR1bits.RC1IF)                                                      // Uart1 receive interrupt? RS485
    {
        RX1byte = RCREG1;                                                       // copy received byte

        if (ModbusTimer > 3)                                                    // last reception more then 3ms ago? 
        {
            idx = 0;                                                            // clear idx in RS485 RX handler
        }  
        if (idx == 50) idx--;                                                   // max 50 bytes in buffer
        U1buffer[idx++] = RX1byte;                                              // Store received byte in buffer

        ModbusTimer = 0;            
    }

    if (PIR1bits.TX1IF && PIE1bits.TX1IE)                                       // Uart1 transmit interrupt? RS485
    {
        TXREG1 = U1TXbuffer[ISRTXFLAG++];                                       // send character
        if ((ISRTXFLAG == ISRTXLEN)|| ISRTXFLAG == 50)                          // end of buffer
        {
            PIE1bits.TX1IE = 0;                                                 // clear transmit Interrupt for RS485 after sending last character
            ISRTXFLAG = 0;                                                      // end of transmission.
        }                                                                       // we switch off the transmitter in the main loop, after the final character has been sent..
        ModbusTimer = 0;                                                        // make sure there is a delay between modbus packets
    }

    // Uart2 receive interrupt?
    while (PIR3bits.RC2IF)                                                      
    {
        // Check for BREAK character, then Reset
        if (RCSTA2bits.FERR && RCONbits.POR && State == STATE_A ) {
                                                                                // Make sure any data during a POR is ignored.
            RX1byte = RCREG2;                                                   // copy received byte
            if (!RX1byte) Reset();                                              // Only reset if not charging...
        } else RX1byte = RCREG2;

        RCONbits.POR = 1;                                                       // flag that future resets are not POR resets
        
        TXREG2 = RX1byte;                                                       // echo to UART2 port, don't check for overflow here.
        if (idx2 == 50) idx2--;
        if ((RX1byte == 0x08) && (idx2 > 0)) {
            idx2--;                                                             // backspace
        } else {
            if (RX1byte == 0x0d || RX1byte == 0x0a)                             // CR or LF?
            {
                RX1byte = 0;
                ISR2FLAG = idx2 + 1u;                                           // ENTER, process data
            }
            U2buffer[idx2++] = RX1byte;                                         // store byte
        }
    }
    
    // Timer 4 interrupt, called 1000 times/sec
    while (PIR5bits.TMR4IF)                                                     
    {
        if (Lock)                                                               // Cable lock enabled?
        {
            if (Error || (State != STATE_C)) {
                if (unlocktimer < 600) {                                        // 600ms pulse
                    SOLENOID_UNLOCK;
                } else SOLENOID_OFF;
                if (unlocktimer++ > 700) {
                    if (PORTCbits.RC1 == lock1 )                                // still locked...
                    {
                        if (unlocktimer > 5000) unlocktimer = 0;                //try to unlock again in 5 seconds
                    } else unlocktimer = 700;
                }
                locktimer = 0;
            } else {                                                            // State C
                if (locktimer < 600) {                                          // 600ms pulse
                    SOLENOID_LOCK;
                } else SOLENOID_OFF;
                if (locktimer++ > 700) {
                    if (PORTCbits.RC1 == lock2 )                                // still unlocked...
                    {
                        if (locktimer > 5000) locktimer = 0;                    // try to lock again in 5 seconds
                    } else locktimer = 700;
                }
                unlocktimer = 0;
            }
        }

        Timer++;                                                                // mSec counter (overflows in 1193 hours)
        ModbusTimer++;
        
        if (LedTimer-- == 0) {
            CCPR2L = LedPwm;                                                    // MSB of DutyCycle, Lsb 0-1 are part of CCP2CON, but not used
                                                                                // LedPwm is calculated in the main loop
            LedTimer = 10;                                                      // Led is updated every 10ms (1ms*10)
            LedUpdate = 1;                                                      // Flag that LED PWM value has been updated
        }

        PIR5bits.TMR4IF = 0;                                                    // clear interrupt flag
    }

}


// Copy modbus frame to output buffer
// Start RS485 transmission, by enabling TX interrupt
void RS485SendBuf(char *buffer, unsigned char len) {
    unsigned char i,index = 0;

#ifdef LOG_DEBUG_MODBUS
    for (i=0;i<len;i++) printf("%02X ",buffer[i]);
    printf("\r\n");
#endif
    while (ISRTXFLAG) {}                                                        // wait if we are already transmitting on the RS485 bus (blocking, does not occur?)
    ISRTXLEN = len;                                                             // number of bytes to transfer

    while (len--) {
        U1TXbuffer[index++] = *buffer++;                                        // load next byte
    }
    
    if (ModbusTimer > 6) {                                                      // No RS485 reception at the moment
    
        LATBbits.LATB5 = 1;                                                     // set RS485 transceiver to transmit
        delay(1);
        PIE1bits.TX1IE = 1;                                                     // enable transmit Interrupt for RS485
    } else DelayedRS485SendBuf = 1;                                             // RS485 reception taking place, handle sending of frame in main loop
    
}

/**
 * Send data over modbus
 * 
 * @param unsigned char address
 * @param unsigned char function
 * @param unsigned char byte
 * @param unsigned int pointer to values
 * @param unsigned char count of values
 */
void ModbusSend(unsigned char address, unsigned char function, unsigned char byte, unsigned int *values, unsigned char count) {
    unsigned int cs, i, n = 0;

    // Device address
    Tbuffer[n++] = address;
    // Function
    Tbuffer[n++] = function;
    // The number of data bytes to follow
    if (byte) Tbuffer[n++] = byte;
    // Values
    for (i = 0; i < count; i++) {
        Tbuffer[n++] = ((unsigned char)(values[i]>>8));
        Tbuffer[n++] = ((unsigned char)(values[i]));
    }
    // Calculate CRC16 from data
    cs = crc16(Tbuffer, n);
    Tbuffer[n++] = ((unsigned char)(cs));
    Tbuffer[n++] = ((unsigned char)(cs>>8));

    // Send buffer to RS485 port
    RS485SendBuf(Tbuffer, n);
}

/**
 * Send single value over modbus
 * 
 * @param unsigned char address
 * @param unsigned char function
 * @param unsigned int register
 * @param unsigned int data
 */
void ModbusSend8(unsigned char address, unsigned char function, unsigned int reg, unsigned int data) {
    unsigned int values[2];
    
    values[0] = reg;
    values[1] = data;
    
    ModbusSend(address, function, 0, values, 2);
}

/**
 * Request read holding (FC=3) or read input register (FC=04) to a device over modbus
 * 
 * @param unsigned char address
 * @param unsigned char function
 * @param unsigned int register
 * @param unsigned int quantity
 */
void ModbusReadInputRequest(unsigned char address, unsigned char function, unsigned int reg, unsigned int quantity) {
    Modbus.RequestAddress = address;
    Modbus.RequestFunction = function;
    Modbus.RequestRegister = reg;
    ModbusSend8(address, function, reg, quantity);
}

/**
 * Response read holding (FC=3) or read input register (FC=04) to a device over modbus
 * 
 * @param unsigned char address
 * @param unsigned char function
 * @param unsigned int pointer to values
 * @param unsigned char count of values
 */
void ModbusReadInputResponse(unsigned char address, unsigned char function, unsigned int *values, unsigned char count) {
    ModbusSend(address, function, count * 2u, values, count);
}

/**
 * Request write single register (FC=06) to a device over modbus
 * 
 * @param unsigned char address
 * @param unsigned int register
 * @param unsigned int value
 */
void ModbusWriteSingleRequest(unsigned char address, unsigned int reg, unsigned int value) {
    Modbus.RequestAddress = address;
    Modbus.RequestFunction = 0x06;
    Modbus.RequestRegister = reg;
    ModbusSend8(address, 0x06, reg, value);  
}

/**
 * Response write single register (FC=06) to a device over modbus
 * 
 * @param unsigned char address
 * @param unsigned int register
 * @param unsigned int value
 */
void ModbusWriteSingleResponse(unsigned char address, unsigned int reg, unsigned int value) {
    ModbusSend8(address, 0x06, reg, value);  
}


/**
 * Request write multiple register (FC=16) to a device over modbus
 * 
 * @param unsigned char address
 * @param unsigned int register
 * @param unsigned char pointer to data
 * @param unsigned char count of data
 */
void ModbusWriteMultipleRequest(unsigned char address, unsigned int reg, unsigned int *values, unsigned char count) {
    unsigned int i, n = 0, cs;

    Modbus.RequestAddress = address;
    Modbus.RequestFunction = 0x10;
    Modbus.RequestRegister = reg;

    // Device Address
    Tbuffer[n++] = address;
    // Function Code 16
    Tbuffer[n++] = 0x10;
    // Data Address of the first register
    Tbuffer[n++] = ((unsigned char)(reg>>8));
    Tbuffer[n++] = ((unsigned char)(reg));
    // Number of registers to write
    Tbuffer[n++] = 0x00;
    Tbuffer[n++] = count;
    // Number of data bytes to follow (2 registers x 2 bytes each = 4 bytes)
    Tbuffer[n++] = count * 2u;
    // Values
    for (i = 0; i < count; i++) {
        Tbuffer[n++] = ((unsigned char)(values[i]>>8));
        Tbuffer[n++] = ((unsigned char)(values[i]));
    }
    // Calculate CRC16 from data
    cs = crc16(Tbuffer, n);
    Tbuffer[n++] = ((unsigned char)(cs));
    Tbuffer[n++] = ((unsigned char)(cs>>8));	
    // Send buffer to RS485 port
    RS485SendBuf(Tbuffer, n);    
}

/**
 * Response write multiple register (FC=16) to a device over modbus
 * 
 * @param unsigned char address
 * @param unsigned int register
 * @param unsigned int count
 */
void ModbusWriteMultipleResponse(unsigned char address, unsigned int reg, unsigned int count) {
    ModbusSend8(address, 0x10, reg, count);
}

/**
 * Response an exception
 * 
 * @param unsigned char address
 * @param unsigned char function
 * @param unsigned char exeption
 */
void ModbusException(unsigned char address, unsigned char function, unsigned char exception) {
    unsigned int temp[1];
    ModbusSend(address, function, exception, temp, 0);
}

/**
 * Decode received modbus packet
 * 
 * @param unsigned char pointer to buffer
 * @param unsigned char length of buffer
 */
void ModbusDecode(unsigned char *buf, unsigned char len) {
    // Clear old values
    Modbus.Address = 0;
    Modbus.Function = 0;
    Modbus.Register = 0;
    Modbus.RegisterCount = 0;
    Modbus.Value = 0;
    Modbus.DataLength = 0;
    Modbus.Type = MODBUS_INVALID;
    Modbus.Exception = 0;

    // Modbus error packets length is 5 bytes
    if (len == 5) {
        // calculate checksum over all data (including crc16)
        // when checksum == 0 data is ok.
        if (!crc16(buf, len)) {
            // CRC OK
            Modbus.Type = MODBUS_EXCEPTION;
            // Modbus device address
            Modbus.Address = buf[0];
            // Modbus function
            Modbus.Function = buf[1];
            // Modbus Exception code
            Modbus.Exception = buf[2];
        }
    // Modbus data packets minimum length is 8 bytes
    } else if (len >= 8) {
        // Modbus device address
        Modbus.Address = buf[0];
        // Modbus function
        Modbus.Function = buf[1];
        // calculate checksum over all data (including crc16)
        // when checksum == 0 data is ok.
        if (!crc16(buf, len)) {
            // CRC OK
#ifdef LOG_DEBUG_MODBUS
            printf("\n  valid Modbus packet: Address %02x Function %02x", Modbus.Address, Modbus.Function);
#endif
            switch (Modbus.Function) {
                case 0x03: // (Read holding register)
                case 0x04: // (Read input register)
                    if (len == 8) {
                        // request packet
                        Modbus.Type = MODBUS_REQUEST;
                        // Modbus register
                        Modbus.Register = (buf[2] <<8) | buf[3];
                        // Modbus register count
                        Modbus.RegisterCount = (buf[4] <<8) | buf[5];
                    } else {
                        // Modbus datacount
                        Modbus.DataLength = buf[2];
                        if (Modbus.DataLength == len - 5) {
                            // packet length OK
                            // response packet
                            Modbus.Type = MODBUS_RESPONSE;
#ifdef LOG_WARN_MODBUS
                        } else {
                            printf("\nInvalid modbus packet");
#endif
                        }
                    }
                    break;
                case 0x06:
                    // (Write single register)
                    if (len == 8) {
                        // request and response packet are the same
                        Modbus.Type = MODBUS_OK;
                        // Modbus register
                        Modbus.Register = (buf[2] <<8) | buf[3];
                        // Modbus register count
                        Modbus.RegisterCount = 1;
                        // value
                        Modbus.Value = (buf[4] <<8) | buf[5];
#ifdef LOG_WARN_MODBUS
                    } else {
                        printf("\nInvalid modbus packet");
#endif
                    }
                    break;
                case 0x10:
                    // (Write multiple register))
                    // Modbus register
                    Modbus.Register = (buf[2] <<8) | buf[3];
                    // Modbus register count
                    Modbus.RegisterCount = (buf[4] <<8) | buf[5];
                    if (len == 8) {
                        // response packet
                        Modbus.Type = MODBUS_RESPONSE;
                    } else {
                        // Modbus datacount
                        Modbus.DataLength = buf[6];
                        if (Modbus.DataLength == len - 9) {
                            // packet length OK
                            // request packet
                            Modbus.Type = MODBUS_REQUEST;
#ifdef LOG_WARN_MODBUS
                        } else {
                            printf("\nInvalid modbus packet");
#endif
                        }
                    }
                    break;
                default:
                    break;
            }

            // Modbus.Data
            if (Modbus.Type && Modbus.DataLength) {
                // Set pointer to Data
                Modbus.Data = buf;
                // Modbus data is always at the end ahead the checksum
                Modbus.Data = Modbus.Data + (len - Modbus.DataLength - 2);
            }
            
            // Request - Response check
            switch (Modbus.Type) {
                case MODBUS_REQUEST:
                    Modbus.Requested = 0;
                    Modbus.RequestAddress = Modbus.Address;
                    Modbus.RequestFunction = Modbus.Function;
                    Modbus.RequestRegister = Modbus.Register;
                    break;
                case MODBUS_RESPONSE:
                    // If address and function identical with last send or received request, it is a valid response
                    if (Modbus.Address == Modbus.RequestAddress && Modbus.Function == Modbus.RequestFunction) {
                        Modbus.Requested = 1;
                        if (Modbus.Function == 0x03 || Modbus.Function == 0x04) 
                            Modbus.Register = Modbus.RequestRegister;
                    } else {
                        Modbus.Requested = 0;
                    }
                    Modbus.RequestAddress = 0;
                    Modbus.RequestFunction = 0;
                    Modbus.RequestRegister = 0;
                    break;
                case MODBUS_OK:
                    // If address and function identical with last send or received request, it is a valid response
                    if (Modbus.Address == Modbus.RequestAddress && Modbus.Function == Modbus.RequestFunction) {
                        Modbus.Requested = 1;
                        Modbus.Type = MODBUS_RESPONSE;
                        Modbus.RequestAddress = 0;
                        Modbus.RequestFunction = 0;
                        Modbus.RequestRegister = 0;
                    } else {
                        Modbus.Requested = 0;
                        Modbus.Type = MODBUS_REQUEST;
                        Modbus.RequestAddress = Modbus.Address;
                        Modbus.RequestFunction = Modbus.Function;
                        Modbus.RequestRegister = Modbus.Register;
                    }
                default:
                    break;
            }
        }
    }
}

void eeprom_read_object(void *obj_p, size_t obj_size) {
    unsigned char *p = obj_p;

    EECON1 = 0;                                                                 // select EEprom
                                                                                // EEADR needs to be initialized
    while (obj_size--) {
        EECON1bits.RD = 1;
        *p++ = EEDATA;
        EEADR++;
    }
}

void eeprom_write_object(void *obj_p, size_t obj_size) {
    unsigned char *p = obj_p;

    while (obj_size--) {
        EECON1 = 0;                                                             //ensure CFGS=0 and EEPGD=0
        EECON1bits.WREN = 1;                                                    //enable write to EEPROM

        EEDATA = *p++;                                                          // set data
        if (!INTCONbits.GIE)                                                    // Interrupts should have been disabled!
        {
            EECON2 = unlock55;                                                  // required sequence #1
            EECON2 = unlockAA;                                                  // #2
            EECON1bits.WR = 1;                                                  // #3 = actual write
            while (EECON1bits.WR);                                              // blocking
        }    
        EECON1bits.WREN = 0;                                                    // disable write to EEPROM
        EEADR++;
    }
}

/**
 * Validate setting ranges and dependencies
 */
void validate_settings(void) {
    unsigned char i;
    unsigned int value;

    for (i = MENU_ENTER + 1;i < MENU_EXIT; i++){
        value = getItemValue(i);
        //printf("value %s set to %i\n",MenuStr[i].Key, value );
        if (value > MenuStr[i].Max || value < MenuStr[i].Min) {
            value = MenuStr[i].Default;
          //  printf("set default value for %s to %i\n",MenuStr[i].Key, value );
            setItemValue(i, value);
        }
    }

    // Enable access if no access switch used
    if (Switch != 1 && Switch != 2) Access_bit = 1;
    // Sensorbox v2 has always address 0x0A
    if (MainsMeter == EM_SENSORBOX) MainsMeterAddress = 0x0A;
    // Disable modbus reception on normal mode
    if (Mode == MODE_NORMAL) { MainsMeter = 0; PVMeter = 0; }
    // Disable PV reception if not configured
    if (MainsMeterMeasure == 0) PVMeter = 0;
    // set Lock variables for Solenoid or Motor
    if (Lock == 1) { lock1=0; lock2=1; }
    else if (Lock == 2) { lock1=1; lock2=0; }
    // Erase all RFID cards from ram + eeprom if set to EraseAll
    if (RFIDReader == 4) {                                                      // Erase ALL Cards
        for (i = 0; i < 120; i++) RFIDlist[i] = 0xff;
        WriteRFIDlist();
#ifdef LOG_INFO_EVSE
        printf("All RFID cards erased!\n");
#endif
        RFIDReader = 0;                                                         // RFID Reader Disabled
    }
}

// Read a list of 20 RFID's from eeprom
//
void ReadRFIDlist(void) {
    EEADR = 0;                                                                  // start from adr 256 in eeprom
    EEADRH = 1;

    eeprom_read_object(&RFIDlist, 120);
}

// Write a list of 20 RFID's to the eeprom
//
void WriteRFIDlist(void) {
    char savint;

    unlock55 = unlockMagic + 0x33;
    unlockAA = unlockMagic + 0x88;                                              // set unlock variables to magic values

    savint = INTCON;                                                            // Save interrupts state
    INTCONbits.GIE = 0;                                                         // Disable interrupts

    EEADR = 0;                                                                  // start from adr 256 in eeprom
    EEADRH = 1;

    eeprom_write_object(&RFIDlist, 120);                                        // write 120 bytes to eeprom

    unlock55 = 0;                                                               // clear unlock values
    unlockAA = 0;

    INTCON = savint;                                                            // Restore interrupts
#ifdef LOG_DEBUG_EVSE
    printf("\r\nrfid list saved\r\n");
#endif
}

// scan for matching RFID in RFIDlist
// returns offset+6 when found, 0 when not found
unsigned char MatchRFID(void) {
    unsigned char offset = 0, r;

    do {
        r = memcmp(RFID + 1, RFIDlist + offset, 6 );                            // compare read RFID with list of stored RFID's
        offset += 6;
    } while (r !=0 && offset < 114);

    if (r == 0) return offset;                                                  // return offset + 6 in RFIDlist
    else return 0;
}


// Store RFID card in memory and eeprom
// returns 1 when successful
// returns 2 when already stored
// returns 0 when all slots are full.
unsigned char StoreRFID(void) {
    unsigned char offset = 0, r;
    unsigned char empty[6] = {0xff,0xff,0xff,0xff,0xff,0xff};

    // first check if the Card ID was already stored.
    if ( MatchRFID() ) return 2;                                                // already stored, that's ok.

    do {
        r = memcmp(empty, RFIDlist + offset, 6 );
        offset += 6;
    } while (r !=0 && offset < 120);
    if (r != 0) return 0;                                                       // no more room to store RFID
    offset -= 6;
//    printf("offset %u ",offset);
    memcpy(RFIDlist + offset, RFID+1, 6);

#ifdef LOG_DEBUG_EVSE
    for (r=0; r<120; r++) printf("%02x",RFIDlist[r]);
#endif

    WriteRFIDlist();
    return 1;
}

// Delete RFID card in memory and eeprom
// returns 1 when successful, 0 when RFID was not found
unsigned char DeleteRFID(void) {
    unsigned char offset = 0, r;
    unsigned char empty[6] = {0xff,0xff,0xff,0xff,0xff,0xff};

    offset = MatchRFID();                                                       // find RFID in list
    if (offset) {
        offset -= 6;
        memcpy(RFIDlist + offset, empty, 6);
    } else return 0;

//    printf("deleted %u ",offset);
//    for (r=0; r<120; r++) printf("%02x",RFIDlist[r]);

    return 1;
}

void read_settings(void) {
        
    EEADR = 0;                                                                  // start from adr 0 in eeprom
    EEADRH = 0;                                                                 // we only use the first 256 bytes for now.
    
    eeprom_read_object(&MaxMains, sizeof MaxMains);
    if (MaxMains > 200) {                                                       // check if the eeprom is uninitialized
        MaxMains = MAX_MAINS;                                                   // set MaxMains back to default value    
        write_settings();                                                       // uninitialized, write default settings to eeprom   
        return;
    } 
            
    eeprom_read_object(&MaxCurrent, sizeof MaxCurrent);
    eeprom_read_object(&MinCurrent, sizeof MinCurrent);
    eeprom_read_object(&ICal, sizeof ICal);
    eeprom_read_object(&Mode, sizeof Mode);
    eeprom_read_object(&Lock, sizeof Lock);
    eeprom_read_object(&MaxCircuit, sizeof MaxCircuit);
    eeprom_read_object(&Config, sizeof Config);
    eeprom_read_object(&LoadBl, sizeof LoadBl);
    eeprom_read_object(&Switch, sizeof Switch);
    eeprom_read_object(&RCmon, sizeof RCmon);
    eeprom_read_object(&StartCurrent, sizeof StartCurrent);
    eeprom_read_object(&StopTime, sizeof StopTime);
    eeprom_read_object(&MainsMeter, sizeof MainsMeter);
    eeprom_read_object(&MainsMeterAddress, sizeof MainsMeterAddress);
    eeprom_read_object(&MainsMeterMeasure, sizeof MainsMeterMeasure);
    eeprom_read_object(&PVMeter, sizeof PVMeter);
    eeprom_read_object(&PVMeterAddress, sizeof PVMeterAddress);
    eeprom_read_object(&EMConfig[EM_CUSTOM].Endianness, sizeof EMConfig[EM_CUSTOM].Endianness);
    eeprom_read_object(&EMConfig[EM_CUSTOM].IRegister, sizeof EMConfig[EM_CUSTOM].IRegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].IDivisor, sizeof EMConfig[EM_CUSTOM].IDivisor);
    eeprom_read_object(&ImportCurrent, sizeof ImportCurrent);
    eeprom_read_object(&Grid, sizeof Grid);
    eeprom_read_object(&EVMeter, sizeof EVMeter);
    eeprom_read_object(&EVMeterAddress, sizeof EVMeterAddress);
    eeprom_read_object(&RFIDReader, sizeof RFIDReader);
    eeprom_read_object(&EMConfig[EM_CUSTOM].URegister, sizeof EMConfig[EM_CUSTOM].URegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].UDivisor, sizeof EMConfig[EM_CUSTOM].UDivisor);
    eeprom_read_object(&EMConfig[EM_CUSTOM].PRegister, sizeof EMConfig[EM_CUSTOM].PRegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].PDivisor, sizeof EMConfig[EM_CUSTOM].PDivisor);
    eeprom_read_object(&EMConfig[EM_CUSTOM].ERegister, sizeof EMConfig[EM_CUSTOM].ERegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].EDivisor, sizeof EMConfig[EM_CUSTOM].EDivisor);

    validate_settings();

}

void write_settings(void) {
    char savint;

    unlock55 = unlockMagic + 0x33;
    unlockAA = unlockMagic + 0x88;                                              // set unlock variables to magic values
    
    validate_settings();

    savint = INTCON;                                                            // Save interrupts state
    INTCONbits.GIE = 0;                                                         // Disable interrupts
    
    EEADR = 0;                                                                  // start from adr 0 in eeprom
    EEADRH = 0;                                                                 // we only use the first 256 bytes for now.
        
    eeprom_write_object(&MaxMains, sizeof MaxMains);
    eeprom_write_object(&MaxCurrent, sizeof MaxCurrent);
    eeprom_write_object(&MinCurrent, sizeof MinCurrent);
    eeprom_write_object(&ICal, sizeof ICal);
    eeprom_write_object(&Mode, sizeof Mode);
    eeprom_write_object(&Lock, sizeof Lock);
    eeprom_write_object(&MaxCircuit, sizeof MaxCircuit);
    eeprom_write_object(&Config, sizeof Config);
    eeprom_write_object(&LoadBl, sizeof LoadBl);
    eeprom_write_object(&Switch, sizeof Switch);
    eeprom_write_object(&RCmon, sizeof RCmon);
    eeprom_write_object(&StartCurrent, sizeof StartCurrent);
    eeprom_write_object(&StopTime, sizeof StopTime);
    eeprom_write_object(&MainsMeter, sizeof MainsMeter);
    eeprom_write_object(&MainsMeterAddress, sizeof MainsMeterAddress);
    eeprom_write_object(&MainsMeterMeasure, sizeof MainsMeterMeasure);
    eeprom_write_object(&PVMeter, sizeof PVMeter);
    eeprom_write_object(&PVMeterAddress, sizeof PVMeterAddress);
    eeprom_write_object(&EMConfig[EM_CUSTOM].Endianness, sizeof EMConfig[EM_CUSTOM].Endianness);
    eeprom_write_object(&EMConfig[EM_CUSTOM].IRegister, sizeof EMConfig[EM_CUSTOM].IRegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].IDivisor, sizeof EMConfig[EM_CUSTOM].IDivisor);
    eeprom_write_object(&ImportCurrent, sizeof ImportCurrent);
    eeprom_write_object(&Grid, sizeof Grid);
    eeprom_write_object(&EVMeter, sizeof EVMeter);
    eeprom_write_object(&EVMeterAddress, sizeof EVMeterAddress);
    eeprom_write_object(&RFIDReader, sizeof RFIDReader);
    eeprom_write_object(&EMConfig[EM_CUSTOM].URegister, sizeof EMConfig[EM_CUSTOM].URegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].UDivisor, sizeof EMConfig[EM_CUSTOM].UDivisor);
    eeprom_write_object(&EMConfig[EM_CUSTOM].PRegister, sizeof EMConfig[EM_CUSTOM].PRegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].PDivisor, sizeof EMConfig[EM_CUSTOM].PDivisor);
    eeprom_write_object(&EMConfig[EM_CUSTOM].ERegister, sizeof EMConfig[EM_CUSTOM].ERegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].EDivisor, sizeof EMConfig[EM_CUSTOM].EDivisor);

    unlock55 = 0;                                                               // clear unlock values
    unlockAA = 0;
    
    INTCON = savint;                                                            // Restore interrupts
#ifdef LOG_INFO_EVSE
    printf("\r\nsettings saved\r\n");
#endif

   /* if (LoadBl == 1) {                                                          // Master mode
        unsigned int i, values[12];
        for (i = 0; i < 12; i++) {
            values[i] = getItemValue(MENU_MAX + i);
        }
        ModbusWriteMultipleRequest(0x00, 0xE0, values, 12);                     // Broadcast settings to other controllers (NEEDS FIX!)
    }
    */
}

void putch(unsigned char byte)                                                  // user defined printf support on uart2
{
    // output one byte on UART2
    while (!PIR3bits.TX2IF);                                                    // set when register is empty (blocking)
    TXREG2 = byte;

}

unsigned char ReadPilot(void)                                                   // Read Pilot Signal 
{
    ADCON0bits.GO = 1;                                                          // start ADC conversion on the selected channel
    while (ADCON0bits.GO);                                                      // wait for conversion to finish (blocking)
    if (ADRES > 980) return PILOT_12V;                                          // Pilot at 12V (min 11.0V)
    if ((ADRES > 860) && (ADRES < 915)) return PILOT_9V;                        // Pilot at 9V
    if ((ADRES > 720) && (ADRES < 800)) return PILOT_6V;                        // Pilot at 6V
    if ((ADRES > 25) && (ADRES < 95)) return PILOT_DIODE;                       // Diode Check OK
    return PILOT_NOK;                                                           // Pilot NOT ok
}

void ProximityPin(void) {
    ADCON0 = 0b00000101;                                                        // ADC input AN1 (Proximity Pin)
    delay(100);                                                                 // delay 100ms (blocking)
    ADCON0bits.GO = 1;                                                          // initiate ADC conversion on the selected channel
    while (ADCON0bits.GO);                                                      // wait for conversion to finish (blocking)

    MaxCapacity = 13;                                                           // No resistor, Max cable current = 13A
    if ((ADRES > 394) && (ADRES < 434)) MaxCapacity = 16;                       // Max cable current = 16A	680R
    if ((ADRES > 175) && (ADRES < 193)) MaxCapacity = 32;                       // Max cable current = 32A	220R
    if ((ADRES > 88) && (ADRES < 98)) MaxCapacity = 63;                         // Max cable current = 63A	100R

    if (Config) MaxCapacity = MaxCurrent;                                       // Override with MaxCurrent when Fixed Cable is used.  

    ADCON0 = 0b00000001;                                                        // ADC input AN0 (Pilot)
}

void Temp(void)                                                                 // Measure Temperature EVSE (0-125 C)
{
    unsigned int temp;

    ADCON0 = 0b00001001;                                                        // ADC input AN2 (Temperature Sensor)
    ADCON1 = 0b00001000;                                                        // Use VREF 2.048V
    ADCON2 = 0b10111101;                                                        // Right justify, Tacq = 20 uS, FOSC/16
    ADCON0bits.GO = 1;                                                          // initiate ADC conversion on the selected channel
    while (ADCON0bits.GO);                                                      // wait for conversion to finish (blocking)

    temp = ADRES / 5;                                                           // ADRES= 2mv / ADC step
                                                                                // temp = gr/C (including offset of 50)
    ADCON0 = 0b00000001;                                                        // ADC input AN0 (Pilot)
    ADCON1 = 0b00000000;                                                        // Use standard Voltage ref = VCC
    ADCON2 = 0b10100101;                                                        // Right justify, Tacq = 8 uS, FOSC/16

    TempEVSE = temp - 50;                                                       // set Temp (-50 to +125 deg C), and remove offset
}


void BlinkLed(void) {
    if (Error || ChargeDelay) {
        if (LedUpdate) {
            if (Error & (RCD_TRIPPED | CT_NOCOMM) ) {
                LedCount += 20;                                                 // Very rapid flashing, RCD tripped or no Serial Communication.
                if (LedCount > 128) LedPwm = 255;                               // LED 50% of time on, full brightness    
                else LedPwm = 0;
            } else {                                                            // Waiting for Solar power or enough current to start charging
                LedCount += 2;                                                  // Slow blinking.
                if (LedCount > 230) LedPwm = 255;                               // LED 10% of time on, full brightness
                else LedPwm = 0;
            } 
  
            LedUpdate = 0;                  
          }
    } else if (Access_bit == 0) LedPwm = 0;                                     // No Access, LED off
    else if (State == STATE_A) LedPwm = 40;                                     // STATE A, LED on (dimmed)
    else if (State == STATE_B) {
        LedPwm = 255;                                                           // STATE B, LED on (full brightness)
        LedCount = 128;                                                         // When switching to STATE C, start at full brightness
    } else if (State == STATE_C && LedUpdate)                                   // STATE C, LED fades in/out
    {
        if (Mode == MODE_SOLAR) LedCount ++;                                    // Slow fading (Solar mode)
        else LedCount += 2;                                                     // Faster fading (Smart mode)
        LedPwm = ease8InOutQuad(triwave8(LedCount));                            // pre calculate new LedPwm value
        LedUpdate = 0;
    }
}

void SetCurrent(unsigned int current)                                           // current in Amps*10 (160 = 16A)
{
    unsigned int DutyCycle;

    if ((current >= 60) && (current <= 510)) DutyCycle = (unsigned int) (current / 0.6);
                                                                                // calculate DutyCycle from current
    else if ((current > 510) && (current <= 800)) DutyCycle = (unsigned int) (current / 2.5) + 640;
    else DutyCycle = 100;                                                       // invalid, use 6A
    CCPR1L = DutyCycle >> 2;                                                    // Msb of DutyCycle
                                                                                // 2 Lsb are part of CCP1CON, use Timer 2	
    CCP1CON = (((DutyCycle & 0x03) << 4) | 0x0C);                               // PWM Pilot signal enabled
}

// Is there at least 6A(configurable MinCurrent) available for a EVSE?
// returns 1 if there is 6A available
// returns 0 if there is no current available
//
char IsCurrentAvailable(void) {
    unsigned char n, ActiveEVSE = 0;
    int Baseload, TotalCurrent = 0;

        
    for (n = 0; n < 4; n++) if (BalancedState[n] == STATE_C)                    // must be in STATE_C
    {
        ActiveEVSE++;                                                           // Count nr of active (charging) EVSE's
        TotalCurrent += Balanced[n];                                            // Calculate total max charge current for all active EVSE's
    }
    if (ActiveEVSE == 0) {                                                      // No active (charging) EVSE's
        if (Imeasured > ((MaxMains - MinCurrent) * 10)) {                       // There should be at least 6A available
            return 0;                                                           // Not enough current available!, return with error
        }
    } else {                                                                    // at least one active EVSE
        ActiveEVSE++;                                                           // Do calculations with one more EVSE
        Baseload = Imeasured - TotalCurrent;                                    // Calculate Baseload (load without any active EVSE)
        if (Baseload < 0) Baseload = 0;                                         // only relevant for Smart/Solar mode

        if (ActiveEVSE > 4) ActiveEVSE = 4;
        // When load balancing is active, and we are the Master, the Circuit option limits the max total current
        if (LoadBl == 1) {
            if ((ActiveEVSE * (MinCurrent * 10)) > (MaxCircuit * 10)) {
                return 0;                                                       // Not enough current available!, return with error
            }    
        }
       
        // Check if the lowest charge current(6A) x ActiveEV's + baseload would be higher then the MaxMains.
        if ((ActiveEVSE * (MinCurrent * 10) + Baseload) > (MaxMains * 10)) {
            return 0;                                                           // Not enough current available!, return with error
        }    
        
    }

    // Allow solar Charging if surplus current is above 'StartCurrent' (on one of the phases)
    // Charging will start after the timeout (chargedelay) period has ended
    // now set to -4A (configurable)
    if (Mode == MODE_SOLAR) {                                                   // no active EVSE yet?
        if (ActiveEVSE == 0 && ImeasuredNegative >= ((signed int)StartCurrent *-10)) return 0;
        else if ((ActiveEVSE * MinCurrent * 10) > TotalCurrent) return 0;       // check if we can split the available current between all active EVSE's
    }
        
    return 1;
}

void ResetBalancedStates(void) {
    unsigned char n;

    for (n = 1; n < 4; n++) {
        BalancedState[n] = STATE_A;                                             // Yes, disable old active Slave states
        Balanced[n] = 0;                                                        // reset ChargeCurrent to 0
    }
}

// Calculates Balanced PWM current for each EVSE
// mod =0 normal
// mod =1 we have a new EVSE requesting to start charging.
//
void CalcBalancedCurrent(char mod) {
    int Average, MaxBalanced, Idifference;
    int BalancedLeft = 0;
    signed int IsumImport;
    int ActiveMax = 0, TotalCurrent = 0, Baseload;
    char CurrentSet[4] = {0, 0, 0, 0};
    char n;

    if (!LoadBl) ResetBalancedStates();                                         // Load balancing disabled?, Reset States
                                                                                // Do not modify MaxCurrent as it is a config setting. (fix 2.05)
    if (BalancedState[0] == STATE_C && MaxCurrent > MaxCapacity && !Config) ChargeCurrent = MaxCapacity * 10;
    else ChargeCurrent = MaxCurrent * 10;                                       // Instead use new variable ChargeCurrent.
    
    // Override current temporary if set (from Modbus)
    if (OverrideCurrent) ChargeCurrent = OverrideCurrent;

    if (LoadBl < 2) BalancedMax[0] = ChargeCurrent;                             // Load Balancing Disabled or Master: 
                                                                                // update BalancedMax[0] if the MAX current was adjusted using buttons or CLI

    for (n = 0; n < 4; n++) if (BalancedState[n] == STATE_C) {
            BalancedLeft++;                                                     // Count nr of Active (Charging) EVSE's
            ActiveMax += BalancedMax[n];                                        // Calculate total Max Amps for all active EVSEs
            TotalCurrent += Balanced[n];                                        // Calculate total of all set charge currents
        }

    if (!mod && Mode != MODE_SOLAR) {                                           // Normal and Smart mode
        Idifference = (MaxMains * 10) - Imeasured;                              // Difference between MaxMains and Measured current (can be negative)

        if (Idifference > 0) IsetBalanced += (Idifference / 4);                 // increase with 1/4th of difference (slowly increase current)
        else IsetBalanced += (double)(Idifference / TRANSFORMER_COMP);          // last PWM setting + difference (immediately decrease current)
        if (IsetBalanced < 0) IsetBalanced = 0;
        if (IsetBalanced > 800) IsetBalanced = 800;                             // hard limit 80A (added 11-11-2017)
    }

    
    
    if (Mode == MODE_SOLAR)                                                     // Solar version
    {
        #ifdef SPECIAL                                                          // Import option not visible , make sure it's set to 0
        ImportCurrent = 0;                                                      
        #endif
        IsumImport = Isum - (10 * ImportCurrent);                               // Allow Import of power from the grid when solar charging
        
        if (IsumImport < 0)                                                     // If it's negative, we have surplus (solar) power available
        {
            if (IsumImport < -10) IsetBalanced = IsetBalanced - (IsumImport / 3); //IsetBalanced + 5; // still more then 1A available, increase Balanced charge current with 0.5A
            else IsetBalanced = IsetBalanced - (IsumImport / 4);                // less then 1A difference, increase with 1/4th of difference.
        } else IsetBalanced = IsetBalanced - (IsumImport / 2);                  // Positive, decrease Balanced charge current.
                                                                                // If IsetBalanced is below MinCurrent or negative, make sure it's set to MinCurrent.
        if ( (IsetBalanced < (BalancedLeft * MinCurrent * 10)) || (IsetBalanced < 0) ) {
            IsetBalanced = BalancedLeft * MinCurrent * 10; 
                                                                                // ----------- Check to see if we have to continue charging on solar power alone ----------
            if (BalancedLeft && StopTime && (IsumImport > 10)) SolarTimerEnable=1;    // If any EVSE is Charging and StopTime is set to 1+ minute and we use 1+ A grid power, enable the SolarStopTimer
            else SolarTimerEnable=0;                                            // After the timer runs out, the charging will be stopped.
        } else SolarTimerEnable=0;                                              
  
    }
                                                                                // When Load balancing = Master,  Limit total current of all EVSEs to MaxCircuit
    if (LoadBl == 1 && (IsetBalanced > (MaxCircuit * 10)) ) IsetBalanced = MaxCircuit * 10;       
    
    
    Baseload = Imeasured - TotalCurrent;                                        // Calculate Baseload (load without any active EVSE)
    if (Baseload < 0) Baseload = 0;

    if (Mode == MODE_NORMAL)                                                    // Normal Mode
    {
        if (LoadBl == 1) IsetBalanced = MaxCircuit * 10;                        // Load Balancing = Master? MaxCircuit is max current for all active EVSE's
        else IsetBalanced = ChargeCurrent;                                      // No Load Balancing in Normal Mode. Set current to ChargeCurrent (fix: v2.05)
    }

    if (BalancedLeft)                                                           // Only if we have active EVSE's
    {
        // New EVSE charging, and no Solar mode
        if (mod && Mode != MODE_SOLAR) IsetBalanced = (MaxMains * 10) - Baseload;// Set max combined charge current to MaxMains - Baseload		
        
        if (IsetBalanced < 0 || IsetBalanced < (BalancedLeft * MinCurrent * 10) 
          || ( Mode == MODE_SOLAR && Isum > 10 && Imeasured > (MaxMains * 10)) )
        {
            IsetBalanced = BalancedLeft * MinCurrent * 10;                      // set minimal "MinCurrent" charge per active EVSE
            NoCurrent++;                                                        // Flag NoCurrent left
#ifdef LOG_INFO_EVSE
            printf("No Current!!\n\r");
#endif
        } else NoCurrent = 0;
        
        if (IsetBalanced > ActiveMax) IsetBalanced = ActiveMax;                 // limit to total maximum Amps (of all active EVSE's)

        MaxBalanced = IsetBalanced;                                             // convert to Amps

#ifdef LOG_DEBUG_EVSE
        printf("Imeasured:%.1f A IsetBalanced:%.1f A Baseload:%.1f A ", (double)Imeasured/10, (double)IsetBalanced/10, (double)Baseload/10);
#endif

        // Calculate average current per EVSE
        n = 0;
        do {
            Average = MaxBalanced / BalancedLeft;                               // Average current for all active EVSE's

        // Check for EVSE's that have a lower MAX current
            if ((BalancedState[n] == STATE_C) && (!CurrentSet[n]) && (Average >= BalancedMax[n])) // Active EVSE, and current not yet calculated?
            {
                Balanced[n] = BalancedMax[n];                                   // Set current to Maximum allowed for this EVSE
                CurrentSet[n] = 1;                                              // mark this EVSE as set.
                BalancedLeft--;                                                 // decrease counter of active EVSE's
                MaxBalanced -= Balanced[n];                                     // Update total current to new (lower) value
                n = 0;                                                          // check all EVSE's again
            } else n++;
        } while (n < 4 && BalancedLeft);

        // All EVSE's which had a Max current lower then the average are set.
        // Now calculate the current for the EVSE's which had a higher Max current
        n = 0;
        if (BalancedLeft)                                                       // Any Active EVSE's left?
        {
            do {                                                                // Check for EVSE's that are not set yet
                if ((BalancedState[n] == STATE_C) && (!CurrentSet[n]))                // Active EVSE, and current not yet calculated?
                {
                    Balanced[n] = MaxBalanced / BalancedLeft;                   // Set current to Average
                    CurrentSet[n] = 1;                                          // mark this EVSE as set.
                    BalancedLeft--;                                             // decrease counter of active EVSE's
                    MaxBalanced -= Balanced[n];                                 // Update total current to new (lower) value
                }
            } while (++n < 4 && BalancedLeft);
        }

        
    } // BalancedLeft
    
#ifdef LOG_DEBUG_EVSE
    if (LoadBl == 1) {
        for (n = 0; n < NR_SLAVES; n++) printf("EVSE%u[%u]:%u.%1u A ", n, BalancedState[n], Balanced[n]/10, Balanced[n]%10);
        printf("\n\r");
    }
#endif
}

/**
 * Broadcast momentary currents to all Slave EVSE's
 */
void BroadcastCurrent(void) {
    ModbusWriteMultipleRequest(0x01, 0x01, Balanced, NR_SLAVES);
}

/**
 * Combine Bytes received over modbus
 * 
 * @param pointer to var
 * @param pointer to buf
 * @param unsigned char pos
 * @param unsigned char endianness:\n
 *        0: low byte first, low word first (little endian)\n
 *        1: low byte first, high word first\n
 *        2: high byte first, low word first\n
 *        3: high byte first, high word first (big endian)
 */
void combineBytes(void *var, unsigned char *buf, unsigned char pos, unsigned char endianness) {
    char *pBytes;

    pBytes = var;
    
    // XC8 is little endian
    switch(endianness) {
        case ENDIANESS_LBF_LWF: // low byte first, low word first (little endian)
            *pBytes++ = (unsigned char)buf[pos + 0];
            *pBytes++ = (unsigned char)buf[pos + 1];
            *pBytes++ = (unsigned char)buf[pos + 2];
            *pBytes   = (unsigned char)buf[pos + 3];   
            break;
        case ENDIANESS_LBF_HWF: // low byte first, high word first
            *pBytes++ = (unsigned char)buf[pos + 2];
            *pBytes++ = (unsigned char)buf[pos + 3];
            *pBytes++ = (unsigned char)buf[pos + 0];
            *pBytes   = (unsigned char)buf[pos + 1];   
            break;
        case ENDIANESS_HBF_LWF: // high byte first, low word first
            *pBytes++ = (unsigned char)buf[pos + 1];
            *pBytes++ = (unsigned char)buf[pos + 0];
            *pBytes++ = (unsigned char)buf[pos + 3];
            *pBytes   = (unsigned char)buf[pos + 2];   
            break;
        case ENDIANESS_HBF_HWF: // high byte first, high word first (big endian)
            *pBytes++ = (unsigned char)buf[pos + 3];
            *pBytes++ = (unsigned char)buf[pos + 2];
            *pBytes++ = (unsigned char)buf[pos + 1];
            *pBytes   = (unsigned char)buf[pos + 0];   
            break;
        default:
            break;
    }
}

signed double receiveMeasurement(unsigned char *buf, unsigned char pos, unsigned char Endianness, unsigned char Divisor) {
    signed double dCombined;
    signed long lCombined;

    if (Divisor == 8) {
        combineBytes(&dCombined, buf, pos, Endianness);
    } else {
        combineBytes(&lCombined, buf, pos, Endianness);
        dCombined = (signed double) lCombined / pow10[Divisor];
    }

    return dCombined;
}

/**
 * Send Energy measurement request over modbus
 * 
 * @param unsigned char Meter
 * @param unsigned char Address
 */
void requestEnergyMeasurement(unsigned char Meter, unsigned char Address) {
    ModbusReadInputRequest(Address, EMConfig[Meter].Function, EMConfig[Meter].ERegister, 2);
}

/**
 * Read energy measurement from modbus
 * 
 * @param pointer to buf
 * @param unsigned char Meter
 * @return signed double Energy (kWh)
 */
signed double receiveEnergyMeasurement(unsigned char *buf, unsigned char Meter) {
    signed double dCombined;

    dCombined = receiveMeasurement(buf, 0, EMConfig[Meter].Endianness, EMConfig[Meter].EDivisor);

    switch(Meter) {
        case EM_FINDER:
            dCombined = dCombined / 1000;
            break;
    }
    
    return dCombined;
}

/**
 * Send Power measurement request over modbus
 * 
 * @param unsigned char Meter
 * @param unsigned char Address
 */
void requestPowerMeasurement(unsigned char Meter, unsigned char Address) {
    ModbusReadInputRequest(Address, EMConfig[Meter].Function, EMConfig[Meter].PRegister, 2);
}

/**
 * Read Power measurement from modbus
 * 
 * @param pointer to buf
 * @param unsigned char Meter
 * @return unsigned int Power (W)
  */
unsigned int receivePowerMeasurement(unsigned char *buf, unsigned char Meter) {
    signed double dCombined;

    dCombined = receiveMeasurement(buf, 0, EMConfig[Meter].Endianness, EMConfig[Meter].PDivisor);
    
    return dCombined;
}

/**
 * Send current measurement request over modbus
 * 
 * @param unsigned char Meter
 * @param unsigned char Address
 */
void requestCurrentMeasurement(unsigned char Meter, unsigned char Address) {
    switch(Meter) {
        case EM_SENSORBOX:
            ModbusReadInputRequest(Address, 4, 0, 20);
            break;
        case EM_EASTRON:
            // Phase 1-3 current: Register 0x06 - 0x0B (unsigned)
            // Phase 1-3 power:   Register 0x0C - 0x11 (signed)
            ModbusReadInputRequest(Address, 4, 0x06, 12);
            break;
        case EM_ABB:
            // Phase 1-3 current: Register 0x5B0C - 0x5B11 (unsigned)
            // Phase 1-3 power:   Register 0x5B16 - 0x5B1B (signed)
            ModbusReadInputRequest(Address, 3, 0x5B0C, 16);
            break;
        default:
            ModbusReadInputRequest(Address, EMConfig[Meter].Function, EMConfig[Meter].IRegister, 6);
            break;
    }  
}

/**
 * Read current measurement from modbus
 * 
 * @param pointer to buf
 * @param unsigned char Meter
 * @param pointer to var
 */
unsigned char receiveCurrentMeasurement(unsigned char *buf, unsigned char Meter, signed double *var) {
    unsigned char x, offset;

    // No CAL option in Menu
    CalActive = 0;

    switch(Meter) {
        case EM_SENSORBOX:
            // return immediately if the data contains no new P1 or CT measurement
            if (buf[3] == 0) return 0;  // error!!
            // determine if there is P1 data present, otherwise use CT data
            if (buf[3] & 0x80) offset = 16;                                     // P1 data present
            else offset = 28;                                                   // Use CTs
            // offset 16 is Smart meter P1 current
            for (x = 0; x < 3; x++) {
                // SmartEVSE works with Amps * 10
                var[x] = receiveMeasurement(buf, offset + (x * 4), EMConfig[Meter].Endianness, EMConfig[Meter].IDivisor) * 10.0;
                // When using CT's , adjust the measurements with calibration value
                if (offset == 28) {
                    var[x] = var[x] * ICal;
                    // When MaxMains is set to >100A, it's assumed 200A:50ma CT's are used.
                    if (MaxMains > 100) var[x] = var[x] * 2;                    // Multiply measured currents with 2
                    // very small negative currents are shown as zero.
                    if ((var[x] > -0.01) && (var[x] < 0.01)) var[x] = 0.0;      
                    CalActive = 1;                                              // Enable CAL option in Menu
                }
            }
            // Set Sensorbox 2 to 3/4 Wire configuration (and phase Rotation) (v2.16)
            if (buf[1] >= 0x10 && offset == 28) {
                GridActive = 1;                                                 // Enable the GRID menu option
                #ifdef SPECIAL                                                  // Only when Load balancing is Disabled/Master
                if ((buf[1] & 0x3) != GRID && (LoadBl < 2)) ModbusWriteSingleRequest(0x0A, 0x800, GRID);
                #else
                if ((buf[1] & 0x3) != (Grid << 1) && (LoadBl < 2)) ModbusWriteSingleRequest(0x0A, 0x800, Grid << 1);
                #endif
            } else GridActive = 0;
            break;
        default:
            for (x = 0; x < 3; x++) {
                var[x] = receiveMeasurement(buf, (x * 4), EMConfig[Meter].Endianness, EMConfig[Meter].IDivisor) * 10.0;
            }
            break;
    }

    // Get sign from power measurement on some electric meters
    switch(Meter) {
        case EM_EASTRON:
            for (x = 0; x < 3; x++) {
                if (receiveMeasurement(buf, ((x + 3) * 4), EMConfig[Meter].Endianness, EMConfig[Meter].PDivisor) < 0) var[x] = -var[x];
            }
            break;
        case EM_ABB:
            for (x = 0; x < 3; x++) {
                if (receiveMeasurement(buf, ((x + 5) * 4), EMConfig[Meter].Endianness, EMConfig[Meter].PDivisor) < 0) var[x] = -var[x];
            }
            break;
    }

    // all OK
    return 1;
}

/**
 * Master requests Slave status over modbus
 * Master -> Slave
 * 
 * @param unsigned char SlaveNr (1-3)
 */
void requestSlaveStatus(unsigned char SlaveNr) {
    ModbusReadInputRequest(SlaveNr + 1, 4, 0xA0 , 9);                           // Slave address, start register = 0xA0 , nr of registers 9
}


/**
 * Master receives Slave status over modbus
 * Slave -> Master
 * 
 * @param unsigned char SlaveAdr (1-3)
 */
void receiveSlaveStatus(unsigned char *buf, unsigned char SlaveAdr) {
    BalancedState[SlaveAdr] = buf[1];                                           // Slave State
    BalancedError[SlaveAdr] = buf[3];                                           // Slave Error status
    BalancedMax[SlaveAdr] = buf[5] * 10;                                        // Slave Max ChargeCurrent (0.1A)
    //printf("ReceivedSlave[%u]Status State:%u Error:%u, BalancedMax:%u \r\n", SlaveAdr, BalancedState[SlaveAdr], BalancedError[SlaveAdr], BalancedMax[SlaveAdr] );
}

/**
 * Master checks slave status requests, and responds with new state
 * Master -> Slave
 * 
 * @param unsigned char SlaveAdr (1-3)
 */
void processAllSlaveStates(unsigned char SlaveAdr) {
    unsigned int values[2];
    unsigned char current, write = 0;

    values[0] = BalancedState[SlaveAdr];

    current = IsCurrentAvailable();
    if (current) {                                                              // Yes enough current
        if (BalancedError[SlaveAdr] & (LESS_6A|NO_SUN)) {
            BalancedError[SlaveAdr] &= ~(LESS_6A | NO_SUN);                     // Clear Error flags
            write = 1;
        }
    }

    // Check EVSE for request to charge states
    switch (BalancedState[SlaveAdr]) {
        case STATE_B:
            if (current == 0) {
                Balanced[SlaveAdr] = 0;                                         // Make sure the Slave does not start charging by setting current to 0
                BalancedState[SlaveAdr] = STATE_A;
                values[0] = STATE_A;
                if (Mode == MODE_SOLAR) BalancedError[SlaveAdr] |= NO_SUN;      // Solar mode: No Solar Power available
                else BalancedError[SlaveAdr] |= LESS_6A;                        // Normal or Smart Mode: Not enough current available 
                write = 1;
#ifdef LOG_INFO_EVSE
                printf("State B->A - Not enough current!\r\n");
#endif
            }
            break;

        case STATE_COMM_B:                                                      // Request to charge A->B
#ifdef LOG_INFO_EVSE
            printf("Slave %u State A->B request ", SlaveAdr);
#endif
            if (current) {                                                      // check if we have enough current
                                                                                // Yes enough current..
                BalancedState[SlaveAdr] = STATE_B;                              // Mark Slave EVSE as active (State B)
                Balanced[SlaveAdr] = MinCurrent * 10;                           // Initially set current to lowest setting
                values[0] = STATE_COMM_B_OK;
                write = 1;
#ifdef LOG_INFO_EVSE
                printf("- OK!\r\n");
#endif
            } else {                                                            // We do not have enough current to start charging
                Balanced[SlaveAdr] = 0;                                         // Make sure the Slave does not start charging by setting current to 0
                if ((BalancedError[SlaveAdr] & (LESS_6A|NO_SUN)) == 0) {        // Error flags cleared?
                    if (Mode == MODE_SOLAR) BalancedError[SlaveAdr] |= NO_SUN;  // Solar mode: No Solar Power available
                    else BalancedError[SlaveAdr] |= LESS_6A;                    // Normal or Smart Mode: Not enough current available 
                    write = 1;
                }
#ifdef LOG_INFO_EVSE
                printf("- Not enough current!\r\n");
#endif
            }
            break;

        case STATE_COMM_C:                                                      // request to charge B->C
#ifdef LOG_INFO_EVSE
            printf("Slave %u State B->C request ", SlaveAdr);
#endif
            Balanced[SlaveAdr] = 0;                                             // For correct baseload calculation set current to zero
            if (current) {                                                      // check if we have enough current
                                                                                // Yes
                BalancedState[SlaveAdr] = STATE_C;                              // Mark Slave EVSE as Charging (State C)
                CalcBalancedCurrent(1);                                         // Calculate charge current for all connected EVSE's
                values[0] = STATE_COMM_C_OK;
                write = 1;
#ifdef LOG_INFO_EVSE
                printf("- OK!\r\n");
#endif
            } else {                                                            // We do not have enough current to start charging
                if ((BalancedError[SlaveAdr] & (LESS_6A|NO_SUN)) == 0) {        // Error flags cleared?
                    if (Mode == MODE_SOLAR) BalancedError[SlaveAdr] |= NO_SUN;  // Solar mode: No Solar Power available
                    else BalancedError[SlaveAdr] |= LESS_6A;                    // Normal or Smart Mode: Not enough current available 
                    write = 1;
                }
#ifdef LOG_INFO_EVSE
                printf("- Not enough current!\r\n");
#endif
            }
            break;

        default:
            break;

    }
    values[1] = BalancedError[SlaveAdr];

    if (write) {
#ifdef LOG_DEBUG_EVSE
        printf("SlaveAdr %u, BalancedError:%u \r\n",SlaveAdr, BalancedError[SlaveAdr]);
#endif
        ModbusWriteMultipleRequest(SlaveAdr+1 , 0xA0, values, 2);               // Write State and Error to Slave
    }

}


// Counts nr of menu options currently available
unsigned char GetPosInMenu (unsigned char count) {
    unsigned char i;

    for (i = 0; i < count; i++) {
        if (MenuItems[i] == LCDNav) return i+1;
    }
    return 0;
}


/**
 * Create an array of available menu items
 * Depends on configuration settings like CONFIG/MODE/LoadBL
 * 
 * @return unsigned char MenuItemCount
 */
unsigned char getMenuItems (void) {
    unsigned char m = 0;

    MenuItems[m++] = MENU_CONFIG;                                               // Configuration (0:Socket / 1:Fixed Cable)
    if (!Config) {                                                              // ? Fixed Cable?
        MenuItems[m++] = MENU_LOCK;                                             // - Cable lock (0:Disable / 1:Solenoid / 2:Motor)
    }
    MenuItems[m++] = MENU_MODE;                                                 // EVSE mode (0:Normal / 1:Smart)
    if (Mode == MODE_SOLAR && LoadBl < 2) {                                     // ? Solar mode and Load Balancing Disabled/Master?
        MenuItems[m++] = MENU_START;                                            // - Start Surplus Current (A)
        MenuItems[m++] = MENU_STOP;                                             // - Stop time (min)
        #ifndef SPECIAL
        MenuItems[m++] = MENU_IMPORT;                                           // - Import Current from Grid (A)
        #endif
    }
    MenuItems[m++] = MENU_LOADBL;                                               // Load Balance Setting (0:Disable / 1:Master / 2-4:Slave)
    if (Mode && LoadBl < 2) {                                                   // ? Mode Smart/Solar and Load Balancing Disabled/Master?
        MenuItems[m++] = MENU_MAINS;                                            // - Max Mains Amps (hard limit, limited by the MAINS connection) (A) (Mode:Smart/Solar)
    }
    if (Mode && LoadBl < 2 || LoadBl == 1) {                                    // ? Mode Smart/Solar or LoadBl Master?
        MenuItems[m++] = MENU_MIN;                                              // - Minimal current the EV is happy with (A) (Mode:Smart/Solar or LoadBl:Master)
    }
    if (LoadBl == 1) {                                                          // ? Load balancing Master?
        MenuItems[m++] = MENU_CIRCUIT;                                          // - Max current of the EVSE circuit (A) (LoadBl:Master)
    }
    MenuItems[m++] = MENU_MAX;                                                  // Max Charge current (A)
    MenuItems[m++] = MENU_SWITCH;                                               // External Switch on SW (0:Disable / 1:Access / 2:Smart-Solar)
    MenuItems[m++] = MENU_RCMON;                                                // Residual Current Monitor on RCM (0:Disable / 1:Enable)
    MenuItems[m++] = MENU_RFIDREADER;                                           // RFID Reader connected to SW (0:Disable / 1:Enable / 2:Learn / 3:Delete / 4:Delate All)
    if (Mode && LoadBl < 2) {                                                   // ? Smart or Solar mode?
        MenuItems[m++] = MENU_MAINSMETER;                                       // - Type of Mains electric meter (0: Disabled / Constants EM_*)
        if (MainsMeter == EM_SENSORBOX) {                                       // - ? Sensorbox?
            #ifndef SPECIAL
            if (GridActive == 1) MenuItems[m++] = MENU_GRID;
            #endif
            if (CalActive == 1) MenuItems[m++] = MENU_CAL;                      // - - Sensorbox CT measurement calibration
        } else if(MainsMeter) {                                                 // - ? Other?
            MenuItems[m++] = MENU_MAINSMETERADDRESS;                            // - - Address of Mains electric meter (5 - 254)
            MenuItems[m++] = MENU_MAINSMETERMEASURE;                            // - - What does Mains electric meter measure (0: Mains (Home+EVSE+PV) / 1: Home+EVSE / 2: Home)
            if (MainsMeterMeasure) {                                            // - - ? PV not measured by Mains electric meter?
                MenuItems[m++] = MENU_PVMETER;                                  // - - - Type of PV electric meter (0: Disabled / Constants EM_*)
                if (PVMeter) MenuItems[m++] = MENU_PVMETERADDRESS;              // - - - - Address of PV electric meter (5 - 254)
            }
        }
        MenuItems[m++] = MENU_EVMETER;                                          // - Type of EV electric meter (0: Disabled / Constants EM_*)
        if (EVMeter) {                                                          // - ? EV meter configured?
            MenuItems[m++] = MENU_EVMETERADDRESS;                               // - - Address of EV electric meter (5 - 254)
        }
        if (MainsMeter == EM_CUSTOM || PVMeter == EM_CUSTOM || EVMeter == EM_CUSTOM) { // ? Custom electric meter used?
            MenuItems[m++] = MENU_EMCUSTOM_ENDIANESS;                           // - Byte order of custom electric meter
            MenuItems[m++] = MENU_EMCUSTOM_UREGISTER;                           // - Starting register for voltage of custom electric meter
            MenuItems[m++] = MENU_EMCUSTOM_UDIVISOR;                            // - Divisor for voltage of custom electric meter
            MenuItems[m++] = MENU_EMCUSTOM_IREGISTER;                           // - Starting register for current of custom electric meter
            MenuItems[m++] = MENU_EMCUSTOM_IDIVISOR;                            // - Divisor for current of custom electric meter
            MenuItems[m++] = MENU_EMCUSTOM_PREGISTER;                           // - Starting register for power of custom electric meter
            MenuItems[m++] = MENU_EMCUSTOM_PDIVISOR;                            // - Divisor for power of custom electric meter
            MenuItems[m++] = MENU_EMCUSTOM_EREGISTER;                           // - Starting register for energy of custom electric meter
            MenuItems[m++] = MENU_EMCUSTOM_EDIVISOR;                            // - Divisor for energy of custom electric meter
        }
    }
    MenuItems[m++] = MENU_EXIT;

    return m;
}

/**
 * Check minimum and maximum of a value and set the variable
 * 
 * @param unsigned char MENU_xxx
 * @param unsigned int value
 * @return unsigned char success
 */
unsigned char setItemValue(unsigned char nav, unsigned int val) {
    unsigned char ret = 0;

    if (nav == STATUS_MODE) nav = MENU_MODE;

    if (nav < MENU_EXIT) {
        if (val >= MenuStr[nav].Min && val <= MenuStr[nav].Max) {
            switch (nav) {
                case MENU_CONFIG:
                    Config = val;
                    break;
                case MENU_MODE:
                    Mode = val;
                    break;
                case MENU_START:
                    StartCurrent = val;
                    break;
                case MENU_STOP:
                    StopTime = val;
                    break;
                case MENU_IMPORT:
                    ImportCurrent = val;
                    break;    
                case MENU_LOADBL:
                    LoadBl = val;
                    break;
                case MENU_MAINS:
                    MaxMains = val;
                    break;
                case MENU_MIN:
                    MinCurrent = val;
                    break;
                case MENU_MAX:
                    MaxCurrent = val;
                    break;
                case MENU_CIRCUIT:
                    MaxCircuit = val;
                    break;
                case MENU_LOCK:
                    Lock = val;
                    break;
                case MENU_SWITCH:
                    Switch = val;
                    break;
                case MENU_RCMON:
                    RCmon = val;
                    break;
                case MENU_CAL:
                    ICal = (signed double)val / 100;
                    break;
                case MENU_GRID:
                    Grid = val;
                    break;
                case MENU_MAINSMETER:
                    MainsMeter = val;
                    break;
                case MENU_MAINSMETERADDRESS:
                    MainsMeterAddress = val;
                    break;
                case MENU_MAINSMETERMEASURE:
                    MainsMeterMeasure = val;
                    break;
                case MENU_PVMETER:
                    PVMeter = val;
                    break;
                case MENU_PVMETERADDRESS:
                    PVMeterAddress = val;
                    break;
                case MENU_EVMETER:
                    EVMeter = val;
                    break;
                case MENU_EVMETERADDRESS:
                    EVMeterAddress = val;
                    break;
                case MENU_EMCUSTOM_ENDIANESS:
                    EMConfig[EM_CUSTOM].Endianness = val;
                    break;
                case MENU_EMCUSTOM_UREGISTER:
                    EMConfig[EM_CUSTOM].URegister = val;
                    break;
                case MENU_EMCUSTOM_UDIVISOR:
                    EMConfig[EM_CUSTOM].UDivisor = val;
                    break;
                case MENU_EMCUSTOM_IREGISTER:
                    EMConfig[EM_CUSTOM].IRegister = val;
                    break;
                case MENU_EMCUSTOM_IDIVISOR:
                    EMConfig[EM_CUSTOM].IDivisor = val;
                    break;
                case MENU_EMCUSTOM_PREGISTER:
                    EMConfig[EM_CUSTOM].PRegister = val;
                    break;
                case MENU_EMCUSTOM_PDIVISOR:
                    EMConfig[EM_CUSTOM].PDivisor = val;
                    break;
                case MENU_EMCUSTOM_EREGISTER:
                    EMConfig[EM_CUSTOM].ERegister = val;
                    break;
                case MENU_EMCUSTOM_EDIVISOR:
                    EMConfig[EM_CUSTOM].EDivisor = val;
                    break;
                case MENU_RFIDREADER:
                    RFIDReader = val;
                    break;
                default:
                    break;
            }
            ret = 1;
        }
    } else {
        ret = 1;
        switch (nav) {
            case STATUS_STATE:                                                  // Write the State register 0x00A0
                State = val;
                break;
            case STATUS_ERROR:                                                  // Write the Error register 0x00A1
                Error = val;
                break;
            case STATUS_CURRENT:                                                // Write the Current register 0x00A6
                OverrideCurrent = val;
                break;
            case STATUS_ACCESS:                                                 // Write the Access register 0x00A7
                if (val == 0 || val == 1) {
                    Access_bit = val;
                    ret = 1;
                    if (val == 0) State = STATE_A;
                }
                break;
            default:
                ret = 0;
                break;
        }
    }

    return ret;
}

/**
 * Get the variable
 * 
 * @param unsigned char MENU_xxx
 * @return unsigned int value
 */
unsigned int getItemValue(unsigned char nav) {
    switch (nav) {
        case MENU_CONFIG:
            return Config;
        case MENU_MODE:
        case STATUS_MODE:
            return Mode;
        case MENU_START:
            return StartCurrent;
        case MENU_STOP:
            return StopTime;
        case MENU_IMPORT:
            return ImportCurrent;    
        case MENU_LOADBL:
            return LoadBl;
        case MENU_MAINS:
            return MaxMains;
        case MENU_MIN:
            return MinCurrent;
        case MENU_MAX:
            return MaxCurrent;
        case MENU_CIRCUIT:
            return MaxCircuit;
        case MENU_LOCK:
            return Lock;
        case MENU_SWITCH:
            return Switch;
        case MENU_RCMON:
            return RCmon;
        case MENU_CAL:
            return (unsigned int) (ICal * 100);
        case MENU_GRID:
            return Grid;
        case MENU_MAINSMETER:
            return MainsMeter;
        case MENU_MAINSMETERADDRESS:
            return MainsMeterAddress;
        case MENU_MAINSMETERMEASURE:
            return MainsMeterMeasure;
        case MENU_PVMETER:
            return PVMeter;
        case MENU_PVMETERADDRESS:
            return PVMeterAddress;
        case MENU_EVMETER:
            return EVMeter;
        case MENU_EVMETERADDRESS:
            return EVMeterAddress;
        case MENU_EMCUSTOM_ENDIANESS:
            return EMConfig[EM_CUSTOM].Endianness;
        case MENU_EMCUSTOM_UREGISTER:
            return EMConfig[EM_CUSTOM].URegister;
        case MENU_EMCUSTOM_UDIVISOR:
            return EMConfig[EM_CUSTOM].UDivisor;
        case MENU_EMCUSTOM_IREGISTER:
            return EMConfig[EM_CUSTOM].IRegister;
        case MENU_EMCUSTOM_IDIVISOR:
            return EMConfig[EM_CUSTOM].IDivisor;
        case MENU_EMCUSTOM_PREGISTER:
            return EMConfig[EM_CUSTOM].PRegister;
        case MENU_EMCUSTOM_PDIVISOR:
            return EMConfig[EM_CUSTOM].PDivisor;
        case MENU_EMCUSTOM_EREGISTER:
            return EMConfig[EM_CUSTOM].ERegister;
        case MENU_EMCUSTOM_EDIVISOR:
            return EMConfig[EM_CUSTOM].EDivisor;
        case MENU_RFIDREADER:
            return RFIDReader;

        case STATUS_STATE:
            return State;
        case STATUS_ERROR:
            return Error;
        case STATUS_MAX:
            return MaxCapacity;
        case STATUS_MIN:
            return MinCurrent; // In solar mode StartCurrent?
        case STATUS_CURRENT:
            return Balanced[0];
        case STATUS_ACCESS:
            return Access_bit;

        default:
            return 0;
    }
}

/**
 * Get active option of an menu item
 * 
 * @param unsigned char nav
 * @return unsigned char[] MenuItemOption
 */
const far char * getMenuItemOption(unsigned char nav) {
    unsigned char Str[10];
    unsigned int value;
    
    value = getItemValue(nav); 

    switch (nav) {
        case MENU_CONFIG:
            if (Config) return StrFixed;
            else return StrSocket;
        case MENU_MODE:
            if (Mode == MODE_SMART) return StrSmart;
            else if (Mode == MODE_SOLAR) return StrSolar;
            else return StrNormal;
        case MENU_START:
                sprintf(Str, "-%2u A", value);
                return Str;
        case MENU_STOP:
            if (value) {
                sprintf(Str, "%2u min", value);
                return Str;
            } else return StrDisabled;
        case MENU_LOADBL:
            return StrLoadBl[LoadBl];
        case MENU_MAINS:
        case MENU_MIN:
        case MENU_MAX:
        case MENU_CIRCUIT:
        case MENU_IMPORT:
            sprintf(Str, "%2u A", value);
            return Str;
        case MENU_LOCK:
            if (Lock == 1) return StrSolenoid;
            else if (Lock == 2) return StrMotor;
            else return StrDisabled;
        case MENU_SWITCH:
            return StrSwitch[Switch];
        case MENU_RCMON:
            if (RCmon) return StrEnabled;
            else return StrDisabled;
        case MENU_MAINSMETER:
        case MENU_PVMETER:
        case MENU_EVMETER:
            return EMConfig[value].Desc;
        case MENU_GRID:
            return StrGrid[Grid];
        case MENU_MAINSMETERADDRESS:
        case MENU_PVMETERADDRESS:
        case MENU_EVMETERADDRESS:
        case MENU_EMCUSTOM_UREGISTER:
        case MENU_EMCUSTOM_IREGISTER:
        case MENU_EMCUSTOM_PREGISTER:
        case MENU_EMCUSTOM_EREGISTER:
            if(value < 0x1000) sprintf(Str, "%u (%02X)", value, value);
            else sprintf(Str, "%u %X", value, value);
            return Str;
        case MENU_MAINSMETERMEASURE:
            if (MainsMeterMeasure) return StrMainsHomeEVSE;
            else return StrMainsAll;
        case MENU_EMCUSTOM_ENDIANESS:
            switch(value) {
                case 0: return "LBF & LWF";
                case 1: return "LBF & HWF";
                case 2: return "HBF & LWF";
                case 3: return "HBF & HWF";
                default:
                    break;
            }
        case MENU_EMCUSTOM_UDIVISOR:
        case MENU_EMCUSTOM_IDIVISOR:
        case MENU_EMCUSTOM_PDIVISOR:
        case MENU_EMCUSTOM_EDIVISOR:
            if (value == 8) return "Double";
            sprintf(Str, "%lu", pow10[value]);
            return Str;
        case MENU_RFIDREADER:
            return StrRFIDReader[RFIDReader];
        case MENU_EXIT:
            return StrExitMenu;
        default:
            return "";
    }
}

/**
 * Map a Modbus register to an item ID (MENU_xxx or STATUS_xxx)
 * 
 * @return unsigned char ItemID
 */
unsigned char mapModbusRegister2ItemID() { // Modbus.Register / Modbus.RegisterCount
    unsigned int RegisterStart, ItemStart, Count;

    // Register 0x0*: Slave -> Master
    if (Modbus.Register == 0x01) {// && Modbus.Register <= 0x04) {
        return 255;
    }

    else if (Modbus.Register == 0xA8 && (Mode == 0 || LoadBl == 0) ) {          // Do not change Charge Mode when set to Normal or Load Balancing is disabled
        return 255;
    }

    // Register 0xA*: Status
    // 0xA0: State
    // 0xA1: Error
    // 0xA2: Maximum charging current
    // 0xA3: Minimum charging current
    // 0xA4: Number of used phases (ToDo)
    // 0xA5: Real charging current (ToDo)
    // 0xA6: Charging current (A * 10)
    // 0xA7: Access bit
    // 0xA8: EVSE Mode
    else if (Modbus.Register >= 0xA0 && Modbus.Register <= 0xA8) {
        RegisterStart = 0xA0;
        ItemStart = STATUS_STATE;
        Count = 9;
    }

    // Register 0xC*: Configuration
    // 0xC0: Configuration
    // 0xC1: Load Balance
    // 0xC2: Minimal current the EV is happy with
    // 0xC3: Fixed Cable Current limit
    // 0xC4: Cable lock
    // 0xC5: Surplus energy start Current
    // 0xC6: Stop solar charging at 6A after this time
    // 0xC7: External Start/Stop button
    // 0xC8: Residual Current Monitor
    else if (Modbus.Register >= 0xC0 && Modbus.Register <= 0xC8) {
        RegisterStart = 0xC0;
        ItemStart = MENU_CONFIG;
        Count = 9;
    }

    // Register 0xE*: Load balancing configuration (same on all SmartEVSE)
    // 0xE0: Max Charge Current of the system
    // 0xE1: EVSE mode
    // 0xE2: Max Mains Current
    // 0xE3: CT calibration value
    // 0xE4: Type of Mains electric meter
    // 0xE5: Address of Mains electric meter
    // 0xE6: What does Mains electric meter measure
    // 0xE7: Type of PV electric meter
    // 0xE8: Address of PV electric meter
    // 0xE9: Byte order of custom electric meter
    // 0xEA: Register for Current of custom electric meter
    // 0xEB: Divisor for Current of custom electric meter (10^x)
    else if (Modbus.Register >= 0xE0 && Modbus.Register <= 0xEB) {
        RegisterStart = 0xE0;
        ItemStart = MENU_MAX;
        Count = 12;
    }

    else {
        return 0;
    }
    
    if (Modbus.RegisterCount <= (RegisterStart + Count) - Modbus.Register) {
        return (Modbus.Register - RegisterStart + ItemStart);
    } else {
        return 0;
    }
}

/**
 * Read item values and send modbus response
 * 
 * @param unsigned char ItemID: Start item ID
 */
void ReadItemValueResponse(unsigned char ItemID) {
    unsigned char i;
    unsigned int values[12];

    if (ItemID) {
        for (i = 0; i < Modbus.RegisterCount; i++) {
            values[i] = getItemValue(ItemID + i);
        }
        ModbusReadInputResponse(Modbus.Address, Modbus.Function, values, Modbus.RegisterCount);
    } else {
        ModbusException(Modbus.Address, Modbus.Function, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS);
    }
}

/**
 * Write item values and send modbus response
 * 
 * @param unsigned char ItemID: Start item ID
 */
void WriteItemValueResponse(unsigned char ItemID) {
    unsigned char OK = 0;

    if (ItemID) {
        OK = setItemValue(ItemID, Modbus.Value);
    }

    if (OK && ItemID < STATUS_STATE) write_settings();

    if (Modbus.Address > 0 || LoadBl == 0) {
        if (!ItemID) {
            ModbusException(Modbus.Address, Modbus.Function, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS);
        } else if (!OK) {
            ModbusException(Modbus.Address, Modbus.Function, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE);
        } else {
            ModbusWriteSingleResponse(Modbus.Address, Modbus.Register, Modbus.Value);
        }
    }
}

/**
 * Write multiple item values and send modbus response
 * 
 * @param unsigned char ItemID: Start item ID
 */
void WriteMultipleItemValueResponse(unsigned char ItemID) {
    unsigned int i, OK = 0, value;

    if (ItemID) {
        for (i = 0; i < Modbus.RegisterCount; i++) {
            value = (Modbus.Data[i * 2] <<8) | Modbus.Data[(i * 2) + 1];
            OK += setItemValue(ItemID + i, value);
        }
    }

    if (OK && ItemID < STATUS_STATE) write_settings();

    if (Modbus.Address > 0 || LoadBl == 0) {
        if (!ItemID) {
            ModbusException(Modbus.Address, Modbus.Function, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS);
        } else if (!OK) {
            ModbusException(Modbus.Address, Modbus.Function, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE);
        } else  {
            ModbusWriteMultipleResponse(Modbus.Address, Modbus.Register, OK);
        }
    }
}

// Serial Command line interface
// Display Menu, and process input.
//------------------------------------------------
// Smart EVSE
// -- Main menu --
// CONFIG - Set to Fixed Cable or Type 2 Socket
// MODE   - Set to Normal, Smart or Solar EVSE mode
// START  - Surplus energy start Current
// STOP   - Stop solar charging at 6A after this time
// LOADBL - Set Load Balancing to Disabled, Master or Slave1-3
// MAINS  - Set max MAINS Current (25-100)
// MAX    - Set MAX Charge Current for the EV (16-80)
// MIN    - Set MIN Charge Current the EV will accept
// CAL    - Calibrate CT1
// LOCK   - Cable lock Disable/Solenoid/Motor
// ACCESS - Access control on IO2                    
// RCMON  - Residual Current Monitor on IO3
// L1: 1.2A L2: 5.3A L3: 0.4A (MAX:26A MIN:10A)
//

void RS232cli(void) {
    unsigned char i, OK;
    unsigned int n;
    double Inew, Iold;
    unsigned char MenuItemsCount = getMenuItems();

    printf("\r\n");
    if (menu == 0)                                                              // menu = Main Menu
    {
        for(i = 0; i < MenuItemsCount - 1; i++) {
            if (strcmp(U2buffer, MenuStr[MenuItems[i]].Key) == 0) menu = MenuItems[i];
        }
        if (strcmp(U2buffer, (const far char *) "STATE?") == 0 ) {              // request charging state for all connected EVSE's
            menu = MENU_STATE;
        }
    } else if (U2buffer[0] == 0) menu = 0;
    else {
        switch (menu) {
            case MENU_CAL:
                Inew = atof(U2buffer);
                if ((Inew < 6) || (Inew > 80)) printf("\r\nError! please calibrate with at least 6A\r\n");
                else {
                    Iold = abs(Irms[0]) / ICal;
                    ICal = (Inew * 10) / Iold;                                  // Calculate new Calibration value
                    write_settings();
                }
                break;
            case MENU_MODE:
                if (strcmp(U2buffer, (const far char *) "SOLAR") == 0) {
                    Mode = MODE_SOLAR;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "SMART") == 0) {
                    Mode = MODE_SMART;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "NORMAL") == 0) {
                    Mode = MODE_NORMAL;
                    write_settings();
                    Error = NO_ERROR; // Clear Errors
                }
                break;
            case MENU_LOCK:
                if (strcmp(U2buffer, (const far char *) "SOLENOID") == 0) {
                    Lock = 1;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "MOTOR") == 0) {
                    Lock = 2;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "DISABLE") == 0) {
                    Lock = 0;
                    write_settings();
                }
                break;
            case MENU_CONFIG:
                if (strcmp(U2buffer, (const far char *) "FIXED") == 0) {
                    Config = 1;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "SOCKET") == 0) {
                    Config = 0;
                    write_settings();
                }
                break;
            case MENU_LOADBL:
                for(i = 0; i < 5; i++){
                    if (strcmp(U2buffer, StrLoadBl[i]) == 0) {
                        LoadBl = i;
                        write_settings();
                    }
                }
                break;
            case MENU_SWITCH:
                for(i = 0; i < 5; i++){
                    if (strcmp(U2buffer, StrSwitch[i]) == 0) {
                        Switch = i;
                        write_settings();
                    }
                }
                break;
            case MENU_GRID:
                for(i = 0; i < 2; i++){
                    if (strcmp(U2buffer, StrGrid[i]) == 0) {
                        Grid = i;                                               // 4Wire=0, 3Wire=1
                        write_settings();
                    }
                }
                break;
            case MENU_RCMON:
                if (strcmp(U2buffer, (const far char *) "DISABLE") == 0) {
                    RCmon = 0;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "ENABLE") == 0) {
                    RCmon = 1;
                    write_settings();
                }
                break;
            case MENU_MAINSMETER:
            case MENU_PVMETER:
            case MENU_EVMETER:
                for(i = 0; i <= EM_CUSTOM; i++){                                // Don't accept Sensorbox for EVMETER
                    if ( (strcmp(U2buffer, EMConfig[i].Desc) == 0) && !(EMConfig[i].ERegister == 0xffff && menu == MENU_EVMETER) ) {
                        setItemValue(menu, i);
                        write_settings();
                    }
                }
                break;
            case MENU_MAINSMETERMEASURE:
                if (strcmp(U2buffer, (const far char *) "ALL") == 0) {
                    MainsMeterMeasure = 0;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "HOME") == 0) {
                    MainsMeterMeasure = 1;
                    write_settings();
                }
                break;
            case MENU_RFIDREADER:
                for(i = 0; i < 5; i++) {
                    if (strcmp(U2buffer, StrRFIDReader[i]) == 0) {
                        RFIDReader = i;
                        write_settings();
                    }
                }
                break;
            default:
                n = (unsigned int) atoi(U2buffer);
                OK = setItemValue(menu, n);
                write_settings();
                if(!OK) printf("\r\nError! please check limits\r\n");
                break;
        }

        menu = 0;
        MenuItemsCount = getMenuItems();
    }

    // Show active item configuration
    if (menu > 14 && menu < MENU_EXIT) printf("%s is set to %s\r\n", MenuStr[menu].Desc, getMenuItemOption(menu));

    switch (menu) {
        case 0:
            printf("\r\n----------------------------- SMART EVSE -----------------------------\r\n v");
            printf(VERSION);
            printf(" for instructions, see www.smartevse.org\r\n");
            printf(" Internal Temperature: %i C  SN: %06u\r\n", TempEVSE, serialnr);
            printf("----------------------------------------------------------------------\r\n");
            for(i = 0; i < MenuItemsCount - 1; i++) {
                printf("%-07s - %-50s - ", MenuStr[MenuItems[i]].Key, MenuStr[MenuItems[i]].Desc);
                if (MenuItems[i] == MENU_CAL) {
                    printf("CT1:%d.%u A CT2:%d.%u A CT3:%d.%u A)", (int)Irms[0]/10, (unsigned int)abs(Irms[0])%10, (int)Irms[1]/10, (unsigned int)abs(Irms[1])%10, (int)Irms[2]/10, (unsigned int)abs(Irms[2])%10);
                } else {
                    printf(getMenuItemOption(MenuItems[i]));
                }
                printf("\r\n");
            }

            printf(">");
            break;
        case MENU_CONFIG:
            printf("Configuration : %s\r\nEnter new Configuration (FIXED/SOCKET): ", getMenuItemOption(menu));
            break;
        case MENU_MODE:
            printf("EVSE set to : %s\r\nEnter new EVSE Mode (NORMAL/SMART/SOLAR): ", getMenuItemOption(menu));
            break;
        case MENU_START:
            printf("Surplus energy start Current set to: %u A\r\nEnter new Surplus start Current (1-16): -", StartCurrent);
            break;
        case MENU_STOP:
            printf("Stop solar charging at 6A after %u min.\r\nEnter new time (0-60) min: ", StopTime);
            break;
        case MENU_IMPORT:
            printf("Allow Import from grid. Current set to: %u A\r\nEnter new Import Current (0-6): ", ImportCurrent);
            break;    
        case MENU_LOADBL:
            printf("Load Balancing set to : %s\r\nEnter Load Balancing mode (%s", getMenuItemOption(menu), StrLoadBl[0]);
            for(i = 1; i < 5; i++) {
                printf("/%s", StrLoadBl[i]);
            }
            printf("): ");
            break;
        case MENU_MAINS:
            printf("WARNING - DO NOT SET CURRENT HIGHER THAN YOUR CIRCUIT BREAKER\r\n");
            printf("OR GREATER THAN THE RATED VALUE OF THE EVSE\r\n");
            printf("MAINS Current set to: %u A\r\nEnter new max MAINS Current (10-200): ", MaxMains);
            break;
        case MENU_MIN:
            printf("MIN Charge Current set to: %u A\r\nEnter new MIN Charge Current (6-16): ", MinCurrent);
            break;
        case MENU_MAX:
            printf("WARNING - DO NOT SET CURRENT HIGHER THAN YOUR CIRCUIT BREAKER\r\n");
            printf("OR GREATER THAN THE RATED VALUE OF THE EVSE\r\n");
            printf("MAX Current set to: %u A\r\nEnter new MAX Charge Current (6-80): ", MaxCurrent);
            break;
        case MENU_CIRCUIT:
            printf("WARNING - DO NOT SET CURRENT HIGHER THAN YOUR CIRCUIT BREAKER\r\n");
            printf("OR GREATER THAN THE RATED VALUE OF THE EVSE\r\n");
            printf("EVSE Circuit Current limit set to: %u A\r\nEnter new limit (10-160): ", MaxCircuit);
            break;
        case MENU_LOCK:
            printf("Cable lock set to : %s\r\nEnter new Cable lock mode (DISABLE/SOLENOID/MOTOR): ", getMenuItemOption(menu));
            break;
        case MENU_SWITCH:
            printf("Access Control on pin SW set to : %s\r\nAccess Control on SW (%s", getMenuItemOption(menu), StrSwitch[0]);
            for(i = 1; i < 5; i++) {
                printf("/%s", StrSwitch[i]);
            }
            printf("): ");
            break;
        case MENU_RCMON:
            printf("Residual Current Monitor on pin RCM set to : %s\r\nResidual Current Monitor (DISABLE/ENABLE): ", getMenuItemOption(menu));
            break;
        case MENU_GRID:
            printf("GRID connection (for correct Sensorbox measurement) set to : %s\r\nGrid set to (4Wire/3Wire): ", getMenuItemOption(menu));
            break;    
        case MENU_CAL:
            printf("CT1 reads: %d.%u A\r\nEnter new Measured Current for CT1: ", (int)Irms[0]/10, (unsigned int)abs(Irms[0])%10);
            break;
        case MENU_MAINSMETER:
        case MENU_PVMETER:
        case MENU_EVMETER:    
            printf("Enter new type (%s", EMConfig[0].Desc);
            for(i = 1; i <= EM_CUSTOM; i++) {                                   // Don't show Sensorbox and Custom on EVMETER
                if (!(EMConfig[i].ERegister == 0xffff && menu == MENU_EVMETER)) printf("/%s", EMConfig[i].Desc);
            }
            printf("): ");
            break;
        case MENU_MAINSMETERMEASURE:
            printf("Enter what mains electric meter measure (ALL/HOME): ");
            break;
        case MENU_EMCUSTOM_ENDIANESS:
            printf("Enter new Byte order (0: LBF & LWF, 1: LBF & HWF, 2: HBF & LWF, 3: HBF & HWF): ");
            break;
        case MENU_EMCUSTOM_UDIVISOR:
        case MENU_EMCUSTOM_IDIVISOR:
        case MENU_EMCUSTOM_PDIVISOR:
        case MENU_EMCUSTOM_EDIVISOR:
            printf("Enter new exponent of divisor (0-7) or 8 for double: ");
            break;
        case MENU_RFIDREADER:
            printf("RFID reader is set to: %s\r\nEnter new RFID reader mode (%s", getMenuItemOption(menu), StrRFIDReader[0]);
            for(i = 1; i < 5; i++) {
                printf("/%s", StrRFIDReader[i]);
            }
            printf("): ");
            break;
        case MENU_STATE:
            for (n = 0; n < NR_SLAVES; n++) {
                printf("EVSE%u:%c(%u.%1uA)", n, BalancedState[n]+'A', Balanced[n]/10, Balanced[n]%10);
                if (n < NR_SLAVES-1) printf(",");
                else printf("\r\n");
            }
            menu = 0;
            break;
        default:
            printf("Enter new value (%u-%u): ", MenuStr[menu].Min, MenuStr[menu].Max);
            break;
    }
    ISR2FLAG = 0;                                                               // clear flag
    idx2 = 0;                                                                   // reset buffer pointer
}

void delay(unsigned int d) {                                                    // delay for number of mS (blocking))
    unsigned long x;
    x = Timer;                                                                  // read Timer value (increased every ms)
    while (Timer < (x + d)) {
    }
}


// TestIO will be called after a special RS485 command has been received.
void TestIO(void)                                                               // Test connector should be connected to CON1
{
    unsigned char error = 0;

    if (TestState == 1) {
        CCP2CON = 0;                                                            // Disable PWM on LED output
        LATBbits.LATB3 = 0;                                                     // set IO1 to low, State B

        SOLENOID_OFF;
        delay(3000);                                                            // wait 3 seconds for capacitor to charge

        CCP1CON = 0;                                                            // PWM off
        PORTCbits.RC2 = 0;                                                      // Control pilot static -12V
        delay(100);                                                             // wait 100 msec
        if (ReadPilot() == PILOT_DIODE) TestState = STATE_B;                    // should be -12V
        else error = 1;
    } else if (TestState == STATE_B && State == STATE_B)                        // +9V (B state) OK, now test PP input
    {
        ProximityPin();
        if (MaxCapacity != 32) error ^= 2;                                      // error!
        TestState = STATE_C;
        LATBbits.LATB3 = 1;                                                     // set IO1 to high State B->State C 
    } else if (TestState == STATE_C && State == STATE_C)                        //+6V (C state) OK
    {
        Lock = 1;                                                               // enable Lock
        TRISB = 0b10000101;                                                     // RB7(RX2), RB0,2 inputs. all other output
        LATBbits.LATB1 = 1;                                                     // set IO3 to high
        delay(5000);                                                            // wait 5 seconds for capacitor to charge
        if (PORTCbits.RC1 == 1) error ^= 4;                                     // error, Solenoid not activated !

        delay(10);
                                                                                // Contactor + I/O test
        if (PORTBbits.RB2 == 1)                                                 // sample input PIN IO2
        {
            LATBbits.LATB1 = 0;
            delay(10);
            if (PORTBbits.RB2 != 0) error ^= 8;                                 // error
        } else error ^= 8;                                                      // error

        TestState = STATE_CB;
        LATBbits.LATB3 = 0;                                                     // set IO1 to low State C->State B 
    } else if (TestState == STATE_CB && State == STATE_B) {
        TRISB = 0b10000001;                                                     // RB7(RX2), RB0 inputs. all other output
        delay(1000);
        if (PORTCbits.RC1 == 0) error ^= 4;                                     // Solenoid FAIL!!
        else if (!error) {
            TestState = 80;
            Lock = 0;
            GLCD();
        }
    }

    if (error) {
        TRISB = 0b10000001;                                                     // Reset all IO to default values
        LATBbits.LATB1 = 0;
        LATBbits.LATB2 = 0;
        LATBbits.LATB3 = 0;                                                     // set IO1 to low State C->State B 
        Lock = 0;
        Error |= Test_IO;
        TestState = error;
        State = STATE_A;
    }
}

void init(void) {
    OSCCON = 0b01101100;                                                        // setup external oscillator
    OSCCON2 = 0b00000100;                                                       // primary Oscillator On.

    RCON = 0b11011111;                                                          // Set Interrupt priority, enable BOR

    PMD0 = 0b00000000;                                                          // Peripheral Module Enable/Disable
    PMD1 = 0b00000000;                                                          // All enabled
    PMD2 = 0b00000000;

    PORTA = 0;                                                                  // Init PORTA
    ANSELA = 0b00000111;                                                        // RA0, RA1, RA2 are analog inputs (pin 2,3,4)
    TRISA = 0b00000111;                                                         // Set RA0,RA1,RA2 as inputs

    PORTB = 0;
    ANSELB = 0;                                                                 // All digital IO
    TRISB = 0b10000111;                                                         // RB7(RX2), RB0-RB2 inputs. all other output
    WPUB = 0b10000111;                                                          // weak pullup on RB7 and RB0-RB2    
    INTCON2bits.RBPU = 0;                                                       // Enable weak pullups on PORTB

    PORTC = 0b00000100;                                                         // Set Pilot to +12V at startup
    ANSELC = 0;                                                                 // All digital IO
    TRISC = 0b10000010;                                                         // RC1 and RC7 input (RX1), all other output

    SPBRGH1 = 0x01;                                                             // Initialize UART 1 (RS485)
    SPBRG1 = 0xA0;                                                              // Baudrate 9600 

    BAUDCON1 = 0b00001000;                                                      // 16 bit Baudrate register is used
    TXSTA1 = 0b00100100;                                                        // Enable TX, 8 bit, Asynchronous mode
    RCSTA1 = 0b10010000;                                                        // Enable serial port TX and RX, 8 bit. 

    SPBRGH2 = 0;                                                                // Initialize UART 2
    SPBRG2 = 34;                                                                // Baudrate 115k2 (114285)
    BAUDCON2 = 0b00001000;                                                      // 16 bit Baudrate register is used
    TXSTA2 = 0b00100100;                                                        // Enable TX, 8 bit, Asynchronous mode
    RCSTA2 = 0b10010000;                                                        // Enable serial port TX and RX, 8 bit. 

    VREFCON0 = 0b10100000;                                                      // Fixed Voltage reference set to 2.048V

    ADCON0 = 0b00000001;                                                        // ADC On, input AN0 (Pilot)
    ADCON1 = 0;
    ADCON2 = 0b10100101;                                                        // Right justify, Tacq = 8 uS, FOSC/16

    T0CON = 0b10000111;                                                         // Timer 0 @ 16Mhz => 32 uS Timer0, 16 bit counter, 1:256 prescaler

    PR2 = 249;                                                                  // Timer 2 frequency value -> 1Khz @ 16 Mhz
    T2CON = 0b00000110;                                                         // Timer 2 ON, prescaler 1:16
    CCP1CON = 0;                                                                // PWM off (Control Pilot signal)
    CCP2CON = 0;                                                                // PWM off (Led on I/O 1)

    PR4 = 249;                                                                  // Timer 4 frequency value -> 1Khz @ 16 Mhz
    T4CON = 0b00000110;                                                         // Timer 4 ON, prescaler 1:16

    // SPI registers
    SSP1STAT = 0b00000000;                                                      // 0 = Input data sampled at middle of data output time
                                                                                // 0 = Transmit occurs on transition from Idle to active clock state
    SSP1CON1 = 0b00010000;                                                      // Idle state for clock is a high level, SPI Master mode, clock = FOSC/4
    SSP1CON1 = 0b00110000;                                                      // SPI enabled,Idle state for clock is a high level, SPI Master mode, clock = FOSC/4

    PIE1bits.RC1IE = 1;                                                         // enable receive Interrupt for UART1
    PIE3bits.RC2IE = 1;                                                         // enable receive Interrupt for UART2
    PIE5bits.TMR4IE = 1;                                                        // enable Timer4 Interrupt
	
    INTCONbits.GIEH = 1;                                                        // global High Priority interrupts enabled
    INTCONbits.GIEL = 0;                                                        // global Low Priority interrupts disabled

    SOLENOID_OFF;                                                               // R and W outputs held at Capacitor voltage (+12V) 

    CCPR2L = 0;                                                                 // LED DutyCycle 0%
    CCP2CON = 0x0C;                                                             // LED PWM on
    
    unlockMagic = 0x22;
    printf("\r\nSmart EVSE powerup.\r\n");

}


/**
 * Update current data after received current measurement
 */
void UpdateCurrentData(void) {
    unsigned char x;

    // reset Imeasured value (grid power used)
    Imeasured = 0;
    // reset ImeasuredNegative (surplus power generated)
    ImeasuredNegative = 0;
    for (x=0; x<3; x++) {
        // Imeasured holds highest Irms of all channels
        if (Irms[x] > Imeasured) Imeasured = (unsigned int) Irms[x];
        if (Irms[x] < ImeasuredNegative) ImeasuredNegative = (signed int) Irms[x];
    }

     
    // Load Balancing mode: Smart/Master or Disabled
    if (Mode && LoadBl < 2) {
        // Calculate dynamic charge current for connected EVSE's
        CalcBalancedCurrent(0);

        // No current left, or Overload (2x Maxmains)?
        if (NoCurrent > 2 || (Imeasured > (MaxMains * 20))) {
            // STOP charging for all EVSE's
            // Display error message
            Error |= LESS_6A; //NOCURRENT;
            // Set all EVSE's to State A
            ResetBalancedStates();

            // Broadcast Error code over RS485
            ModbusWriteSingleRequest(0x01, 0x02, LESS_6A);
            NoCurrent = 0;
        } else if (LoadBl) BroadcastCurrent();                                  // Master sends current to all connected EVSE's

        if ((State == STATE_B) || (State == STATE_C)) {
            // Set current for Master EVSE in Smart Mode
            SetCurrent(Balanced[0]);
        }
#ifdef LOG_DEBUG_EVSE
        printf("STATE: %c Error: %u StartCurrent: -%i ImeasuredNegative: %.1f A ChargeDelay: %u SolarStopTimer: %u NoCurrent: %u Imeasured: %.1f A IsetBalanced: %.1f A\r\n", State +'A', Error, StartCurrent,
                                                                        (double)ImeasuredNegative/10, ChargeDelay, SolarStopTimer,  NoCurrent,
                                                                        (double)Imeasured/10,
                                                                        (double)IsetBalanced/10);

        printf("L1: %.1f A L2: %.1f A L3: %.1f A Isum: %.1f A\r\n", (Irms[0]/10), Irms[1]/10, Irms[2]/10, (double)Isum/10);
#endif
    } else Imeasured = 0; // In case Sensorbox is connected in Normal mode. Clear measurement.
}


void main(void) {
    unsigned char x, leftbutton, RB2low = 0;
    unsigned char pilot, count = 0, timeout = 5, DataReceived = 0, MainsReceived = 0;
    unsigned char DiodeCheck = 0, ItemID, ActivationMode = 0, ActivationTimer = 0;
    unsigned char SlaveAdr, Broadcast = 1, RB2count = 0, RB2last = 1;
    unsigned int BalancedReceived;
    signed double PV[3]={0, 0, 0};
    signed double EnergyEV = 0;
    unsigned long RB2Timer = 0;                                                 // 1500ms
    unsigned char ResetKwh = 2;                                                 // if set, reset EV kwh meter at state transition B->C
                                                                                // cleared when charging, reset to 1 when disconnected (state A)
    
    init();                                                                     // initialize ports, ADC, UARTs etc

    read_settings();                                                            // from EEprom
    IsetBalanced = MaxMains * 10;                                               // Initially set to MaxMains
    ReadRFIDlist();                                                             // Read all stored RFID's from eeprom

    BACKLIGHT_ON;                                                               // so we can see the version nr at powerup
    GLCD_init();
    GLCD_version();                                                             // Display Version
    
    RCONbits.POR = 1;                                                           // flag that future resets are not POR resets

    x = checkbootloader();                                                      // update the bootloader to v1.06?
    if (x == 2) Error = BL_FLASH;                                               // bootloader update flash write error!

    
    while (1)                                                                   // MAIN loop
    {
                
        if (TestState) TestIO();                                                // TestMode. Test all I/O of Module

        if (ISR2FLAG) RS232cli();                                               // RS232 command line interface

        if (DelayedRS485SendBuf && (ModbusTimer > 6)) {
            
            LATBbits.LATB5 = 1;                                                 // set RS485 transceiver to transmit
            delay(1);
            PIE1bits.TX1IE = 1;                                                 // enable transmit Interrupt for RS485
            DelayedRS485SendBuf = 0;                                            // reset delayed transmission flag
#ifdef LOG_INFO_MODBUS
            printf ("delayed transmission \r\n");
#endif
        }
    
        if (!ISRTXFLAG && TXSTA1bits.TRMT) LATBbits.LATB5 = 0;                  // set RS485 transceiver to receive if the last character has been sent
        
        BlinkLed();                                                             // Handle the blinking of the 12V LED

        TRISC = 0b10100011;                                                     // Set RC5 and RC0 to input. Make sure there are pull-ups on these pins.
        NOP();
        NOP();
        x = (PORTC & 0b00100001);                                               // Read Two Button Inputs on RC5(>) and RC0(select)
        ButtonState = (x >> 3);
        ButtonState = ButtonState | ((x << 1) & 0x02);                          // arranged to lowest bits
        ButtonState = ButtonState | (PORTB & 0x01);                             // Read the state of the last button RB0(<).
        TRISC = 0b10000010;                                                     // RC1 and RC7 input (RX1), all other output

                                                                                // Any button pressed or just released?
        if ((ButtonState != 0x07) || (ButtonState != OldButtonState)) GLCDMenu(ButtonState);  

        if (LCDNav > MENU_ENTER && LCDNav < MENU_EXIT && (ScrollTimer + 5000 < Timer) && (!SubMenu)) GLCDHelp(); // Update/Show Helpmenu
        
        // Left button pressed, Loadbalancing is Master or Disabled, switch is set to "Sma-Sol B" and Mode is Smart or Solar?
        if (!LCDNav && ButtonState == 0x6 && Mode && !leftbutton && (LoadBl < 2) && Switch == 3) { 
                Mode = ~Mode & 0x3;                                             // Change from Solar to Smart mode and vice versa.
                Error &= ~(NOCURRENT | NO_SUN | LESS_6A);                       // Clear All errors
                ChargeDelay = 0;                                                // Clear any Chargedelay 
                SolarTimerEnable = 0;                                           // Also make sure the SolarTimer is disabled.
                LCDTimer = 0;
                                                                                // Broadcast change of Charging mode (Solar/Smart) to slave EVSE's
                if (LoadBl == 1) ModbusWriteSingleRequest(0x01, 0xA8, Mode);
                leftbutton = 5;
        } else if (leftbutton && ButtonState == 0x7) leftbutton--;
        
               
        // External switch changed state?
        if (PORTBbits.RB2 != RB2last || RB2low) {
            // make sure that noise on the input does not switch
            if (RB2count++ > 5 || RB2low) {
                RB2last = PORTBbits.RB2;

                if (RB2last == 0) {
                    // Switch input pulled low
                    switch (Switch) {
                        case 1: // Access Button
                            if (Access_bit) {
                                Access_bit = 0;                                 // Toggle Access bit on/off
                                State = STATE_A;                                // Switch back to state A
                            } else Access_bit = 1;
#ifdef LOG_DEBUG_EVSE
                            printf("access: %d ", Access_bit);
#endif
                            break;
                        case 2: // Access Switch
                            Access_bit = 1;
                            break;
                        case 3: // Smart-Solar Button or hold button for 1,5 second to STOP charging
                            if (RB2low == 0) {
                                RB2low = 1;
                                RB2Timer = Timer;
                            }
                            if (RB2low && Timer > RB2Timer + 1500) {
                                if (State == STATE_C) {                         
                                    State = STATE_A;
                                    if (!TestState) ChargeDelay = 15;           // Keep in State A for 15 seconds, so the Charge cable can be removed.
                                RB2low = 2;    
                                }
                            }
                            break;
                        case 4: // Smart-Solar Switch
                            if (Mode == MODE_SOLAR) {
                                Mode = MODE_SMART;
                                SolarTimerEnable = 0;                           // Also make sure the SolarTimer is disabled.
                            }                                                   // Broadcast change of Charging mode (Solar/Smart) to slave EVSE's
                            if (LoadBl == 1 && Mode) ModbusWriteSingleRequest(0x01, 0xA8, Mode);
                            break;
                        default:
                            if (State == STATE_C) {                             // Menu option Access is set to Disabled
                                State = STATE_A;
                                if (!TestState) ChargeDelay = 15;               // Keep in State A for 15 seconds, so the Charge cable can be removed.
                            }
                            break;
                    }

                    // Reset RCD error when button is pressed
                    // RCD was tripped, but RCD level is back to normal
                    if (RCmon == 1 && (Error & RCD_TRIPPED) && PORTBbits.RB1 == 0) {
                        // Clear RCD error
                        Error &= ~RCD_TRIPPED;
                    }
                    // Also light up the LCD backlight
                    BacklightTimer = BACKLIGHT;                                 // Backlight ON
                    BACKLIGHT_ON;
                    
                } else {
                    // Switch input released
                    switch (Switch) {
                        case 2: // Access Switch
                            Access_bit = 0;
                            State = STATE_A;
                            break;
                        case 3: // Smart-Solar Button
                            if (RB2low != 2) {
                                if (Mode == MODE_SMART) {
                                    Mode = MODE_SOLAR;
                                } else if (Mode == MODE_SOLAR) {
                                    Mode = MODE_SMART;
                                }
                                Error &= ~(NOCURRENT | NO_SUN | LESS_6A);       // Clear All errors
                                ChargeDelay = 0;                                // Clear any Chargedelay 
                                SolarTimerEnable = 0;                           // Also make sure the SolarTimer is disabled.
                                LCDTimer = 0;
                                                                                // Broadcast change of Charging mode (Solar/Smart) to slave EVSE's
                                if (LoadBl == 1 && Mode) ModbusWriteSingleRequest(0x01, 0xA8, Mode);
                            }
                            RB2low = 0;
                            break;    
                        case 4: // Smart-Solar Switch
                            if (Mode == MODE_SMART) Mode = MODE_SOLAR;
                            if (LoadBl == 1 && Mode) ModbusWriteSingleRequest(0x01, 0xA8, Mode);
                            break;
                        default:
                            break;
                    }
                }

                RB2count = 0;
            }
        } else RB2count = 0;


        if (RCmon == 1 && PORTBbits.RB1 == 1)                                   // RCD monitor active, and RCD DC current > 6mA ?
        {
           if (PORTBbits.RB1 == 1) {                                            // check again, to prevent voltage spikes from tripping the RCD detection (2.07)
                State = STATE_A;
                Error = RCD_TRIPPED;
                LCDTimer = 0;                                                   // display the correct error message on the LCD
            }
        }

        // ############### EVSE State A #################
        
        if (State == STATE_A || State == STATE_COMM_B)
        {
            CCP1CON = 0;                                                        // PWM off
            PORTCbits.RC2 = 1;                                                  // Control pilot static +12V
            CONTACTOR_OFF;                                                      // Contactor OFF
            BalancedState[0] = 0;                                               // Mark as inactive

            pilot = ReadPilot();

            if (pilot == PILOT_12V) {                                           // Check if we are disconnected, or forced to State A, but still connected to the EV

                State = STATE_A;                                                // reset state, incase we were stuck in STATE_COMM_B
                Error &= ~NO_SUN;
                Error &= ~LESS_6A;
                ChargeDelay = 0;                                                // Clear ChargeDelay when disconnected.
                NextState = NOSTATE;
                if (!ResetKwh) ResetKwh = 1;                                    // when set, reset EV kWh meter on state B->C change.
            } else if ( (pilot == PILOT_9V || pilot == STATE_A_TO_C) 
                && Error == NO_ERROR && ChargeDelay == 0 && Access_bit
                && State != STATE_COMM_B) {                                     // switch to State B ?
                                                                                // Allow to switch to state C directly if STATE_A_TO_C is set to PILOT_6V (see EVSE.h)
                if (NextState == STATE_B)                                       // Access is permitted when Access_bit set
                {
                    if (count++ > 25)                                           // repeat 25 times (changed in v2.05)
                    {
                        DiodeCheck = 0;
                        ProximityPin();                                         // Sample Proximity Pin
#ifdef LOG_DEBUG_EVSE
                        printf("Cable limit: %uA  Max: %uA \r\n", MaxCapacity, MaxCurrent);
#endif
                        if (MaxCurrent > MaxCapacity) ChargeCurrent = MaxCapacity * 10; // Do not modify Max Cable Capacity or MaxCurrent (fix 2.05)
                        else ChargeCurrent = MaxCurrent * 10;                   // Instead use new variable ChargeCurrent

                        if (LoadBl > 1)                                         // Load Balancing : Slave 
                        {                                                       // Send command to Master, followed by Max Charge Current
                            State = STATE_COMM_B;                               // Slave wants to switch to State B
#ifdef LOG_INFO_EVSE
                            printf("STATE COMM B\r\n");
#endif
                        } else {                                                // Load Balancing: Master or Disabled
                            BalancedMax[0] = MaxCapacity * 10;
                            Balanced[0] = ChargeCurrent;                        // Set pilot duty cycle to ChargeCurrent (v2.15)
                            BalancedState[0] = 1;                               // Mark as active
                            State = STATE_B;                                    // switch to State B
                            ActivationMode = 30;                                // Activation mode is triggered if state C is not entered in 30 seconds.
                            BacklightTimer = BACKLIGHT;                         // Backlight ON
#ifdef LOG_INFO_EVSE
                            printf("STATE A->B\r\n");
#endif
                        }
                   }
                } else {
                    NextState = STATE_B;
                    count = 0;
                }
            } else NextState = NOSTATE;
        }

        if (State == STATE_COMM_B_OK) {
            State = STATE_B;
            ActivationMode = 30;                                                // Activation mode is triggered if state C is not entered in 30 seconds.
            BacklightTimer = BACKLIGHT;                                         // Backlight ON
#ifdef LOG_DEBUG_EVSE
            printf("State A->B OK\r\n");
#endif
        }

        // ############### EVSE State B #################

        if (State == STATE_B || State == STATE_COMM_C)
        {                                                                       // measure voltage at ~5% and ~90% of PWM cycle
            if ((TMR2 > 7) && (TMR2 < 24))                                      // PWM cycle 3% - 9% (should be high)
            {
                pilot = ReadPilot();
                if (pilot == PILOT_12V)                                         // Disconnected?
                {
                    if (NextState == STATE_A) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            State = STATE_A;                                    // switch to STATE_A
#ifdef LOG_INFO_EVSE
                            printf("STATE B->A\r\n");
#endif
                        }
                    } else {
                        NextState = STATE_A;
                        count = 0;
                    }
                } else if (pilot == PILOT_6V) {
                    if ((NextState == STATE_C) && (DiodeCheck == 1)) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            if ((Error == NO_ERROR) && (ChargeDelay == 0)) {
                                if (LoadBl > 1)                                 // Load Balancing : Slave 
                                {                                               // Send command to Master, followed by Charge Current
                                    State = STATE_COMM_C;
                                } else {                                        // Load Balancing: Master or Disabled
                                    BalancedMax[0] = ChargeCurrent;
                                    if (IsCurrentAvailable()) {
                                        BalancedState[0] = 2;                   // Mark as Charging
                                        Balanced[0] = 0;                        // For correct baseload calculation set current to zero
                                        CalcBalancedCurrent(1);                 // Calculate charge current for all connected EVSE's

                                        CONTACTOR_ON;                           // Contactor ON
                                        ActivationMode = 255;                   // Disable ActivationMode                                
                                        DiodeCheck = 0;
                                        State = STATE_C;                        // switch to STATE_C
                                        LCDTimer = 0;
                                        Timer = 0;                              // reset msTimer and ChargeTimer
                                        if (EVMeter && ResetKwh) {
                                            EnergyMeterStart = EnergyEV;        // store kwh measurement at start of charging.
                                            ResetKwh = 0;                       // clear flag, will be set when disconnected from EVSE (State A)
                                        }
                                        if (!LCDNav) GLCD();                    // Don't update the LCD if we are navigating the menu
                                                                                // immediately update LCD (20ms)
#ifdef LOG_INFO_EVSE
                                        printf("STATE B->C\r\n");
#endif
                                    }
                                    else Error |= LESS_6A;//NOCURRENT;
                                }
                            }
                        }
                    } else {
                        NextState = STATE_C;
                        count = 0;
                    }
                } else {                                                        // PILOT_9V
                                       
                    if (ActivationMode == 0) {
                        State = STATE_ACTSTART;
                        ActivationTimer = 3;
                        CCP1CON = 0;                                            // PWM off
                        PORTCbits.RC2 = 0;                                      // Control pilot static -12V
#ifdef LOG_DEBUG_EVSE
                        printf("Activation Mode Triggered\r\n");
#endif
                    }
                    NextState = NOSTATE;                                        // no State to switch to
                }
            }
            if (TMR2 > 230)                                                     // PWM > 92%
            {
                while (TMR2 < 242);                                             // wait till TMR2 is in range, otherwise we'll miss it (blocking)
                if ((TMR2 > 241) && (TMR2 < 249))                               // PWM cycle >= 96% (should be low)
                {
                    pilot = ReadPilot();
                    if (pilot == PILOT_DIODE) DiodeCheck = 1;                   // Diode found, OK
                    else DiodeCheck = 0;
                }
            }
        }
        
        if (State == STATE_ACTSTART && ActivationTimer == 0) {
            State = STATE_B;                                                    // Switch back to State B
            PORTCbits.RC2 = 1;                                                  // Control pilot static +12V
            ActivationMode = 255;                                               // Disable ActivationMode
        }

        if (State == STATE_COMM_C_OK) {
            CONTACTOR_ON;                                                       // Contactor ON
            DiodeCheck = 0;
            State = STATE_C;                                                    // switch to STATE_C
            ActivationMode = 255;                                               // Disable ActivationMode  
            NextState = NOSTATE;                                                // no State to switch to
            LCDTimer = 0;
            Timer = 0;                                                          // reset msTimer and ChargeTimer
                                                                                // Don't update the LCD if we are navigating the menu
            if (!LCDNav) GLCD();                                                // immediately update LCD
#ifdef LOG_DEBUG_EVSE
            printf("State C OK \r\n");
#endif
        }

        // ############### EVSE State C #################

        if (State == STATE_C)                                
        {                                                                       // measure voltage at ~5% of PWM cycle
            if ((TMR2 > 7) && (TMR2 < 24))                                      // cycle 3% - 9% (should be high)
            {
                pilot = ReadPilot();
                if ((pilot == PILOT_12V) || (pilot == PILOT_NOK))               // Disconnected or Error?
                {
                    if (NextState == STATE_A) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            CONTACTOR_OFF;                                      // Contactor OFF
                            State = STATE_A;                                    // switch back to STATE_A
#ifdef LOG_INFO_EVSE
                            printf("STATE C->A\r\n");
#endif
                            GLCD_init();                                        // Re-init LCD
                            if (LoadBl < 2) BalancedState[0] = 0;               // Load Balancing : Master or Disabled
                                                                                // Mark EVSE as disconnected
                        }
                    } else {
                        NextState = STATE_A;
                        count = 0;
                    }
                } else if (pilot == PILOT_9V) {
                    if (NextState == STATE_B) {
                        if (count++ > 25)                                       // repeat 25 times
                        {
                            CONTACTOR_OFF;                                      // Contactor OFF
                            State = STATE_B;                                    // switch back to STATE_B
#ifdef LOG_INFO_EVSE
                            printf("STATE C->B\r\n");
#endif
                            GLCD_init();                                        // Re-init LCD (200ms delay)
                            DiodeCheck = 0;
                       
                            if (LoadBl < 2) BalancedState[0] = 1;               // Load Balancing : Master or Disabled
                                                                                // Mark EVSE as inactive (still State B)
                        }
                    } else {
                        NextState = STATE_B;
                        count = 0;
                    }
                } else {                                                        // PILOT_6V
                    NextState = NOSTATE;                                        // no State to switch to
                }
            }
        } // end of State C code

        
        if (RCSTA1bits.OERR)                                                    // Uart1 Overrun Error?
        {
            RCSTA1bits.CREN = 0;
            RCSTA1bits.CREN = 1;                                                // Restart Uart
        }
        if (RCSTA2bits.OERR)                                                    // Uart2 Overrun Error?
        {
            RCSTA2bits.CREN = 0;
            RCSTA2bits.CREN = 1;                                                // Restart Uart
        }

        // The following code will be executed every second, except when there is a state change C->B happening
        x = TMR0L;
        if (TMR0H >= 0x3d &&  (NextState == NOSTATE || State != STATE_C) )      // 1 second timer
        {
            TMR0H = 0;
            TMR0L = 0;
            
            Temp();                                                             // once a second, measure temperature

//            printf("locktimer: %lu timer: %lu\r\n lockstatus: %u", locktimer, Timer, lockstatus);

            // When RFID is enabled, a OneWire RFID reader is expected on the SW input
            if (RFIDReader) {                                                   // RFID Reader set to Enabled, Learn or Delete
                if (OneWireReadCardId() ) {                                     // Read card ID
                    switch (RFIDReader) {
                        case 1:                                                 // Enabled
                            x = MatchRFID();
                            if (x && !RFIDstatus) {
                                //printf("RFID card found!\r\n");
                                if (Access_bit) {
                                    Access_bit = 0;                             // Toggle Access bit on/off
                                    State = STATE_A;                            // Switch back to state A
                                } else Access_bit = 1;

                                RFIDstatus = 1;
                            }  else if (!x) RFIDstatus = 7;                     // invalid card
                            BacklightTimer = BACKLIGHT;
                            break;
                        case 2:                                                 // Learn Card
                            x = StoreRFID();
                            if (x == 1) {
                                printf("RFID card Stored!\r\n");
                                RFIDstatus = 2;
                            } else if (x == 2 && !RFIDstatus) {
                                printf("RFID card was already stored!\r\n");
                                RFIDstatus = 4;
                            } else if (!RFIDstatus) {
                                printf("RFID storage full! Delete card first\r\n");
                                RFIDstatus = 6;
                            }
                            break;
                        case 3:                                                 // Delete Card
                            x = DeleteRFID();
                            if (x) {
                                printf("RFID card Deleted!\r\n");
                                RFIDstatus = 3;
                            } else if (!RFIDstatus) {
                                printf("RFID card not in list!\r\n");
                                RFIDstatus = 5;
                            }
                            break;
                        default:
                            break;
                    }
                } else RFIDstatus = 0;
            }

            if (State == STATE_B && ActivationMode < 255) ActivationMode--;     // decrease 30 sec counter when in State B
            if (State == STATE_ACTSTART && ActivationTimer) ActivationTimer--;
            
            // When Solar Charging, once the current drops to MINcurrent a timer is started.
            // Charging is stopped when the timer reaches the time set in 'StopTime' (in minutes)
            // Except when Stoptime =0, then charging will continue.

            if (SolarTimerEnable)
            {
                if ( SolarStopTimer++ >= (StopTime*60))                         // Convert minutes into seconds
                {
                     State = STATE_A;                                           // switch back to state A
                     SolarTimerEnable=0;                                        // Disable Solar Timer
                     SolarStopTimer=0;
                     Error |= NO_SUN; 
                                          
                     ResetBalancedStates();                                     // reset all states
                     ModbusWriteSingleRequest(0x01, 0x02, NO_SUN);
                     
                }   
            } else SolarStopTimer=0;   
            
            if (ChargeDelay) ChargeDelay--;                                     // Decrease Charge Delay counter

            if ((TempEVSE < 55) && (Error & TEMP_HIGH)) // Temperature below limit?
            {
                Error &= ~TEMP_HIGH; // clear Error
            }

            if ( (Error & (LESS_6A|NO_SUN) ) && (LoadBl < 2) && (IsCurrentAvailable())) {
                Error &= ~LESS_6A;                                              // Clear Errors if there is enough current available, and Load Balancing is disabled or we are Master
                Error &= ~NO_SUN;
#ifdef LOG_DEBUG_EVSE
                printf("No sun/current Errors Cleared.\r\n");
#endif
                ModbusWriteSingleRequest(0x01, 0x02, Error);                    // Broadcast
            }

            if ((timeout == 0) && !(Error & CT_NOCOMM))                         // timeout if CT current measurement takes > 10 secs
            {
                Error |= CT_NOCOMM;
                State = STATE_A;                                                // switch back to state A
#ifdef LOG_WARN_EVSE
                printf("Error, communication error!\r\n");
#endif
                ResetBalancedStates();
            } else if (timeout) timeout--;

            if (TempEVSE >= 65 && !(Error & TEMP_HIGH))                         // Temperature too High?
            {
                Error |= TEMP_HIGH;
                State = STATE_A;                                                // ERROR, switch back to STATE_A
#ifdef LOG_WARN_EVSE
                printf("Error, temperature %i C !\r\n", TempEVSE);
#endif
                ResetBalancedStates();
            }

            if (Error & (NO_SUN | LESS_6A)) {
                //Error &= ~NOCURRENT;                                            // Clear NO_CURRENT from error register
#ifdef LOG_INFO_EVSE
                if (Mode == MODE_SOLAR) {
                    if (ChargeDelay == 0) printf("Waiting for Solar power..\r\n");
            //        Error |= NO_SUN;                                            // Set new Error
                } else {
                    if (ChargeDelay == 0) printf("Not enough current available!\r\n");
            //        Error |= LESS_6A;
                }
#endif
                State = STATE_A;
                ChargeDelay = CHARGEDELAY;                                      // Set Chargedelay 
            }

            // once a second, update LCD
            GLCD();

            // Every two seconds request measurement data from sensorbox/kwh meters.
            // and send broadcast to Slave controllers.
            if (LoadBl < 2 && !Broadcast--) {                                   // Load Balancing mode: Master or Disabled
                if (Mode) {                                                     // Smart or Solar mode
                    ModbusRequest = 1;                                          // Start with state 1
                } else {                                                        // Normal mode
                    Imeasured = 0;                                              // No measurements, so we set it to zero
                    ModbusRequest = 5;                                          // Start with state 5 (poll Slaves)
                    timeout = 10;                                               // reset timeout counter (not checked for Master)
                }
                Broadcast = 1;                                                  // repeat every two seconds
            }

        } // end 1 second timer

        
        // Every 2 seconds, request measurements from modbus meters 
        if (ModbusRequest && ModbusTimer >= 100 ) {
            switch (ModbusRequest++) {                                          // State
                case 1:
                    requestCurrentMeasurement(MainsMeter, MainsMeterAddress);   // Sensorbox or kWh meter that measures -all- currents
                    break;
                case 2:                                                         // PV kwh meter
                    if (PVMeter) {
                        requestCurrentMeasurement(PVMeter, PVMeterAddress);
                        break;
                    }
                    ModbusRequest++;
                case 3:                                                         // EV kWh meter, Energy measurement (total charged kWh)
                    if (EVMeter) {
                        requestEnergyMeasurement(EVMeter, EVMeterAddress);
                        break;
                    }
                    ModbusRequest++;
                case 4:                                                         // EV kWh meter, Power measurement (momentary power in Watt)
                    if (EVMeter) {
                        requestPowerMeasurement(EVMeter, EVMeterAddress);
                        break;
                    }
                    ModbusRequest++;
                case 5:                                                         // Slave 1
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    if (LoadBl == 1) {
                        requestSlaveStatus(ModbusRequest - 5);                  // Master, Request Slave 1-8 status
                        break;
                    }
                    ModbusRequest = 11;
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                    if (LoadBl == 1) {
                        processAllSlaveStates(ModbusRequest - 12);
                        break;
                    }
                default:
                    if (Mode) {                                                 // Smart/Solar mode 
                        if ((Error & CT_NOCOMM) == 0) UpdateCurrentData();      // No communication error with Sensorbox /Kwh meter?
                                                                                // then update the data and send broadcast to all connected EVSE's
                    } else {                                                    // Normal Mode
                        CalcBalancedCurrent(0);                                 // Calculate charge current for connected EVSE's
                        if (LoadBl == 1) BroadcastCurrent();                    // Send to all EVSE's (only in Master mode)
                        if ((State == STATE_B) || (State == STATE_C)) SetCurrent(Balanced[0]); // set PWM output for Master
                    }
                    ModbusRequest = 0;
                    break;
            }
        }


        /*  RS485 serial data is received by the ISR routine, and processed here..
            Reads serial packet with Raw Current values, measured from 1-3 CT's, over a RS485 serial line
        */
        
        // Receive data from modbus
        // last reception more then 3ms ago? // complete packet detected?

        if (idx && (ModbusTimer > 3) ) {                                        // if (idx && Timer > (ModbusTimer + 3)) {
            memcpy(U1packet, U1buffer, idx);                                    // store received data packet
            ISRFLAG = idx;                                                      // set flag to length of data packet
            idx = 0;                                                            // ready to receive a new packet    

            ModbusDecode(U1packet, ISRFLAG);
#ifdef LOG_DEBUG_MODBUS
                printf("Received packet (%i bytes) ",ISRFLAG);
                for (x=0; x<ISRFLAG; x++) printf("%02x ",U1packet[x]);
                printf("\n\r");
#endif

            // Data received is a response to an earlier request from the master.
            if (Modbus.Type == MODBUS_RESPONSE) {
                //printf("\nModbus Response Address %i / Function %02x / Register %02x",Modbus.Address,Modbus.Function,Modbus.Register);
                switch (Modbus.Function) {
                    case 0x03: // (Read holding register)
                    case 0x04: // (Read input register)
                        if (Modbus.Address == MainsMeterAddress && Modbus.Register == EMConfig[MainsMeter].IRegister) {
                            // packet from Mains electric meter
                            x = receiveCurrentMeasurement(Modbus.Data, MainsMeter, Irms);
                            if (x && LoadBl <2) timeout = 10;                   // only reset timeout when data is ok, and Master/Disabled
                            if (!PVMeter) {
                                Isum = 0;                                       // Calculate Isum (for slaves and master)
                                for (x = 0; x < 3; x++) {
                                    Isum = Isum + (int) Irms[x];
                                }
                            }

                        } else if (PVMeter && Modbus.Address == PVMeterAddress && Modbus.Register == EMConfig[PVMeter].IRegister) {
                            // packet from PV electric meter
                            receiveCurrentMeasurement(Modbus.Data, PVMeter, PV);
                            Isum = 0;
                            for (x = 0; x < 3; x++) {                           // Calculate Isum (for slaves and master)
                                Irms[x] = Irms[x] - PV[x];
                                Isum = Isum + (int) Irms[x];
                            }

                        } else if (EVMeter && Modbus.Address == EVMeterAddress && Modbus.Register == EMConfig[EVMeter].ERegister) {
                            // packet from EV kWh meter
                            EnergyEV = receiveEnergyMeasurement(Modbus.Data, EVMeter);
                            if (ResetKwh == 2) EnergyMeterStart = EnergyEV;      // At powerup, set EnergyEV to kwh meter value
                            if (EVMeter) EnergyCharged = EnergyEV - EnergyMeterStart; // Calculate Energy
                        } else if (EVMeter && Modbus.Address == EVMeterAddress && Modbus.Register == EMConfig[EVMeter].PRegister) {
                            // packet from EV kWh meter
                            PowerMeasured = receivePowerMeasurement(Modbus.Data, EVMeter);
//                            printf("Power measured %u W \r\n",PowerMeasured);

                        }  else if (Modbus.Address > 1 && Modbus.Address < 4 && Modbus.Register == 0xA0) {
                            // Status packet from Slave EVSE received
                            receiveSlaveStatus(Modbus.Data, Modbus.Address - 1);
                        }
                        break;
                    default:
                        break;
                }
            // Data received is a request from the master to a device on the bus.
            } else if (Modbus.Type == MODBUS_REQUEST) {
                //printf("\nModbus Request Address %i / Function %02x / Register %02x",Modbus.Address,Modbus.Function,Modbus.Register);
                                                                                // No timeout reset here, as it is a request, no response!!!! 
                switch (Modbus.Function) {
                    case 0x03: // (Read holding register)
                    case 0x04: // (Read input register)
                        // Addressed to this device
                        if (Modbus.Address == LoadBl) {
                            ItemID = mapModbusRegister2ItemID();
                            if (ItemID < 255) ReadItemValueResponse(ItemID);
                        }
                        break;
                    case 0x06: // (Write single register)
                        // Special TestIO message?
                        if (Modbus.Address == 0x0a && Modbus.Register == 0xa8 && Modbus.Value == 0x494f && !TestState) {
                            TestState = 1;
                            break;
                        }    
                        // Broadcast or addressed to this device
                        if (Modbus.Address == 0x01 || Modbus.Address == LoadBl) {
                            
                            ItemID = mapModbusRegister2ItemID();
                            if (ItemID < 255) WriteItemValueResponse(ItemID);
                            DataReceived = 1;
                        }
                        break;
                    case 0x10: // (Write multiple register))
                        // Broadcast or addressed to this device
                        if (Modbus.Address == 0x01 || Modbus.Address == LoadBl) {
                            // 0x01: Balance currents
                            if (Modbus.Register == 0x01 && LoadBl > 1) {        // Message for Slave(s)
                                BalancedReceived = (Modbus.Data[(LoadBl - 1) * 2] <<8) | Modbus.Data[(LoadBl - 1) * 2 + 1];
                                //printf("\n  Address %02x Register %02x BalancedReceived %i ", Modbus.Address, Modbus.Register, BalancedReceived);
                                DataReceived = 1;
                            }
                            
                            ItemID = mapModbusRegister2ItemID();
                            if (ItemID < 255) WriteMultipleItemValueResponse(ItemID);
                        }
                        break;
                    default:
                        break;
                }
            } else if (Modbus.Type == MODBUS_EXCEPTION) {
#ifdef LOG_DEBUG_MODBUS
                printf("Modbus Address %02x exception %u received\r\n", Modbus.Address, Modbus.Exception);
#endif
#ifdef LOG_WARN_MODBUS
            } else {
                printf("\r\nCRC invalid\r\n");
#endif
            }
        } // (ISRFLAG > 1) 	 complete packet detected?


        // Process received data on Slaves
        if (DataReceived) {                                                     // Master -> Slave
            if (Modbus.Address == 0x01 && LoadBl > 1)                           // Broadcast message from Master->Slaves, Set Charge current
            {
                switch (Modbus.Register) {
                    case 0x01:
                        Balanced[0] = BalancedReceived;
                        if (Balanced[0] == 0 && State == STATE_C) State = STATE_A;                  // Stop charging if charge current is zero
                        else if ((State == STATE_B) || (State == STATE_C)) SetCurrent(Balanced[0]); // Set charge current, and PWM output
#ifdef LOG_DEBUG_MODBUS
                        printf("Broadcast received, Slave %u.%1u A \r\n", Balanced[0]/10, Balanced[0]%10);
#endif
                        timeout = 10;                                           // reset 10 second timeout
                        break;
                    case 0x02:                                                  // Broadcast Error message from Master->Slaves
                        Error = Modbus.Value;                                   // Error stored in variable Current
                        if (Error) {                                            // Is there an actual Error? Maybe the error got cleared?
                            State = STATE_A;                                    // We received an error; switch to State A, and wait 60 seconds
                            ChargeDelay = CHARGEDELAY;
#ifdef LOG_DEBUG_MODBUS
                            printf("Broadcast Error message received!\r\n");
                        } else {
                            printf("Broadcast Errors Cleared received!\r\n");
#endif
                        }
                        break;
                    default:
                        break;
                }
            }
        }
        
        if ((Error & CT_NOCOMM) && timeout == 10) Error &= ~CT_NOCOMM;          // Clear communication error, if present

        DataReceived = 0;
    } // end of while(1) loop
}
