/*
; Project:       Smart EVSE
; Date:          8 June 2020
;
; Changes:
;
; 2.00  New v2 hardware (18F26K22), Graphic 128x64 LCD , MPLAB X IDE, and the XC8 compiler
; 2.01  Fix: Charge current in normal mode was limited to MaxMains setting.
;       Fix: Load Balancing-Master can now adjust MaxMains and MinCharge settings from the LCD menu.
;       Fix: SmartMode can now charge at a higher current then set by MaxMains, using surplus power generated by Solar.
;            i.e. -15A PV power +45A MaxMains results in charging current of 60A.
;       Bugfixes to load balancing code (only affects v2)
; 2.02  Fix: Node Max charge current was set to Cable limit instead of MaxCurrent
;       Fix: Charging sometimes stopped because State C control pilot ranges were too strict.
; 2.03  Changed lowest MaxMains setting to 10A, lowest CT calibration value to 6A.
; 2.04  Fix: In Normal mode, the MAX charge current was limited by the MAINS setting (which is not shown in this mode).
;       Fix: default LoadBl EEPROM setting was not set correctly.
;       MAX charge current can be adjusted while charging in Normal mode.
;       ACCESS menu option added. Allows to Start/Stop charging by connecting a button/switch to IO2.
;       if the ACCESS option is set to disabled, the button can be used to stop charging.
;       On IO1 a LED can be connected, which acts as a charging/error indicator.
; 2.05  Fix: Using a 16A charge cable would limit MaxCurrent to 16A, until a reset of the module or adjusting the MAX value using the menu.
;       Fix: Increased number of times a STATE change needs to be valid, before the actual STATE change takes place.
;            this to fix erratic behavior on a Renault Zoe.
;       LCD Backlight will now be activated on any key press, and will turn off after 60 seconds of inactivity (except when charging).
;       CT's default values can be restored by holding both < and > keys while in the CAL menu.
;       RCMON menu option added. This adds support for DC Residual Current sensors, as required by IEC62955.
;            IO3 is used as the fault input (active high).
;            The error state can be reset by pressing any module button, or the pushbutton on IO2
; 2.06  Added check in EEprom write routine for disabled interrupts.
; 2.07  Fix: The RCD was tripped by inductive loads/ voltage spikes on the mains line. Checking twice for a tripped RCD fixed this.
;       Bootloader can now only be entered when also the right button on top of the module is pressed.
;       Added Compile time option to switch directly from STATE_A to STATE_C.
;
; 2.10  Modbus version.
;       Please note that the old sensorbox will -not- work with this version.
;       Use Sensorbox 1.5 or Sensorbox 2, or use a Phoenix, Finder or Eastrom modbus kWh meter for measuring the current on your mains wiring.
;       Thanks to Robert Heel for his work on this code.
;       Added MODE Solar option. Maximize charging on Solar power.
;       Added START menu option. Start Charging when surplus solar power is above 4A (configurable 1-16 A). EV will always charge at minimal MIN Current per phase
;       Added STOP menu option. Stop Charging after XX minutes at MIN charge current (configurable 0-60 min) (0= keep charging)
;       EEprom initialization done at first power-up.
;       Bugfixes in Master/Node code.
;       Automatic CT Calibration reset when upgrading from 2.0x to this version.
;       LCD Backlight will now be lit for 60 seconds, when pressing the external button.
;       CABLE option removed, just set MAX to the cable capacity.
;       CIRCUIT menu option added. Used when multiple EVSE's share the same circuit. Set this to the max current of the EVSE circuit.
;       Switching between Solar/Smart mode with left button on the module.
; 2.11  Fixed rare corrupted flash issue, seems to happen sometimes at power on.
;       The microcontroller would start at a random address, if this happened to be the flash erase code, the flash will become corrupted.
;       Now using two variables that hold the unlock sequence. So that power up glitches will not trigger a flash erase/write.
;       Bootloader also gets updated to fix this issue (now v1.06)
;       MAX setting now starts at 6A
; 2.12  Fixed garbled LCD. When charging is stopped the the LCD is re-initialized after a 200ms delay.
; 2.13  Various Master/Node communication bug fixes.
; 2.14  Fixed Broadcast error clear message handling on node.
;       Added check in Solar mode for overloading the MAINS.
;       Removed START and STOP menu options from the node, as it is determined by the master.
; 2.15  Added check to see if Sensorbox data contains new measurement data.
;       Added IMPORT menu option, which allows for power import from the grid when solar charging.
;       Added compile time option to compensate for 230V-400V transformers.
;       Added Activation mode, which is triggered if state C is not entered within 30 seconds.
;       If an external push button is used as Smart/Solar mode switch, holding this button for 1.5 seconds will now stop charging.
; 2.16  Fixed Smart/Solar mode switch, it would force Solar or Smart mode, even in Normal mode.
;       Added GRID menu option. Configures the Sensorbox2 for use with 4Wire (L1,L2,L3 and Neutral) or 3Wire (L1,L2,L3 no Neutral)
;       Speeded up State C->B detection, by removing (blocking) delays. The Renault ZOE will show an error if this takes > 100ms.
; 2.17  Fixed state switch bug while in solar mode.
;       Hides CAL menu option when CT's are not used.
; 2.20  Fixed Temp Error, >65C stopped charging, but did not show any error message on the LCD.
;       Internal temperature is now displayed on the LCD while in the setup menu.
;       Added setup menu navigation indicator, which shows how many menu options are available, and which one is currently selected.
;       Fixed MAX current adjustment above initial setting, while charging and a FIXED cable is used.
;       Added EVMETER and EVADR option to the menu. Use a modbus kWh meter to measure the charged energy.
;       Added charged energy to the LCD (Smart/Solar mode)
;       Uses condensed characters on the LCD, so the 'i' will not use the same space as the 'w'
;       Increased MaxMains to 200A, and Circuit to 160A.
;       Allows the use of 200A:50ma CT's with the Sensorbox. Will adjust (x2) measurement when MAINS setting is >100A
;       Increased the nr of nodes to 7.
;       Added modbus node polling. The master will poll all nodes for state changes.
;       Added RFID reader option. Learn up to 20 RFID cards.
;           Enabling the RFID reader will lock/unlock the SmartEVSE with a valid RFID card.
;           Status messages when learning/deleting cards are displayed on the LCD.
;           Erase all cards by selecting EraseAll from the menu, and then Exit Menu.
;
;
;   Build with MPLAB X v5.25 and XC8 compiler version 2.10
;
;   If you get "(902) no chip name specified" error messages, make sure the xc8-cc compiler is used.
;
;   set in XC8 global options the C standard to "C90"
;   set XC8 linker memory model settings to: double 32 bit, float 32 bit
;   and reserve space for the bootloader by setting ROM range to 0-FCFB
;
;
;   (C) 2013-2020  Michael Stegen / Stegen Electronics
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in
; all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
; THE SOFTWARE.
*/
#include <xc.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "EVSE.h"
#include "bootloader.h"
#include "modbus.h"
#include "utils.h"

void SetCurrent(unsigned int);
unsigned int CalcCurrent();


// Configuration settings
#pragma	config FCMEN = OFF,	IESO = OFF, PRICLKEN = ON
#pragma config PLLCFG = OFF, FOSC = HSMP                                        // High Speed Medium power (4-16Mhz), PLL Off
#pragma	config BORV = 285, BOREN = ON, PWRTEN = ON
#pragma	config WDTPS = 2048, WDTEN = OFF                                        // WDT timeout
#pragma config CCP2MX = PORTB3, PBADEN = OFF, CCP3MX = PORTC6                   // PortB digital IO
#pragma config HFOFST = OFF, T3CMX = PORTB5, P2BMX = PORTC0, MCLRE = INTMCLR

#pragma config XINST = OFF, DEBUG = OFF, LVP = OFF, STVREN = ON
#pragma	config CP0 = OFF, CP1 = OFF, CP2 = OFF, CP3 = OFF, CPD = OFF, CPB = OFF
#pragma	config WRT0 = OFF, WRT1 = OFF, WRT2 = OFF, WRT3 = OFF
#pragma	config WRTC = OFF, WRTB = OFF, WRTD = OFF
#pragma	config EBTR0 = OFF, EBTR1 = OFF, EBTR2 = OFF, EBTR3 = OFF
#pragma	config EBTRB = OFF


// Text
const far char StrFixed[]   = "Fixed";
const far char StrSocket[]  = "Socket";
const far char StrSmart[]   = "Smart";
const far char StrNormal[]  = "Normal";
const far char StrSolar[]   = "Solar";
const far char StrSolenoid[] = "Solenoid";
const far char StrMotor[]   = "Motor";
const far char StrDisabled[] = "Disabled";
const far char StrLoadBl[9][9]  = {"Disabled", "Master", "Node 1", "Node 2", "Node 3", "Node 4", "Node 5", "Node 6", "Node 7"};
const far char StrSwitch[5][10] = {"Disabled", "Access B", "Access S", "Sma-Sol B", "Sma-Sol S"};
const far char StrGrid[2][10] = {"4Wire", "3Wire"};
const far char StrEnabled[] = "Enabled";
const far char StrExitMenu[] = "MENU";
const far char StrMainsAll[] = "All"; // Everything
const far char StrMainsHomeEVSE[] = "Home+EVSE";
const far char StrRFIDReader[5][10] = {"Disabled", "Enabled", "Learn", "Delete", "DeleteAll"};
const far char StrStateName[9][10] = {"A", "B", "C", "D", "COMM_B", "COMM_B_OK", "COMM_C", "COMM_C_OK", "Activate"};

// Global data
char U1buffer[50],U1packet[50];                                                 // Uart1 Receive buffer /RS485
char U1TXbuffer[50];                                                            // Uart1 Transmit buffer /RS485
char U2buffer[50];                                                              // Uart2 buffer /Serial CLI
char GLCDbuf[512];                                                              // GLCD buffer (half of the display)
char RFIDlist[120];                                                             // holds up to 20 RFIDs


// The following data will be updated by eeprom data at powerup:
unsigned int MaxMains = MAX_MAINS;                                              // Max Mains Amps (hard limit, limited by the MAINS connection) (A)
unsigned int MaxCurrent = MAX_CURRENT;                                          // Max Charge current (A)
unsigned int MinCurrent = MIN_CURRENT;                                          // Minimal current the EV is happy with (A)
unsigned long ICal = ICAL;                                                      // CT calibration value
char Mode = MODE;                                                               // EVSE mode (0:Normal / 1:Smart)
char Lock = LOCK;                                                               // Cable lock (0:Disable / 1:Solenoid / 2:Motor)
unsigned int MaxCircuit = MAX_CIRCUIT;                                          // Max current of the EVSE circuit (A)
char Config = CONFIG;                                                           // Configuration (0:Socket / 1:Fixed Cable)
char LoadBl = LOADBL;                                                           // Load Balance Setting (0:Disable / 1:Master / 2-4:Node)
char Switch = SWITCH;                                                           // External Switch on I/O 2 (0:Disable / 1:Access / 2:Smart-Solar)
char RCmon = RC_MON;                                                            // Residual Current Monitor on I/O 3 (0:Disable / 1:Enable)
unsigned int StartCurrent = START_CURRENT;
unsigned int StopTime = STOP_TIME;
unsigned int ImportCurrent = IMPORT_CURRENT;
unsigned char MainsMeter = MAINS_METER;                                         // Type of Mains electric meter (0: Disabled / Constants EM_*)
unsigned char MainsMeterAddress = MAINS_METER_ADDRESS;
unsigned char MainsMeterMeasure = MAINS_METER_MEASURE;                          // What does Mains electric meter measure (0: Mains (Home+EVSE+PV) / 1: Home+EVSE / 2: Home)
unsigned char PVMeter = PV_METER;                                               // Type of PV electric meter (0: Disabled / Constants EM_*)
unsigned char PVMeterAddress = PV_METER_ADDRESS;
char Grid = GRID;                                                               // Type of Grid connected to Sensorbox (0:4Wire / 1:3Wire )
unsigned char EVMeter = EV_METER;                                               // Type of EV electric meter (0: Disabled / Constants EM_*)
unsigned char EVMeterAddress = EV_METER_ADDRESS;
unsigned char RFIDReader = RFID_READER;                                         // RFID Reader Disabled/Enabled (Learn / Delete, Delete All)

signed int Irms[3]={0, 0, 0};                                                   // Momentary current per Phase (23 = 2.3A) (resolution 100mA)
                                                                                // Max 3 phases supported
unsigned char State = STATE_A;
unsigned char Error = NO_ERROR;
unsigned char NextState;

unsigned int MaxCapacity;                                                       // Cable limit (A) (limited by the wire in the charge cable, set automatically, or manually if Config=Fixed Cable)
unsigned int ChargeCurrent;                                                     // Calculated Charge Current (Amps *10)
unsigned int OverrideCurrent = 0;                                               // Temporary assigned current (Amps *10) (modbus)
signed int Imeasured = 0;                                                       // Max of all Phases (Amps *10) of mains power
signed int ImeasuredNegative = 0;                                               // Max of all Phases (Amps *10) of generated surplus power (negative)
signed int Isum = 0;                                                            // Sum of all measured Phases (Amps *10) (can be negative)

// Load Balance variables
signed int IsetBalanced = 0;                                                    // Max calculated current (Amps *10) available for all EVSE's
unsigned int Balanced[NR_EVSES] = {0, 0, 0, 0, 0, 0, 0, 0};                     // Amps value per EVSE
unsigned int BalancedMax[NR_EVSES] = {0, 0, 0, 0, 0, 0, 0, 0};                  // Max Amps value per EVSE
char BalancedState[NR_EVSES] = {0, 0, 0, 0, 0, 0, 0, 0};                        // State of all EVSE's 0=not active (state A), 1=charge request (State B), 2= Charging (State C)
unsigned int BalancedError[NR_EVSES] = {0, 0, 0, 0, 0, 0, 0, 0};                // Error state of EVSE
bool EVSEOnline[NR_EVSES];                                                      // 0: Master / 1: Node 1 ...
struct NodeStatus Node[NR_EVSES];

unsigned char RX1byte;
unsigned char idx = 0, idx2 = 0, ISRFLAG = 0, ISR2FLAG = 0, ISRTXFLAG = 0, ISRTXLEN = 0;
unsigned char menu = 0;
unsigned int locktimer = 0, unlocktimer = 0;                                    // solenoid timers
unsigned char lock1 = 0, lock2 = 0;
unsigned long Timer = 0;                                                        // mS counter
unsigned long ModbusTimer;
unsigned char BacklightTimer = 0;                                               // Backlight timer (sec)
unsigned int ChargeTimer = 0;                                                   // Counts seconds in STATE C (Charging) (unused)
unsigned char LCDTimer = 0;
signed char TempEVSE = 0;                                                       // Temperature EVSE in deg C (-50 to +125)
unsigned char ButtonState = 0x0f;                                               // Holds latest push Buttons state (LSB 3:0)
unsigned char OldButtonState = 0x0f;                                            // Holds previous push Buttons state (LSB 3:0)
unsigned char LCDNav = 0;
unsigned char SubMenu = 0;
unsigned long ScrollTimer = 0;
unsigned char LCDpos = 0;
unsigned char ChargeDelay = 0;                                                  // Delays charging at least 60 seconds in case of not enough current available.
unsigned char NoCurrent = 0;                                                    // counts overcurrent situations.
unsigned char TestState = 0;
unsigned char LedTimer = 0;                                                     // LED on I01 uses TMR2 and a PWM signal to fade in/out
unsigned char LedUpdate = 0;                                                    // Flag that LED PWM data has been updated
unsigned char LedCount = 0;                                                     // Raw Counter before being converted to PWM value
unsigned char LedPwm = 0;                                                       // PWM value 0-255
unsigned char ModbusRequest = 0;                                                // Flag to request Modbus information
unsigned char MenuItems[MENU_EXIT];
unsigned char unlockMagic = 0;
unsigned char unlock55 = 0;                                                     // unlock bytes set to 0 to prevent flash write at por
unsigned char unlockAA = 0;                                                     // unlock bytes set to 0 to prevent flash write at por
unsigned char Access_bit = 0;
unsigned int serialnr = 0;
unsigned char GridActive = 0;                                                   // When the CT's are used on Sensorbox2, it enables the GRID menu option.
unsigned char CalActive = 0;                                                    // When the CT's are used on Sensorbox(1.5 or 2), it enables the CAL menu option.
unsigned int Iuncal = 0;                                                        // Uncalibrated CT1 measurement (resolution 10mA)

unsigned int SolarStopTimer = 0;
unsigned char DelayedRS485SendBuf = 0;
signed long EnergyCharged = 0;                                                  // kWh meter value energy charged. (Wh) (will reset if state changes from A->B)
signed long EnergyMeterStart = 0;                                               // kWh meter value is stored once EV is connected to EVSE (Wh)
signed long PowerMeasured = 0;                                                  // Measured Charge power in Watt by kWh meter
unsigned char RFID[8] = {0, 0, 0, 0, 0, 0, 0, 0};
unsigned char RFIDstatus = 0;

void interrupt high_isr(void)
{
    // Determine what caused the interrupt
    while (PIR1bits.RC1IF)                                                      // Uart1 receive interrupt? RS485
    {
        RX1byte = RCREG1;                                                       // copy received byte

        if (ModbusTimer > 3)                                                    // last reception more then 3ms ago?
        {
            idx = 0;                                                            // clear idx in RS485 RX handler
        }
        if (idx == 50) idx--;                                                   // max 50 bytes in buffer
        U1buffer[idx++] = RX1byte;                                              // Store received byte in buffer

        ModbusTimer = 0;
    }

    if (PIR1bits.TX1IF && PIE1bits.TX1IE)                                       // Uart1 transmit interrupt? RS485
    {
        TXREG1 = U1TXbuffer[ISRTXFLAG++];                                       // send character
        if ((ISRTXFLAG == ISRTXLEN)|| ISRTXFLAG == 50)                          // end of buffer
        {
            PIE1bits.TX1IE = 0;                                                 // clear transmit Interrupt for RS485 after sending last character
            ISRTXFLAG = 0;                                                      // end of transmission.
        }                                                                       // we switch off the transmitter in the main loop, after the final character has been sent..
        ModbusTimer = 0;                                                        // make sure there is a delay between modbus packets
    }

    // Uart2 receive interrupt?
    while (PIR3bits.RC2IF)
    {
        // Check for BREAK character, then Reset
        if (RCSTA2bits.FERR && RCONbits.POR && State == STATE_A ) {
                                                                                // Make sure any data during a POR is ignored.
            RX1byte = RCREG2;                                                   // copy received byte
            if (!RX1byte) Reset();                                              // Only reset if not charging...
        } else RX1byte = RCREG2;

        RCONbits.POR = 1;                                                       // flag that future resets are not POR resets

        TXREG2 = RX1byte;                                                       // echo to UART2 port, don't check for overflow here.
        if (idx2 == 50) idx2--;
        if ((RX1byte == 0x08) && (idx2 > 0)) {
            idx2--;                                                             // backspace
        } else {
            if (RX1byte == 0x0d || RX1byte == 0x0a)                             // CR or LF?
            {
                RX1byte = 0;
                ISR2FLAG = idx2 + 1u;                                           // ENTER, process data
            }
            U2buffer[idx2++] = RX1byte;                                         // store byte
        }
    }

    // Timer 4 interrupt, called 1000 times/sec
    while (PIR5bits.TMR4IF)
    {
        if (Lock)                                                               // Cable lock enabled?
        {
            if (Error || (State != STATE_C)) {
                if (unlocktimer < 600) {                                        // 600ms pulse
                    SOLENOID_UNLOCK;
                } else SOLENOID_OFF;
                if (unlocktimer++ > 700) {
                    if (PORTCbits.RC1 == lock1 )                                // still locked...
                    {
                        if (unlocktimer > 5000) unlocktimer = 0;                //try to unlock again in 5 seconds
                    } else unlocktimer = 700;
                }
                locktimer = 0;
            } else {                                                            // State C
                if (locktimer < 600) {                                          // 600ms pulse
                    SOLENOID_LOCK;
                } else SOLENOID_OFF;
                if (locktimer++ > 700) {
                    if (PORTCbits.RC1 == lock2 )                                // still unlocked...
                    {
                        if (locktimer > 5000) locktimer = 0;                    // try to lock again in 5 seconds
                    } else locktimer = 700;
                }
                unlocktimer = 0;
            }
        }

        Timer++;                                                                // mSec counter (overflows in 1193 hours)
        ModbusTimer++;

        if (LedTimer-- == 0) {
            CCPR2L = LedPwm;                                                    // MSB of DutyCycle, Lsb 0-1 are part of CCP2CON, but not used
                                                                                // LedPwm is calculated in the main loop
            LedTimer = 10;                                                      // Led is updated every 10ms (1ms*10)
            LedUpdate = 1;                                                      // Flag that LED PWM value has been updated
        }

        PIR5bits.TMR4IF = 0;                                                    // clear interrupt flag
    }

}


// Copy modbus frame to output buffer
// Start RS485 transmission, by enabling TX interrupt
void RS485SendBuf(char *buffer, unsigned char len) {
    unsigned char index = 0;

#ifdef LOG_INFO_MODBUS
    printf("\nSend packet");
#endif
#ifdef LOG_DEBUG_MODBUS
    for (unsigned char i=0; i<len; i++) printf(" %02X", buffer[i]);
#endif
    while (ISRTXFLAG) {}                                                        // wait if we are already transmitting on the RS485 bus (blocking, does not occur?)
    ISRTXLEN = len;                                                             // number of bytes to transfer

    while (len--) {
        U1TXbuffer[index++] = *buffer++;                                        // load next byte
    }

    if (ModbusTimer > 6) {                                                      // No RS485 reception at the moment

        LATBbits.LATB5 = 1;                                                     // set RS485 transceiver to transmit
        delay(1);
        PIE1bits.TX1IE = 1;                                                     // enable transmit Interrupt for RS485
    } else DelayedRS485SendBuf = 1;                                             // RS485 reception taking place, handle sending of frame in main loop

}

void eeprom_read_object(void *obj_p, size_t obj_size) {
    unsigned char *p = obj_p;

    EECON1 = 0;                                                                 // select EEprom
                                                                                // EEADR needs to be initialized
    while (obj_size--) {
        EECON1bits.RD = 1;
        *p++ = EEDATA;
        EEADR++;
    }
}

void eeprom_write_object(void *obj_p, size_t obj_size) {
    unsigned char *p = obj_p;

    while (obj_size--) {
        EECON1 = 0;                                                             //ensure CFGS=0 and EEPGD=0
        EECON1bits.WREN = 1;                                                    //enable write to EEPROM

        EEDATA = *p++;                                                          // set data
        if (!INTCONbits.GIE)                                                    // Interrupts should have been disabled!
        {
            EECON2 = unlock55;                                                  // required sequence #1
            EECON2 = unlockAA;                                                  // #2
            EECON1bits.WR = 1;                                                  // #3 = actual write
            while (EECON1bits.WR);                                              // blocking
        }
        EECON1bits.WREN = 0;                                                    // disable write to EEPROM
        EEADR++;
    }
}

/**
 * Validate setting ranges and dependencies
 */
void validate_settings(void) {
    unsigned char i;
    unsigned int value;

    for (i = MENU_ENTER + 1;i < MENU_EXIT; i++){
        value = getItemValue(i);
        //printf("value %s set to %i\n",MenuStr[i].Key, value );
        if (value > MenuStr[i].Max || value < MenuStr[i].Min) {
            value = MenuStr[i].Default;
          //  printf("set default value for %s to %i\n",MenuStr[i].Key, value );
            setItemValue(i, value);
        }
    }

    // Enable access if no access switch used
    if (Switch != 1 && Switch != 2) Access_bit = 1;
    // Sensorbox v2 has always address 0x0A
    if (MainsMeter == EM_SENSORBOX) MainsMeterAddress = 0x0A;
    // Disable modbus reception on normal mode
    if (Mode == MODE_NORMAL) { MainsMeter = 0; PVMeter = 0; }
    // Disable PV reception if not configured
    if (MainsMeterMeasure == 0) PVMeter = 0;
    // set Lock variables for Solenoid or Motor
    if (Lock == 1) { lock1=0; lock2=1; }
    else if (Lock == 2) { lock1=1; lock2=0; }
    // Erase all RFID cards from ram + eeprom if set to EraseAll
    if (RFIDReader == 4) {                                                      // Erase ALL Cards
        for (i = 0; i < 120; i++) RFIDlist[i] = 0xff;
        WriteRFIDlist();
#ifdef LOG_INFO_EVSE
        printf("\nAll RFID cards erased!");
#endif
        RFIDReader = 0;                                                         // RFID Reader Disabled
    }

    // Backward compatibility < 2.20
    if (EMConfig[EM_CUSTOM].IRegister == 8 || EMConfig[EM_CUSTOM].URegister == 8 || EMConfig[EM_CUSTOM].PRegister == 8 || EMConfig[EM_CUSTOM].ERegister == 8) {
        EMConfig[EM_CUSTOM].IsDouble = true;
        EMConfig[EM_CUSTOM].IRegister = 0;
        EMConfig[EM_CUSTOM].URegister = 0;
        EMConfig[EM_CUSTOM].PRegister = 0;
        EMConfig[EM_CUSTOM].ERegister = 0;
    }
}

// Read a list of 20 RFID's from eeprom
//
void ReadRFIDlist(void) {
    EEADR = 0;                                                                  // start from adr 256 in eeprom
    EEADRH = 1;

    eeprom_read_object(RFIDlist, 120);
}

// Write a list of 20 RFID's to the eeprom
//
void WriteRFIDlist(void) {
    char savint;

    unlock55 = unlockMagic + 0x33;
    unlockAA = unlockMagic + 0x88;                                              // set unlock variables to magic values

    savint = INTCON;                                                            // Save interrupts state
    INTCONbits.GIE = 0;                                                         // Disable interrupts

    EEADR = 0;                                                                  // start from adr 256 in eeprom
    EEADRH = 1;

    eeprom_write_object(RFIDlist, 120);                                        // write 120 bytes to eeprom

    unlock55 = 0;                                                               // clear unlock values
    unlockAA = 0;

    INTCON = savint;                                                            // Restore interrupts
#ifdef LOG_DEBUG_EVSE
    printf("\nRFID list saved\n");
#endif
}

// scan for matching RFID in RFIDlist
// returns offset+6 when found, 0 when not found
unsigned char MatchRFID(void) {
    unsigned char offset = 0, r;

    do {
        r = memcmp(RFID + 1, RFIDlist + offset, 6 );                            // compare read RFID with list of stored RFID's
        offset += 6;
    } while (r !=0 && offset < 114);

    if (r == 0) return offset;                                                  // return offset + 6 in RFIDlist
    else return 0;
}


// Store RFID card in memory and eeprom
// returns 1 when successful
// returns 2 when already stored
// returns 0 when all slots are full.
unsigned char StoreRFID(void) {
    unsigned char offset = 0, r;
    unsigned char empty[6] = {0xff,0xff,0xff,0xff,0xff,0xff};

    // first check if the Card ID was already stored.
    if ( MatchRFID() ) return 2;                                                // already stored, that's ok.

    do {
        r = memcmp(empty, RFIDlist + offset, 6 );
        offset += 6;
    } while (r !=0 && offset < 120);
    if (r != 0) return 0;                                                       // no more room to store RFID
    offset -= 6;
//    printf("offset %u ",offset);
    memcpy(RFIDlist + offset, RFID+1, 6);

#ifdef LOG_DEBUG_EVSE
    printf("\nRFIDlist:");
    for (r=0; r<120; r++) printf("%02x",RFIDlist[r]);
#endif

    WriteRFIDlist();
    return 1;
}

// Delete RFID card in memory and eeprom
// returns 1 when successful, 0 when RFID was not found
unsigned char DeleteRFID(void) {
    unsigned char offset = 0, r;

    offset = MatchRFID();                                                       // find RFID in list
    if (offset) {
        offset -= 6;
        for (r = 0; r < 6; r++) RFIDlist[offset + r] = 0xff;
    } else return 0;

//    printf("deleted %u ",offset);
//    for (r=0; r<120; r++) printf("%02x",RFIDlist[r]);

    return 1;
}

void read_settings(void) {

    EEADR = 0;                                                                  // start from adr 0 in eeprom
    EEADRH = 0;                                                                 // we only use the first 256 bytes for now.

    eeprom_read_object(&MaxMains, sizeof MaxMains);
    if (MaxMains > 200) {                                                       // check if the eeprom is uninitialized
        MaxMains = MAX_MAINS;                                                   // set MaxMains back to default value
        write_settings();                                                       // uninitialized, write default settings to eeprom
        return;
    }

    eeprom_read_object(&MaxCurrent, sizeof MaxCurrent);
    eeprom_read_object(&MinCurrent, sizeof MinCurrent);
    eeprom_read_object(&ICal, sizeof ICal);
    eeprom_read_object(&Mode, sizeof Mode);
    eeprom_read_object(&Lock, sizeof Lock);
    eeprom_read_object(&MaxCircuit, sizeof MaxCircuit);
    eeprom_read_object(&Config, sizeof Config);
    eeprom_read_object(&LoadBl, sizeof LoadBl);
    eeprom_read_object(&Switch, sizeof Switch);
    eeprom_read_object(&RCmon, sizeof RCmon);
    eeprom_read_object(&StartCurrent, sizeof StartCurrent);
    eeprom_read_object(&StopTime, sizeof StopTime);
    eeprom_read_object(&MainsMeter, sizeof MainsMeter);
    eeprom_read_object(&MainsMeterAddress, sizeof MainsMeterAddress);
    eeprom_read_object(&MainsMeterMeasure, sizeof MainsMeterMeasure);
    eeprom_read_object(&PVMeter, sizeof PVMeter);
    eeprom_read_object(&PVMeterAddress, sizeof PVMeterAddress);
    eeprom_read_object(&EMConfig[EM_CUSTOM].Endianness, sizeof EMConfig[EM_CUSTOM].Endianness);
    eeprom_read_object(&EMConfig[EM_CUSTOM].IRegister, sizeof EMConfig[EM_CUSTOM].IRegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].IDivisor, sizeof EMConfig[EM_CUSTOM].IDivisor);
    eeprom_read_object(&ImportCurrent, sizeof ImportCurrent);
    eeprom_read_object(&Grid, sizeof Grid);
    eeprom_read_object(&EVMeter, sizeof EVMeter);
    eeprom_read_object(&EVMeterAddress, sizeof EVMeterAddress);
    eeprom_read_object(&RFIDReader, sizeof RFIDReader);
    eeprom_read_object(&EMConfig[EM_CUSTOM].URegister, sizeof EMConfig[EM_CUSTOM].URegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].UDivisor, sizeof EMConfig[EM_CUSTOM].UDivisor);
    eeprom_read_object(&EMConfig[EM_CUSTOM].PRegister, sizeof EMConfig[EM_CUSTOM].PRegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].PDivisor, sizeof EMConfig[EM_CUSTOM].PDivisor);
    eeprom_read_object(&EMConfig[EM_CUSTOM].ERegister, sizeof EMConfig[EM_CUSTOM].ERegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].EDivisor, sizeof EMConfig[EM_CUSTOM].EDivisor);
    eeprom_read_object(&EMConfig[EM_CUSTOM].IsDouble, sizeof EMConfig[EM_CUSTOM].IsDouble);

    validate_settings();
}

void write_settings(void) {
    char savint;

    unlock55 = unlockMagic + 0x33;
    unlockAA = unlockMagic + 0x88;                                              // set unlock variables to magic values

    validate_settings();

    savint = INTCON;                                                            // Save interrupts state
    INTCONbits.GIE = 0;                                                         // Disable interrupts

    EEADR = 0;                                                                  // start from adr 0 in eeprom
    EEADRH = 0;                                                                 // we only use the first 256 bytes for now.

    eeprom_write_object(&MaxMains, sizeof MaxMains);
    eeprom_write_object(&MaxCurrent, sizeof MaxCurrent);
    eeprom_write_object(&MinCurrent, sizeof MinCurrent);
    eeprom_write_object(&ICal, sizeof ICal);
    eeprom_write_object(&Mode, sizeof Mode);
    eeprom_write_object(&Lock, sizeof Lock);
    eeprom_write_object(&MaxCircuit, sizeof MaxCircuit);
    eeprom_write_object(&Config, sizeof Config);
    eeprom_write_object(&LoadBl, sizeof LoadBl);
    eeprom_write_object(&Switch, sizeof Switch);
    eeprom_write_object(&RCmon, sizeof RCmon);
    eeprom_write_object(&StartCurrent, sizeof StartCurrent);
    eeprom_write_object(&StopTime, sizeof StopTime);
    eeprom_write_object(&MainsMeter, sizeof MainsMeter);
    eeprom_write_object(&MainsMeterAddress, sizeof MainsMeterAddress);
    eeprom_write_object(&MainsMeterMeasure, sizeof MainsMeterMeasure);
    eeprom_write_object(&PVMeter, sizeof PVMeter);
    eeprom_write_object(&PVMeterAddress, sizeof PVMeterAddress);
    eeprom_write_object(&EMConfig[EM_CUSTOM].Endianness, sizeof EMConfig[EM_CUSTOM].Endianness);
    eeprom_write_object(&EMConfig[EM_CUSTOM].IRegister, sizeof EMConfig[EM_CUSTOM].IRegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].IDivisor, sizeof EMConfig[EM_CUSTOM].IDivisor);
    eeprom_write_object(&ImportCurrent, sizeof ImportCurrent);
    eeprom_write_object(&Grid, sizeof Grid);
    eeprom_write_object(&EVMeter, sizeof EVMeter);
    eeprom_write_object(&EVMeterAddress, sizeof EVMeterAddress);
    eeprom_write_object(&RFIDReader, sizeof RFIDReader);
    eeprom_write_object(&EMConfig[EM_CUSTOM].URegister, sizeof EMConfig[EM_CUSTOM].URegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].UDivisor, sizeof EMConfig[EM_CUSTOM].UDivisor);
    eeprom_write_object(&EMConfig[EM_CUSTOM].PRegister, sizeof EMConfig[EM_CUSTOM].PRegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].PDivisor, sizeof EMConfig[EM_CUSTOM].PDivisor);
    eeprom_write_object(&EMConfig[EM_CUSTOM].ERegister, sizeof EMConfig[EM_CUSTOM].ERegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].EDivisor, sizeof EMConfig[EM_CUSTOM].EDivisor);
    eeprom_write_object(&EMConfig[EM_CUSTOM].IsDouble, sizeof EMConfig[EM_CUSTOM].IsDouble);

    unlock55 = 0;                                                               // clear unlock values
    unlockAA = 0;

    INTCON = savint;                                                            // Restore interrupts
#ifdef LOG_INFO_EVSE
    printf("\nsettings saved\n");
#endif

    if (LoadBl == 1) {                                                          // Master mode
        unsigned int i, values[MODBUS_SYS_CONFIG_END - MODBUS_SYS_CONFIG_START + 1];
        for (i = 0; i < (MODBUS_SYS_CONFIG_END - MODBUS_SYS_CONFIG_START + 1); i++) {
            values[i] = getItemValue(MENU_CIRCUIT + i);
        }
        // Broadcast settings to other controllers
        ModbusWriteMultipleRequest(BROADCAST_ADR, MODBUS_SYS_CONFIG_START, values, MODBUS_SYS_CONFIG_END - MODBUS_SYS_CONFIG_START + 1);
    }
}

void putch(unsigned char byte)                                                  // user defined printf support on uart2
{
    // output one byte on UART2
    while (!PIR3bits.TX2IF);                                                    // set when register is empty (blocking)
    TXREG2 = byte;

}

unsigned char ReadPilot(void)                                                   // Read Pilot Signal
{
    ADCON0bits.GO = 1;                                                          // start ADC conversion on the selected channel
    while (ADCON0bits.GO);                                                      // wait for conversion to finish (blocking)
    if (ADRES > 980) return PILOT_12V;                                          // Pilot at 12V (min 11.0V)
    if ((ADRES > 860) && (ADRES < 915)) return PILOT_9V;                        // Pilot at 9V
    if ((ADRES > 720) && (ADRES < 800)) return PILOT_6V;                        // Pilot at 6V
    if ((ADRES > 25) && (ADRES < 95)) return PILOT_DIODE;                       // Diode Check OK
    return PILOT_NOK;                                                           // Pilot NOT ok
}

void ProximityPin(void) {
    ADCON0 = 0b00000101;                                                        // ADC input AN1 (Proximity Pin)
    delay(100);                                                                 // delay 100ms (blocking)
    ADCON0bits.GO = 1;                                                          // initiate ADC conversion on the selected channel
    while (ADCON0bits.GO);                                                      // wait for conversion to finish (blocking)

    MaxCapacity = 13;                                                           // No resistor, Max cable current = 13A
    if ((ADRES > 394) && (ADRES < 434)) MaxCapacity = 16;                       // Max cable current = 16A	680R
    if ((ADRES > 175) && (ADRES < 193)) MaxCapacity = 32;                       // Max cable current = 32A	220R
    if ((ADRES > 88) && (ADRES < 98)) MaxCapacity = 63;                         // Max cable current = 63A	100R

    if (Config) MaxCapacity = MaxCurrent;                                       // Override with MaxCurrent when Fixed Cable is used.

    ADCON0 = 0b00000001;                                                        // ADC input AN0 (Pilot)
}

void Temp(void)                                                                 // Measure Temperature EVSE (0-125 C)
{
    unsigned int temp;

    ADCON0 = 0b00001001;                                                        // ADC input AN2 (Temperature Sensor)
    ADCON1 = 0b00001000;                                                        // Use VREF 2.048V
    ADCON2 = 0b10111101;                                                        // Right justify, Tacq = 20 uS, FOSC/16
    ADCON0bits.GO = 1;                                                          // initiate ADC conversion on the selected channel
    while (ADCON0bits.GO);                                                      // wait for conversion to finish (blocking)

    temp = ADRES / 5;                                                           // ADRES= 2mv / ADC step
                                                                                // temp = gr/C (including offset of 50)
    ADCON0 = 0b00000001;                                                        // ADC input AN0 (Pilot)
    ADCON1 = 0b00000000;                                                        // Use standard Voltage ref = VCC
    ADCON2 = 0b10100101;                                                        // Right justify, Tacq = 8 uS, FOSC/16

    TempEVSE = temp - 50;                                                       // set Temp (-50 to +125 deg C), and remove offset
}


void BlinkLed(void) {
    if (Error || ChargeDelay) {
        if (LedUpdate) {
            if (Error & (RCD_TRIPPED | CT_NOCOMM) ) {
                LedCount += 20;                                                 // Very rapid flashing, RCD tripped or no Serial Communication.
                if (LedCount > 128) LedPwm = 255;                               // LED 50% of time on, full brightness
                else LedPwm = 0;
            } else {                                                            // Waiting for Solar power or enough current to start charging
                LedCount += 2;                                                  // Slow blinking.
                if (LedCount > 230) LedPwm = 255;                               // LED 10% of time on, full brightness
                else LedPwm = 0;
            }

            LedUpdate = 0;
          }
    } else if (Access_bit == 0) LedPwm = 0;                                     // No Access, LED off
    else if (State == STATE_A) LedPwm = 40;                                     // STATE A, LED on (dimmed)
    else if (State == STATE_B) {
        LedPwm = 255;                                                           // STATE B, LED on (full brightness)
        LedCount = 128;                                                         // When switching to STATE C, start at full brightness
    } else if (State == STATE_C && LedUpdate)                                   // STATE C, LED fades in/out
    {
        if (Mode == MODE_SOLAR) LedCount ++;                                    // Slow fading (Solar mode)
        else LedCount += 2;                                                     // Faster fading (Smart mode)
        LedPwm = ease8InOutQuad(triwave8(LedCount));                            // pre calculate new LedPwm value
        LedUpdate = 0;
    }
}

void SetCurrent(unsigned int current)                                           // current in Amps*10 (160 = 16A)
{
    unsigned int DutyCycle;

    if ((current >= 60) && (current <= 510)) DutyCycle = (unsigned int) (current / 0.6);
                                                                                // calculate DutyCycle from current
    else if ((current > 510) && (current <= 800)) DutyCycle = (unsigned int) (current / 2.5) + 640;
    else DutyCycle = 100;                                                       // invalid, use 6A
    CCPR1L = DutyCycle >> 2;                                                    // Msb of DutyCycle
                                                                                // 2 Lsb are part of CCP1CON, use Timer 2
    CCP1CON = (((DutyCycle & 0x03) << 4) | 0x0C);                               // PWM Pilot signal enabled
}

/**
 * Get name of a state
 *
 * @param unsigned char State
 * @return unsigned char[] Name
 */
const far unsigned char * getStateName(unsigned char StateCode) {
    if(StateCode < 9) return StrStateName[StateCode];
    else return "NOSTATE";
}

/**
 * Set the solar stop timer
 * 
 * @param unsigned int Timer (seconds)
 */
void setSolarStopTimer(unsigned int Timer) {
    if (LoadBl == 1 && SolarStopTimer != Timer) {
        ModbusWriteSingleRequest(BROADCAST_ADR, 0xAB, Timer);
    }
    SolarStopTimer = Timer;
}

/**
 * Set state
 *
 * @param NewState
 */
void setState(unsigned char NewState) {
#ifdef LOG_INFO_EVSE
#ifndef LOG_DEBUG_EVSE
    if (State != NewState) {
#endif
        printf("\nSTATE %s->%s", getStateName(State), getStateName(NewState));
#ifndef LOG_DEBUG_EVSE
    }
#endif
#endif
    State = NewState;
}

// Is there at least 6A(configurable MinCurrent) available for a EVSE?
// returns 1 if there is 6A available
// returns 0 if there is no current available
//
char IsCurrentAvailable(void) {
    unsigned char n, ActiveEVSE = 0;
    int Baseload, TotalCurrent = 0;


    for (n = 0; n < NR_EVSES; n++) if (BalancedState[n] == STATE_C)                    // must be in STATE_C
    {
        ActiveEVSE++;                                                           // Count nr of active (charging) EVSE's
        TotalCurrent += Balanced[n];                                            // Calculate total max charge current for all active EVSE's
    }
    if (ActiveEVSE == 0) {                                                      // No active (charging) EVSE's
        if (Imeasured > ((MaxMains - MinCurrent) * 10)) {                       // There should be at least 6A available
            return 0;                                                           // Not enough current available!, return with error
        }
    } else {                                                                    // at least one active EVSE
        ActiveEVSE++;                                                           // Do calculations with one more EVSE
        Baseload = Imeasured - TotalCurrent;                                    // Calculate Baseload (load without any active EVSE)
        if (Baseload < 0) Baseload = 0;                                         // only relevant for Smart/Solar mode

        if (ActiveEVSE > NR_EVSES) ActiveEVSE = NR_EVSES;
        // When load balancing is active, and we are the Master, the Circuit option limits the max total current
        if (LoadBl == 1) {
            if ((ActiveEVSE * (MinCurrent * 10)) > (MaxCircuit * 10)) {
                return 0;                                                       // Not enough current available!, return with error
            }
        }

        // Check if the lowest charge current(6A) x ActiveEV's + baseload would be higher then the MaxMains.
        if ((ActiveEVSE * (MinCurrent * 10) + Baseload) > (MaxMains * 10)) {
            return 0;                                                           // Not enough current available!, return with error
        }

    }

    // Allow solar Charging if surplus current is above 'StartCurrent' (on one of the phases)
    // Charging will start after the timeout (chargedelay) period has ended
    // now set to -4A (configurable)
    if (Mode == MODE_SOLAR) {                                                   // no active EVSE yet?
        if (ActiveEVSE == 0 && ImeasuredNegative >= ((signed int)StartCurrent *-10)) return 0;
        else if ((ActiveEVSE * MinCurrent * 10) > TotalCurrent) return 0;       // check if we can split the available current between all active EVSE's
    }

    return 1;
}

void ResetBalancedStates(void) {
    unsigned char n;

    for (n = 1; n < NR_EVSES; n++) {
        BalancedState[n] = STATE_A;                                             // Yes, disable old active Node states
        Balanced[n] = 0;                                                        // reset ChargeCurrent to 0
    }
}

// Calculates Balanced PWM current for each EVSE
// mod =0 normal
// mod =1 we have a new EVSE requesting to start charging.
//
void CalcBalancedCurrent(char mod) {
    int Average, MaxBalanced, Idifference;
    int BalancedLeft = 0;
    signed int IsumImport;
    int ActiveMax = 0, TotalCurrent = 0, Baseload;
    char CurrentSet[NR_EVSES] = {0, 0, 0, 0, 0, 0, 0, 0};
    char n;

    if (!LoadBl) ResetBalancedStates();                                         // Load balancing disabled?, Reset States
                                                                                // Do not modify MaxCurrent as it is a config setting. (fix 2.05)
    if (BalancedState[0] == STATE_C && MaxCurrent > MaxCapacity && !Config) ChargeCurrent = MaxCapacity * 10;
    else ChargeCurrent = MaxCurrent * 10;                                       // Instead use new variable ChargeCurrent.

    // Override current temporary if set (from Modbus)
    if (OverrideCurrent) ChargeCurrent = OverrideCurrent;

    if (LoadBl < 2) BalancedMax[0] = ChargeCurrent;                             // Load Balancing Disabled or Master:
                                                                                // update BalancedMax[0] if the MAX current was adjusted using buttons or CLI

    for (n = 0; n < NR_EVSES; n++) if (BalancedState[n] == STATE_C) {
            BalancedLeft++;                                                     // Count nr of Active (Charging) EVSE's
            ActiveMax += BalancedMax[n];                                        // Calculate total Max Amps for all active EVSEs
            TotalCurrent += Balanced[n];                                        // Calculate total of all set charge currents
        }

    if (!mod && Mode != MODE_SOLAR) {                                           // Normal and Smart mode
        Idifference = (MaxMains * 10) - Imeasured;                              // Difference between MaxMains and Measured current (can be negative)

        if (Idifference > 0) IsetBalanced += (Idifference / 4);                 // increase with 1/4th of difference (slowly increase current)
        else IsetBalanced += (Idifference * 100 / TRANSFORMER_COMP);            // last PWM setting + difference (immediately decrease current)
        if (IsetBalanced < 0) IsetBalanced = 0;
        if (IsetBalanced > 800) IsetBalanced = 800;                             // hard limit 80A (added 11-11-2017)
    }



    if (Mode == MODE_SOLAR)                                                     // Solar version
    {
        #ifdef SPECIAL                                                          // Import option not visible , make sure it's set to 0
        ImportCurrent = 0;
        #endif
        IsumImport = Isum - (10 * ImportCurrent);                               // Allow Import of power from the grid when solar charging

        if (IsumImport < 0)                                                     // If it's negative, we have surplus (solar) power available
        {
            if (IsumImport < -10) IsetBalanced = IsetBalanced - (IsumImport / 3); //IsetBalanced + 5; // still more then 1A available, increase Balanced charge current with 0.5A
            else IsetBalanced = IsetBalanced - (IsumImport / 4);                // less then 1A difference, increase with 1/4th of difference.
        } else IsetBalanced = IsetBalanced - (IsumImport / 2);                  // Positive, decrease Balanced charge current.
                                                                                // If IsetBalanced is below MinCurrent or negative, make sure it's set to MinCurrent.
        if ( (IsetBalanced < (BalancedLeft * MinCurrent * 10)) || (IsetBalanced < 0) ) {
            IsetBalanced = BalancedLeft * MinCurrent * 10;
                                                                                // ----------- Check to see if we have to continue charging on solar power alone ----------
            if (BalancedLeft && StopTime && (IsumImport > 10)) {
                if (SolarStopTimer == 0) setSolarStopTimer(StopTime * 60);      // Convert minutes into seconds
            } else {
                setSolarStopTimer(0);
            }
        } else {
            setSolarStopTimer(0);
        }
    }
                                                                                // When Load balancing = Master,  Limit total current of all EVSEs to MaxCircuit
    if (LoadBl == 1 && (IsetBalanced > (MaxCircuit * 10)) ) IsetBalanced = MaxCircuit * 10;


    Baseload = Imeasured - TotalCurrent;                                        // Calculate Baseload (load without any active EVSE)
    if (Baseload < 0) Baseload = 0;

    if (Mode == MODE_NORMAL)                                                    // Normal Mode
    {
        if (LoadBl == 1) IsetBalanced = MaxCircuit * 10;                        // Load Balancing = Master? MaxCircuit is max current for all active EVSE's
        else IsetBalanced = ChargeCurrent;                                      // No Load Balancing in Normal Mode. Set current to ChargeCurrent (fix: v2.05)
    }

    if (BalancedLeft)                                                           // Only if we have active EVSE's
    {
        // New EVSE charging, and no Solar mode
        if (mod && Mode != MODE_SOLAR) IsetBalanced = (MaxMains * 10) - Baseload;// Set max combined charge current to MaxMains - Baseload

        if (IsetBalanced < 0 || IsetBalanced < (BalancedLeft * MinCurrent * 10)
          || ( Mode == MODE_SOLAR && Isum > 10 && Imeasured > (MaxMains * 10)) )
        {
            IsetBalanced = BalancedLeft * MinCurrent * 10;                      // set minimal "MinCurrent" charge per active EVSE
            NoCurrent++;                                                        // Flag NoCurrent left
#ifdef LOG_INFO_EVSE
            printf("\nNo Current!!");
#endif
        } else NoCurrent = 0;

        if (IsetBalanced > ActiveMax) IsetBalanced = ActiveMax;                 // limit to total maximum Amps (of all active EVSE's)

        MaxBalanced = IsetBalanced;                                             // convert to Amps

        // Calculate average current per EVSE
        n = 0;
        do {
            Average = MaxBalanced / BalancedLeft;                               // Average current for all active EVSE's

        // Check for EVSE's that have a lower MAX current
            if ((BalancedState[n] == STATE_C) && (!CurrentSet[n]) && (Average >= BalancedMax[n])) // Active EVSE, and current not yet calculated?
            {
                Balanced[n] = BalancedMax[n];                                   // Set current to Maximum allowed for this EVSE
                CurrentSet[n] = 1;                                              // mark this EVSE as set.
                BalancedLeft--;                                                 // decrease counter of active EVSE's
                MaxBalanced -= Balanced[n];                                     // Update total current to new (lower) value
                n = 0;                                                          // check all EVSE's again
            } else n++;
        } while (n < NR_EVSES && BalancedLeft);

        // All EVSE's which had a Max current lower then the average are set.
        // Now calculate the current for the EVSE's which had a higher Max current
        n = 0;
        if (BalancedLeft)                                                       // Any Active EVSE's left?
        {
            do {                                                                // Check for EVSE's that are not set yet
                if ((BalancedState[n] == STATE_C) && (!CurrentSet[n]))          // Active EVSE, and current not yet calculated?
                {
                    Balanced[n] = MaxBalanced / BalancedLeft;                   // Set current to Average
                    CurrentSet[n] = 1;                                          // mark this EVSE as set.
                    BalancedLeft--;                                             // decrease counter of active EVSE's
                    MaxBalanced -= Balanced[n];                                 // Update total current to new (lower) value
                }
            } while (++n < NR_EVSES && BalancedLeft);
        }


    } // BalancedLeft

#ifdef LOG_DEBUG_EVSE
    if (LoadBl == 1) {
        printf("\nBalance:");
        for (n = 0; n < NR_EVSES; n++) {
            printf("EVSE%u:%c(%u.%1uA)", n, BalancedState[n]+'A', Balanced[n]/10, Balanced[n]%10);
            if (n < NR_EVSES-1) printf(",");
        }
    }
#endif
}

/**
 * Broadcast momentary currents to all Node EVSE's
 */
void BroadcastCurrent(void) {
    ModbusWriteMultipleRequest(BROADCAST_ADR, 0x01, Balanced, NR_EVSES);
}

/**
 * Master requests Node status over modbus
 * Master -> Node
 *
 * @param unsigned char NodeNr (1-7)
 */
void requestNodeStatus(unsigned char NodeNr) {
    EVSEOnline[NodeNr] = false;
    ModbusReadInputRequest(NodeNr + 1, 4, 0xA0 , 11);                           // Node address, start register = 0xA0 , nr of registers 11
}

/**
 * Master receives Node status over modbus
 * Node -> Master
 *
 * @param unsigned char NodeAdr (1-7)
 */
void receiveNodeStatus(unsigned char *buf, unsigned char NodeNr) {
    EVSEOnline[NodeNr] = true;
//    memcpy(buf, (unsigned char*)&Node[NodeNr], sizeof(struct NodeState));
    BalancedState[NodeNr] = buf[1];                                             // Node State
    BalancedError[NodeNr] = buf[3];                                             // Node Error status
    BalancedMax[NodeNr] = buf[5] * 10;                                          // Node Max ChargeCurrent (0.1A)

    Node[NodeNr].EVMeter = buf[19];
    Node[NodeNr].EVAddress = buf[21];
    //printf("ReceivedNode[%u]Status State:%u Error:%u, BalancedMax:%u \n", NodeNr, BalancedState[NodeNr], BalancedError[NodeNr], BalancedMax[NodeNr] );
}

/**
 * Master checks node status requests, and responds with new state
 * Master -> Node
 *
 * @param unsigned char NodeAdr (1-7)
 */
void processAllNodeStates(unsigned char NodeNr) {
    unsigned int values[2];
    unsigned char current, write = 0;

    values[0] = BalancedState[NodeNr];

    current = IsCurrentAvailable();
    if (current) {                                                              // Yes enough current
        if (BalancedError[NodeNr] & (LESS_6A|NO_SUN)) {
            BalancedError[NodeNr] &= ~(LESS_6A | NO_SUN);                       // Clear Error flags
            write = 1;
        }
    }

    // Check EVSE for request to charge states
    switch (BalancedState[NodeNr]) {

        case STATE_COMM_B:                                                      // Request to charge A->B
#ifdef LOG_INFO_EVSE
            printf("\nNode %u State A->B request ", NodeNr);
#endif
            if (current) {                                                      // check if we have enough current
                                                                                // Yes enough current..
                BalancedState[NodeNr] = STATE_B;                                // Mark Node EVSE as active (State B)
                Balanced[NodeNr] = MinCurrent * 10;                             // Initially set current to lowest setting
                values[0] = STATE_COMM_B_OK;
                write = 1;
#ifdef LOG_INFO_EVSE
                printf("- OK!");
#endif
            } else {                                                            // We do not have enough current to start charging
                Balanced[NodeNr] = 0;                                           // Make sure the Node does not start charging by setting current to 0
                if ((BalancedError[NodeNr] & (LESS_6A|NO_SUN)) == 0) {          // Error flags cleared?
                    if (Mode == MODE_SOLAR) BalancedError[NodeNr] |= NO_SUN;    // Solar mode: No Solar Power available
                    else BalancedError[NodeNr] |= LESS_6A;                      // Normal or Smart Mode: Not enough current available
                    write = 1;
                }
#ifdef LOG_INFO_EVSE
                printf("- Not enough current!");
#endif
            }
            break;

        case STATE_COMM_C:                                                      // request to charge B->C
#ifdef LOG_INFO_EVSE
            printf("\nNode %u State B->C request ", NodeNr);
#endif
            Balanced[NodeNr] = 0;                                               // For correct baseload calculation set current to zero
            if (current) {                                                      // check if we have enough current
                                                                                // Yes
                BalancedState[NodeNr] = STATE_C;                                // Mark Node EVSE as Charging (State C)
                CalcBalancedCurrent(1);                                         // Calculate charge current for all connected EVSE's
                values[0] = STATE_COMM_C_OK;
                write = 1;
#ifdef LOG_INFO_EVSE
                printf("- OK!");
#endif
            } else {                                                            // We do not have enough current to start charging
                if ((BalancedError[NodeNr] & (LESS_6A|NO_SUN)) == 0) {          // Error flags cleared?
                    if (Mode == MODE_SOLAR) BalancedError[NodeNr] |= NO_SUN;    // Solar mode: No Solar Power available
                    else BalancedError[NodeNr] |= LESS_6A;                      // Normal or Smart Mode: Not enough current available
                    write = 1;
                }
#ifdef LOG_INFO_EVSE
                printf("- Not enough current!");
#endif
            }
            break;

        default:
            break;

    }
    values[1] = BalancedError[NodeNr];

    if (write) {
#ifdef LOG_DEBUG_EVSE
        printf("\nNodeAdr %u, BalancedError:%u",NodeNr, BalancedError[NodeNr]);
#endif
        ModbusWriteMultipleRequest(NodeNr+1 , 0xA0, values, 2);                 // Write State and Error to Node
    }

}


/**
 * Create an array of available menu items
 * Depends on configuration settings like CONFIG/MODE/LoadBL
 *
 * @return unsigned char MenuItemCount
 */
unsigned char getMenuItems (void) {
    unsigned char m = 0;

    MenuItems[m++] = MENU_CONFIG;                                               // Configuration (0:Socket / 1:Fixed Cable)
    if (!Config) {                                                              // ? Fixed Cable?
        MenuItems[m++] = MENU_LOCK;                                             // - Cable lock (0:Disable / 1:Solenoid / 2:Motor)
    }
    MenuItems[m++] = MENU_MODE;                                                 // EVSE mode (0:Normal / 1:Smart)
    if (Mode == MODE_SOLAR && LoadBl < 2) {                                     // ? Solar mode and Load Balancing Disabled/Master?
        MenuItems[m++] = MENU_START;                                            // - Start Surplus Current (A)
        MenuItems[m++] = MENU_STOP;                                             // - Stop time (min)
        #ifndef SPECIAL
        MenuItems[m++] = MENU_IMPORT;                                           // - Import Current from Grid (A)
        #endif
    }
    MenuItems[m++] = MENU_LOADBL;                                               // Load Balance Setting (0:Disable / 1:Master / 2-8:Node)
    if (Mode && LoadBl < 2) {                                                   // ? Mode Smart/Solar and Load Balancing Disabled/Master?
        MenuItems[m++] = MENU_MAINS;                                            // - Max Mains Amps (hard limit, limited by the MAINS connection) (A) (Mode:Smart/Solar)
    }
    if (Mode && LoadBl < 2 || LoadBl == 1) {                                    // ? Mode Smart/Solar or LoadBl Master?
        MenuItems[m++] = MENU_MIN;                                              // - Minimal current the EV is happy with (A) (Mode:Smart/Solar or LoadBl:Master)
    }
    if (LoadBl == 1) {                                                          // ? Load balancing Master?
        MenuItems[m++] = MENU_CIRCUIT;                                          // - Max current of the EVSE circuit (A) (LoadBl:Master)
    }
    MenuItems[m++] = MENU_MAX;                                                  // Max Charge current (A)
    MenuItems[m++] = MENU_SWITCH;                                               // External Switch on SW (0:Disable / 1:Access / 2:Smart-Solar)
    MenuItems[m++] = MENU_RCMON;                                                // Residual Current Monitor on RCM (0:Disable / 1:Enable)
    MenuItems[m++] = MENU_RFIDREADER;                                           // RFID Reader connected to SW (0:Disable / 1:Enable / 2:Learn / 3:Delete / 4:Delate All)
    if (Mode) {                                                                 // ? Smart or Solar mode?
        if (LoadBl < 2) {                                                       // - ? Load Balancing Disabled/Master?
            MenuItems[m++] = MENU_MAINSMETER;                                   // - - Type of Mains electric meter (0: Disabled / Constants EM_*)
            if (MainsMeter == EM_SENSORBOX) {                                   // - - ? Sensorbox?
                #ifndef SPECIAL
                if (GridActive == 1) MenuItems[m++] = MENU_GRID;
                #endif
                if (CalActive == 1) MenuItems[m++] = MENU_CAL;                  // - - - Sensorbox CT measurement calibration
            } else if(MainsMeter) {                                             // - - ? Other?
                MenuItems[m++] = MENU_MAINSMETERADDRESS;                        // - - - Address of Mains electric meter (5 - 254)
                MenuItems[m++] = MENU_MAINSMETERMEASURE;                        // - - - What does Mains electric meter measure (0: Mains (Home+EVSE+PV) / 1: Home+EVSE / 2: Home)
                if (MainsMeterMeasure) {                                        // - - - ? PV not measured by Mains electric meter?
                    MenuItems[m++] = MENU_PVMETER;                              // - - - - Type of PV electric meter (0: Disabled / Constants EM_*)
                    if (PVMeter) MenuItems[m++] = MENU_PVMETERADDRESS;          // - - - - - Address of PV electric meter (5 - 254)
                }
            }
        }
        MenuItems[m++] = MENU_EVMETER;                                          // - Type of EV electric meter (0: Disabled / Constants EM_*)
        if (EVMeter) {                                                          // - ? EV meter configured?
            MenuItems[m++] = MENU_EVMETERADDRESS;                               // - - Address of EV electric meter (5 - 254)
        }
        if (LoadBl < 2) {                                                       // - ? Load Balancing Disabled/Master?
            if (MainsMeter == EM_CUSTOM || PVMeter == EM_CUSTOM || EVMeter == EM_CUSTOM) { // ? Custom electric meter used?
                MenuItems[m++] = MENU_EMCUSTOM_ENDIANESS;                       // - - Byte order of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_ISDOUBLE;                        // - - Data type of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_UREGISTER;                       // - - Starting register for voltage of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_UDIVISOR;                        // - - Divisor for voltage of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_IREGISTER;                       // - - Starting register for current of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_IDIVISOR;                        // - - Divisor for current of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_PREGISTER;                       // - - Starting register for power of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_PDIVISOR;                        // - - Divisor for power of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_EREGISTER;                       // - - Starting register for energy of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_EDIVISOR;                        // - - Divisor for energy of custom electric meter
            }
        }
    }
    MenuItems[m++] = MENU_EXIT;

    return m;
}

/**
 * Check minimum and maximum of a value and set the variable
 *
 * @param unsigned char MENU_xxx
 * @param unsigned int value
 * @return unsigned char success
 */
unsigned char setItemValue(unsigned char nav, unsigned int val) {
    if (nav < MENU_EXIT) {
        if (val < MenuStr[nav].Min || val > MenuStr[nav].Max) return 0;
    }

    switch (nav) {
        case MENU_CONFIG:
            Config = val;
            break;
        case MENU_MODE:
        case STATUS_MODE:
            Mode = val;
            break;
        case MENU_START:
            StartCurrent = val;
            break;
        case MENU_STOP:
            StopTime = val;
            break;
        case MENU_IMPORT:
            ImportCurrent = val;
            break;
        case MENU_LOADBL:
            LoadBl = val;
            break;
        case MENU_MAINS:
            MaxMains = val;
            break;
        case MENU_MIN:
            MinCurrent = val;
            break;
        case MENU_MAX:
            MaxCurrent = val;
            break;
        case MENU_CIRCUIT:
            MaxCircuit = val;
            break;
        case MENU_LOCK:
            Lock = val;
            break;
        case MENU_SWITCH:
            Switch = val;
            break;
        case MENU_RCMON:
            RCmon = val;
            break;
        case MENU_CAL:
            ICal = val;
            break;
        case MENU_GRID:
            Grid = val;
            break;
        case MENU_MAINSMETER:
            MainsMeter = val;
            break;
        case MENU_MAINSMETERADDRESS:
            MainsMeterAddress = val;
            break;
        case MENU_MAINSMETERMEASURE:
            MainsMeterMeasure = val;
            break;
        case MENU_PVMETER:
            PVMeter = val;
            break;
        case MENU_PVMETERADDRESS:
            PVMeterAddress = val;
            break;
        case MENU_EVMETER:
            EVMeter = val;
            break;
        case MENU_EVMETERADDRESS:
            EVMeterAddress = val;
            break;
        case MENU_EMCUSTOM_ENDIANESS:
            EMConfig[EM_CUSTOM].Endianness = val;
            break;
        case MENU_EMCUSTOM_ISDOUBLE:
            EMConfig[EM_CUSTOM].IsDouble = val;
            break;
        case MENU_EMCUSTOM_UREGISTER:
            EMConfig[EM_CUSTOM].URegister = val;
            break;
        case MENU_EMCUSTOM_UDIVISOR:
            EMConfig[EM_CUSTOM].UDivisor = val;
            break;
        case MENU_EMCUSTOM_IREGISTER:
            EMConfig[EM_CUSTOM].IRegister = val;
            break;
        case MENU_EMCUSTOM_IDIVISOR:
            EMConfig[EM_CUSTOM].IDivisor = val;
            break;
        case MENU_EMCUSTOM_PREGISTER:
            EMConfig[EM_CUSTOM].PRegister = val;
            break;
        case MENU_EMCUSTOM_PDIVISOR:
            EMConfig[EM_CUSTOM].PDivisor = val;
            break;
        case MENU_EMCUSTOM_EREGISTER:
            EMConfig[EM_CUSTOM].ERegister = val;
            break;
        case MENU_EMCUSTOM_EDIVISOR:
            EMConfig[EM_CUSTOM].EDivisor = val;
            break;
        case MENU_RFIDREADER:
            RFIDReader = val;
            break;

        case STATUS_STATE:
            setState(val);
            break;
        case STATUS_ERROR:
            Error = val;
            if (Error) {                                                        // Is there an actual Error? Maybe the error got cleared?
                setState(STATE_A);                                              // We received an error; switch to State A, and wait 60 seconds
                ChargeDelay = CHARGEDELAY;
#ifdef LOG_DEBUG_MODBUS
                printf("\nBroadcast Error message received!");
            } else {
                printf("\nBroadcast Errors Cleared received!");
#endif
            }
            break;
        case STATUS_CURRENT:
            OverrideCurrent = val;
            break;
        case STATUS_ACCESS:
            if (val == 0 || val == 1) {
                Access_bit = val;
                if (val == 0) setState(STATE_A);
            }
            break;
        case STATUS_SOLAR_TIMER:
            setSolarStopTimer(val);
            break;
        default:
            return 0;
    }

    return 1;
}

/**
 * Get the variable
 *
 * @param unsigned char MENU_xxx
 * @return unsigned int value
 */
unsigned int getItemValue(unsigned char nav) {
    switch (nav) {
        case MENU_CONFIG:
            return Config;
        case MENU_MODE:
        case STATUS_MODE:
            return Mode;
        case MENU_START:
            return StartCurrent;
        case MENU_STOP:
            return StopTime;
        case MENU_IMPORT:
            return ImportCurrent;
        case MENU_LOADBL:
            return LoadBl;
        case MENU_MAINS:
            return MaxMains;
        case MENU_MIN:
            return MinCurrent;
        case MENU_MAX:
            return MaxCurrent;
        case MENU_CIRCUIT:
            return MaxCircuit;
        case MENU_LOCK:
            return Lock;
        case MENU_SWITCH:
            return Switch;
        case MENU_RCMON:
            return RCmon;
        case MENU_CAL:
            return ICal;
        case MENU_GRID:
            return Grid;
        case MENU_MAINSMETER:
            return MainsMeter;
        case MENU_MAINSMETERADDRESS:
            return MainsMeterAddress;
        case MENU_MAINSMETERMEASURE:
            return MainsMeterMeasure;
        case MENU_PVMETER:
            return PVMeter;
        case MENU_PVMETERADDRESS:
            return PVMeterAddress;
        case MENU_EVMETER:
        case STATUS_EVMETER:
            return EVMeter;
        case MENU_EVMETERADDRESS:
        case STATUS_EVMETERADDRESS:
            return EVMeterAddress;
        case MENU_EMCUSTOM_ENDIANESS:
            return EMConfig[EM_CUSTOM].Endianness;
        case MENU_EMCUSTOM_ISDOUBLE:
            return EMConfig[EM_CUSTOM].IsDouble;
        case MENU_EMCUSTOM_UREGISTER:
            return EMConfig[EM_CUSTOM].URegister;
        case MENU_EMCUSTOM_UDIVISOR:
            return EMConfig[EM_CUSTOM].UDivisor;
        case MENU_EMCUSTOM_IREGISTER:
            return EMConfig[EM_CUSTOM].IRegister;
        case MENU_EMCUSTOM_IDIVISOR:
            return EMConfig[EM_CUSTOM].IDivisor;
        case MENU_EMCUSTOM_PREGISTER:
            return EMConfig[EM_CUSTOM].PRegister;
        case MENU_EMCUSTOM_PDIVISOR:
            return EMConfig[EM_CUSTOM].PDivisor;
        case MENU_EMCUSTOM_EREGISTER:
            return EMConfig[EM_CUSTOM].ERegister;
        case MENU_EMCUSTOM_EDIVISOR:
            return EMConfig[EM_CUSTOM].EDivisor;
        case MENU_RFIDREADER:
            return RFIDReader;

        case STATUS_STATE:
            return State;
        case STATUS_ERROR:
            return Error;
        case STATUS_MAX:
            return MaxCapacity;
        case STATUS_MIN:
            return MinCurrent; // In solar mode StartCurrent?
        case STATUS_CURRENT:
            return Balanced[0];
        case STATUS_ACCESS:
            return Access_bit;
        case STATUS_SOLAR_TIMER:
            return SolarStopTimer;

        default:
            return 0;
    }
}

/**
 * Get active option of an menu item
 *
 * @param unsigned char nav
 * @return unsigned char[] MenuItemOption
 */
const far char * getMenuItemOption(unsigned char nav) {
    unsigned char Str[10];
    unsigned int value;

    value = getItemValue(nav);

    switch (nav) {
        case MENU_CONFIG:
            if (Config) return StrFixed;
            else return StrSocket;
        case MENU_MODE:
            if (Mode == MODE_SMART) return StrSmart;
            else if (Mode == MODE_SOLAR) return StrSolar;
            else return StrNormal;
        case MENU_START:
                sprintf(Str, "-%2u A", value);
                return Str;
        case MENU_STOP:
            if (value) {
                sprintf(Str, "%2u min", value);
                return Str;
            } else return StrDisabled;
        case MENU_LOADBL:
            return StrLoadBl[LoadBl];
        case MENU_MAINS:
        case MENU_MIN:
        case MENU_MAX:
        case MENU_CIRCUIT:
        case MENU_IMPORT:
            sprintf(Str, "%2u A", value);
            return Str;
        case MENU_LOCK:
            if (Lock == 1) return StrSolenoid;
            else if (Lock == 2) return StrMotor;
            else return StrDisabled;
        case MENU_SWITCH:
            return StrSwitch[Switch];
        case MENU_RCMON:
            if (RCmon) return StrEnabled;
            else return StrDisabled;
        case MENU_MAINSMETER:
        case MENU_PVMETER:
        case MENU_EVMETER:
            return EMConfig[value].Desc;
        case MENU_GRID:
            return StrGrid[Grid];
        case MENU_MAINSMETERADDRESS:
        case MENU_PVMETERADDRESS:
        case MENU_EVMETERADDRESS:
        case MENU_EMCUSTOM_UREGISTER:
        case MENU_EMCUSTOM_IREGISTER:
        case MENU_EMCUSTOM_PREGISTER:
        case MENU_EMCUSTOM_EREGISTER:
            if(value < 0x1000) sprintf(Str, "%u (%02X)", value, value);
            else sprintf(Str, "%u %X", value, value);
            return Str;
        case MENU_MAINSMETERMEASURE:
            if (MainsMeterMeasure) return StrMainsHomeEVSE;
            else return StrMainsAll;
        case MENU_EMCUSTOM_ENDIANESS:
            switch(value) {
                case 0: return "LBF & LWF";
                case 1: return "LBF & HWF";
                case 2: return "HBF & LWF";
                case 3: return "HBF & HWF";
                default:
                    break;
            }
        case MENU_EMCUSTOM_ISDOUBLE:
            if (value) return "Double";
            else return "Integer";
        case MENU_EMCUSTOM_UDIVISOR:
        case MENU_EMCUSTOM_IDIVISOR:
        case MENU_EMCUSTOM_PDIVISOR:
        case MENU_EMCUSTOM_EDIVISOR:
            sprintf(Str, "%lu", pow10[value]);
            return Str;
        case MENU_RFIDREADER:
            return StrRFIDReader[RFIDReader];
        case MENU_EXIT:
            return StrExitMenu;
        default:
            return "";
    }
}

// Serial Command line interface
// Display Menu, and process input.
//------------------------------------------------
// Smart EVSE
// -- Main menu --
// CONFIG - Set to Fixed Cable or Type 2 Socket
// MODE   - Set to Normal, Smart or Solar EVSE mode
// START  - Surplus energy start Current
// STOP   - Stop solar charging at 6A after this time
// LOADBL - Set Load Balancing to Disabled, Master or Node1-3
// MAINS  - Set max MAINS Current (25-100)
// MAX    - Set MAX Charge Current for the EV (16-80)
// MIN    - Set MIN Charge Current the EV will accept
// CAL    - Calibrate CT1
// LOCK   - Cable lock Disable/Solenoid/Motor
// ACCESS - Access control on IO2
// RCMON  - Residual Current Monitor on IO3
// L1: 1.2A L2: 5.3A L3: 0.4A (MAX:26A MIN:10A)
//

void RS232cli(void) {
    unsigned char i, OK, x;
    unsigned int n;
    unsigned int Inew;                                                          // resolution 0.1A
    unsigned char MenuItemsCount = getMenuItems();

    printf("\n");
    if (menu == 0)                                                              // menu = Main Menu
    {
        for(i = 0; i < MenuItemsCount - 1; i++) {
            if (strcmp(U2buffer, MenuStr[MenuItems[i]].Key) == 0) menu = MenuItems[i];
        }
        if (strcmp(U2buffer, (const far char *) "STATE?") == 0 ) {              // request charging state for all connected EVSE's
            menu = MENU_STATE;
        }
    } else if (U2buffer[0] == 0) menu = 0;
    else {
        switch (menu) {
            case MENU_CAL:
                x = 0;
                do {                                                            // remove decimal point from string
                    i = U2buffer[x];                                            // so 23.5 becomes 235
                    if (i == '.') {
                        U2buffer[x] = U2buffer[x+1];
                        U2buffer[x+1] = '\0';
                    }
                    x++;
                } while (i != '\0');

                Inew = atoi(U2buffer);
                if ((Inew < 60) || (Inew > 800)) printf("\nError! please calibrate with at least 6A\n");
                else {
                    ICal = ((unsigned long)Inew * 10 + 5) * ICAL / Iuncal;      // Calculate new Calibration value
                    write_settings();
                }
                break;
            case MENU_MODE:
                if (strcmp(U2buffer, (const far char *) "SOLAR") == 0) {
                    Mode = MODE_SOLAR;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "SMART") == 0) {
                    Mode = MODE_SMART;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "NORMAL") == 0) {
                    Mode = MODE_NORMAL;
                    write_settings();
                    Error = NO_ERROR; // Clear Errors
                }
                break;
            case MENU_LOCK:
                if (strcmp(U2buffer, (const far char *) "SOLENOID") == 0) {
                    Lock = 1;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "MOTOR") == 0) {
                    Lock = 2;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "DISABLE") == 0) {
                    Lock = 0;
                    write_settings();
                }
                break;
            case MENU_CONFIG:
                if (strcmp(U2buffer, (const far char *) "FIXED") == 0) {
                    Config = 1;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "SOCKET") == 0) {
                    Config = 0;
                    write_settings();
                }
                break;
            case MENU_LOADBL:
                for(i = 0; i <= NR_EVSES; i++){
                    if (strcmp(U2buffer, StrLoadBl[i]) == 0) {
                        LoadBl = i;
                        write_settings();
                    }
                }
                break;
            case MENU_SWITCH:
                for(i = 0; i < 5; i++){
                    if (strcmp(U2buffer, StrSwitch[i]) == 0) {
                        Switch = i;
                        write_settings();
                    }
                }
                break;
            case MENU_GRID:
                for(i = 0; i < 2; i++){
                    if (strcmp(U2buffer, StrGrid[i]) == 0) {
                        Grid = i;                                               // 4Wire=0, 3Wire=1
                        write_settings();
                    }
                }
                break;
            case MENU_RCMON:
                if (strcmp(U2buffer, (const far char *) "DISABLE") == 0) {
                    RCmon = 0;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "ENABLE") == 0) {
                    RCmon = 1;
                    write_settings();
                }
                break;
            case MENU_MAINSMETER:
            case MENU_PVMETER:
            case MENU_EVMETER:
                for(i = 0; i <= EM_CUSTOM; i++){                                // Don't accept Sensorbox for EVMETER
                    if ( (strcmp(U2buffer, EMConfig[i].Desc) == 0) && !(EMConfig[i].ERegister == 0xffff && menu == MENU_EVMETER) ) {
                        setItemValue(menu, i);
                        write_settings();
                    }
                }
                break;
            case MENU_MAINSMETERMEASURE:
                if (strcmp(U2buffer, (const far char *) "ALL") == 0) {
                    MainsMeterMeasure = 0;
                    write_settings();
                } else if (strcmp(U2buffer, (const far char *) "HOME") == 0) {
                    MainsMeterMeasure = 1;
                    write_settings();
                }
                break;
            case MENU_RFIDREADER:
                for(i = 0; i < 5; i++) {
                    if (strcmp(U2buffer, StrRFIDReader[i]) == 0) {
                        RFIDReader = i;
                        write_settings();
                    }
                }
                break;
            default:
                n = (unsigned int) atoi(U2buffer);
                OK = setItemValue(menu, n);
                write_settings();
                if(!OK) printf("\nError! please check limits\n");
                break;
        }

        menu = 0;
        MenuItemsCount = getMenuItems();
    }

    // Show active item configuration
    if (menu > 14 && menu < MENU_EXIT) printf("%s is set to %s\n", MenuStr[menu].Desc, getMenuItemOption(menu));

    switch (menu) {
        case 0:
            printf("\n----------------------------- SMART EVSE -----------------------------\n v");
            printf(VERSION);
            printf(" for instructions, see www.smartevse.org\n");
            printf(" Internal Temperature: %i C  SN: %06u\n", TempEVSE, serialnr);
            printf("----------------------------------------------------------------------\n");
            for(i = 0; i < MenuItemsCount - 1; i++) {
                printf("%-07s - %-50s - ", MenuStr[MenuItems[i]].Key, MenuStr[MenuItems[i]].Desc);
                if (MenuItems[i] == MENU_CAL) {
                    for (x = 0 ; x < 3 ; x++)
                        printf("CT%u:%d.%u A ", x+1, Irms[x]/10, (unsigned int)abs(Irms[x])%10 );
                } else {
                    printf(getMenuItemOption(MenuItems[i]));
                }
                printf("\n");
            }

            printf(">");
            break;
        case MENU_CONFIG:
            printf("Configuration : %s\nEnter new Configuration (FIXED/SOCKET): ", getMenuItemOption(menu));
            break;
        case MENU_MODE:
            printf("EVSE set to : %s\nEnter new EVSE Mode (NORMAL/SMART/SOLAR): ", getMenuItemOption(menu));
            break;
        case MENU_START:
            printf("Surplus energy start Current set to: %u A\nEnter new Surplus start Current (1-16): -", StartCurrent);
            break;
        case MENU_STOP:
            printf("Stop solar charging at 6A after %u min.\nEnter new time (0-60) min: ", StopTime);
            break;
        case MENU_IMPORT:
            printf("Allow Import from grid. Current set to: %u A\nEnter new Import Current (0-6): ", ImportCurrent);
            break;
        case MENU_LOADBL:
            printf("Load Balancing set to : %s\nEnter Load Balancing mode (%s", getMenuItemOption(menu), StrLoadBl[0]);
            for(i = 1; i <= NR_EVSES; i++) {
                printf("/%s", StrLoadBl[i]);
            }
            printf("): ");
            break;
        case MENU_MAINS:
            printf("WARNING - DO NOT SET CURRENT HIGHER THAN YOUR CIRCUIT BREAKER\n");
            printf("OR GREATER THAN THE RATED VALUE OF THE EVSE\n");
            printf("MAINS Current set to: %u A\nEnter new max MAINS Current (10-200): ", MaxMains);
            break;
        case MENU_MIN:
            printf("MIN Charge Current set to: %u A\nEnter new MIN Charge Current (6-16): ", MinCurrent);
            break;
        case MENU_MAX:
            printf("WARNING - DO NOT SET CURRENT HIGHER THAN YOUR CIRCUIT BREAKER\n");
            printf("OR GREATER THAN THE RATED VALUE OF THE EVSE\n");
            printf("MAX Current set to: %u A\nEnter new MAX Charge Current (6-80): ", MaxCurrent);
            break;
        case MENU_CIRCUIT:
            printf("WARNING - DO NOT SET CURRENT HIGHER THAN YOUR CIRCUIT BREAKER\n");
            printf("OR GREATER THAN THE RATED VALUE OF THE EVSE\n");
            printf("EVSE Circuit Current limit set to: %u A\nEnter new limit (10-160): ", MaxCircuit);
            break;
        case MENU_LOCK:
            printf("Cable lock set to : %s\nEnter new Cable lock mode (DISABLE/SOLENOID/MOTOR): ", getMenuItemOption(menu));
            break;
        case MENU_SWITCH:
            printf("Access Control on pin SW set to : %s\nAccess Control on SW (%s", getMenuItemOption(menu), StrSwitch[0]);
            for(i = 1; i < 5; i++) {
                printf("/%s", StrSwitch[i]);
            }
            printf("): ");
            break;
        case MENU_RCMON:
            printf("Residual Current Monitor on pin RCM set to : %s\nResidual Current Monitor (DISABLE/ENABLE): ", getMenuItemOption(menu));
            break;
        case MENU_GRID:
            printf("GRID connection (for correct Sensorbox measurement) set to : %s\nGrid set to (4Wire/3Wire): ", getMenuItemOption(menu));
            break;
        case MENU_CAL:
            printf("CT1 reads: %d.%u A\nEnter new Measured Current for CT1: ", Irms[0]/10, (unsigned int)abs(Irms[0])%10);
            break;
        case MENU_MAINSMETER:
        case MENU_PVMETER:
        case MENU_EVMETER:
            printf("Enter new type (%s", EMConfig[0].Desc);
            for(i = 1; i <= EM_CUSTOM; i++) {                                   // Don't show Sensorbox on EVMETER
                if (!(EMConfig[i].ERegister == 0xffff && menu == MENU_EVMETER)) printf("/%s", EMConfig[i].Desc);
            }
            printf("): ");
            break;
        case MENU_MAINSMETERMEASURE:
            printf("Enter what mains electric meter measure (ALL/HOME): ");
            break;
        case MENU_EMCUSTOM_ENDIANESS:
            printf("Enter new Byte order (0: LBF & LWF, 1: LBF & HWF, 2: HBF & LWF, 3: HBF & HWF): ");
            break;
        case MENU_EMCUSTOM_UDIVISOR:
        case MENU_EMCUSTOM_IDIVISOR:
        case MENU_EMCUSTOM_PDIVISOR:
        case MENU_EMCUSTOM_EDIVISOR:
            printf("Enter new exponent of divisor (0-7) or 8 for double: ");
            break;
        case MENU_RFIDREADER:
            printf("RFID reader is set to: %s\nEnter new RFID reader mode (%s", getMenuItemOption(menu), StrRFIDReader[0]);
            for(i = 1; i < 5; i++) {
                printf("/%s", StrRFIDReader[i]);
            }
            printf("): ");
            break;
        case MENU_STATE:
            for (n = 0; n < NR_EVSES; n++) {
                printf("EVSE%u:%c(%u.%1uA)", n, BalancedState[n]+'A', Balanced[n]/10, Balanced[n]%10);
                if (n < NR_EVSES-1) printf(",");
                else printf("\n");
            }
            menu = 0;
            break;
        default:
            printf("Enter new value (%u-%u): ", MenuStr[menu].Min, MenuStr[menu].Max);
            break;
    }
    ISR2FLAG = 0;                                                               // clear flag
    idx2 = 0;                                                                   // reset buffer pointer
}

// TestIO will be called after a special RS485 command has been received.
void TestIO(void)                                                               // Test connector should be connected to CON1
{
    unsigned char error = 0;

    if (TestState == 1) {
        CCP2CON = 0;                                                            // Disable PWM on LED output
        LATBbits.LATB3 = 0;                                                     // set IO1 to low, State B

        SOLENOID_OFF;
        delay(3000);                                                            // wait 3 seconds for capacitor to charge

        CCP1CON = 0;                                                            // PWM off
        PORTCbits.RC2 = 0;                                                      // Control pilot static -12V
        delay(100);                                                             // wait 100 msec
        if (ReadPilot() == PILOT_DIODE) TestState = STATE_B;                    // should be -12V
        else error = 1;
    } else if (TestState == STATE_B && State == STATE_B)                        // +9V (B state) OK, now test PP input
    {
        ProximityPin();
        if (MaxCapacity != 32) error ^= 2;                                      // error!
        TestState = STATE_C;
        LATBbits.LATB3 = 1;                                                     // set IO1 to high State B->State C
    } else if (TestState == STATE_C && State == STATE_C)                        //+6V (C state) OK
    {
        Lock = 1;                                                               // enable Lock
        TRISB = 0b10000101;                                                     // RB7(RX2), RB0,2 inputs. all other output
        LATBbits.LATB1 = 1;                                                     // set IO3 to high
        delay(5000);                                                            // wait 5 seconds for capacitor to charge
        if (PORTCbits.RC1 == 1) error ^= 4;                                     // error, Solenoid not activated !

        delay(10);
                                                                                // Contactor + I/O test
        if (PORTBbits.RB2 == 1)                                                 // sample input PIN IO2
        {
            LATBbits.LATB1 = 0;
            delay(10);
            if (PORTBbits.RB2 != 0) error ^= 8;                                 // error
        } else error ^= 8;                                                      // error

        TestState = STATE_CB;
        LATBbits.LATB3 = 0;                                                     // set IO1 to low State C->State B
    } else if (TestState == STATE_CB && State == STATE_B) {
        TRISB = 0b10000001;                                                     // RB7(RX2), RB0 inputs. all other output
        delay(1000);
        if (PORTCbits.RC1 == 0) error ^= 4;                                     // Solenoid FAIL!!
        else if (!error) {
            TestState = 80;
            Lock = 0;
            GLCD();
        }
    }

    if (error) {
        TRISB = 0b10000001;                                                     // Reset all IO to default values
        LATBbits.LATB1 = 0;
        LATBbits.LATB2 = 0;
        LATBbits.LATB3 = 0;                                                     // set IO1 to low State C->State B
        Lock = 0;
        Error |= Test_IO;
        TestState = error;
        setState(STATE_A);
    }
}

void init(void) {
    OSCCON = 0b01101100;                                                        // setup external oscillator
    OSCCON2 = 0b00000100;                                                       // primary Oscillator On.

    RCON = 0b11011111;                                                          // Set Interrupt priority, enable BOR

    PMD0 = 0b00000000;                                                          // Peripheral Module Enable/Disable
    PMD1 = 0b00000000;                                                          // All enabled
    PMD2 = 0b00000000;

    PORTA = 0;                                                                  // Init PORTA
    ANSELA = 0b00000111;                                                        // RA0, RA1, RA2 are analog inputs (pin 2,3,4)
    TRISA = 0b00000111;                                                         // Set RA0,RA1,RA2 as inputs

    PORTB = 0;
    ANSELB = 0;                                                                 // All digital IO
    TRISB = 0b10000111;                                                         // RB7(RX2), RB0-RB2 inputs. all other output
    WPUB = 0b10000111;                                                          // weak pullup on RB7 and RB0-RB2
    INTCON2bits.RBPU = 0;                                                       // Enable weak pullups on PORTB

    PORTC = 0b00000100;                                                         // Set Pilot to +12V at startup
    ANSELC = 0;                                                                 // All digital IO
    TRISC = 0b10000010;                                                         // RC1 and RC7 input (RX1), all other output

    SPBRGH1 = 0x01;                                                             // Initialize UART 1 (RS485)
    SPBRG1 = 0xA0;                                                              // Baudrate 9600

    BAUDCON1 = 0b00001000;                                                      // 16 bit Baudrate register is used
    TXSTA1 = 0b00100100;                                                        // Enable TX, 8 bit, Asynchronous mode
    RCSTA1 = 0b10010000;                                                        // Enable serial port TX and RX, 8 bit.

    SPBRGH2 = 0;                                                                // Initialize UART 2
    SPBRG2 = 34;                                                                // Baudrate 115k2 (114285)
    BAUDCON2 = 0b00001000;                                                      // 16 bit Baudrate register is used
    TXSTA2 = 0b00100100;                                                        // Enable TX, 8 bit, Asynchronous mode
    RCSTA2 = 0b10010000;                                                        // Enable serial port TX and RX, 8 bit.

    VREFCON0 = 0b10100000;                                                      // Fixed Voltage reference set to 2.048V

    ADCON0 = 0b00000001;                                                        // ADC On, input AN0 (Pilot)
    ADCON1 = 0;
    ADCON2 = 0b10100101;                                                        // Right justify, Tacq = 8 uS, FOSC/16

    T0CON = 0b10000111;                                                         // Timer 0 @ 16Mhz => 32 uS Timer0, 16 bit counter, 1:256 prescaler

    PR2 = 249;                                                                  // Timer 2 frequency value -> 1Khz @ 16 Mhz
    T2CON = 0b00000110;                                                         // Timer 2 ON, prescaler 1:16
    CCP1CON = 0;                                                                // PWM off (Control Pilot signal)
    CCP2CON = 0;                                                                // PWM off (Led on I/O 1)

    PR4 = 249;                                                                  // Timer 4 frequency value -> 1Khz @ 16 Mhz
    T4CON = 0b00000110;                                                         // Timer 4 ON, prescaler 1:16

    // SPI registers
    SSP1STAT = 0b00000000;                                                      // 0 = Input data sampled at middle of data output time
                                                                                // 0 = Transmit occurs on transition from Idle to active clock state
    SSP1CON1 = 0b00010000;                                                      // Idle state for clock is a high level, SPI Master mode, clock = FOSC/4
    SSP1CON1 = 0b00110000;                                                      // SPI enabled,Idle state for clock is a high level, SPI Master mode, clock = FOSC/4

    PIE1bits.RC1IE = 1;                                                         // enable receive Interrupt for UART1
    PIE3bits.RC2IE = 1;                                                         // enable receive Interrupt for UART2
    PIE5bits.TMR4IE = 1;                                                        // enable Timer4 Interrupt

    INTCONbits.GIEH = 1;                                                        // global High Priority interrupts enabled
    INTCONbits.GIEL = 0;                                                        // global Low Priority interrupts disabled

    SOLENOID_OFF;                                                               // R and W outputs held at Capacitor voltage (+12V)

    CCPR2L = 0;                                                                 // LED DutyCycle 0%
    CCP2CON = 0x0C;                                                             // LED PWM on

    unlockMagic = 0x22;
    printf("\nSmart EVSE powerup.\n");

}


/**
 * Update current data after received current measurement
 */
void UpdateCurrentData(void) {
    unsigned char x;

    // reset Imeasured value (grid power used)
    Imeasured = 0;
    // reset ImeasuredNegative (surplus power generated)
    ImeasuredNegative = 0;
    for (x=0; x<3; x++) {
        // Imeasured holds highest Irms of all channels
        if (Irms[x] > Imeasured) Imeasured = Irms[x];
        if (Irms[x] < ImeasuredNegative) ImeasuredNegative = Irms[x];
    }


    // Load Balancing mode: Smart/Master or Disabled
    if (Mode && LoadBl < 2) {
        // Calculate dynamic charge current for connected EVSE's
        CalcBalancedCurrent(0);

        // No current left, or Overload (2x Maxmains)?
        if (NoCurrent > 2 || (Imeasured > (MaxMains * 20))) {
            // STOP charging for all EVSE's
            // Display error message
            Error |= LESS_6A; //NOCURRENT;
            // Set all EVSE's to State A
            ResetBalancedStates();

            // Broadcast Error code over RS485
            ModbusWriteSingleRequest(BROADCAST_ADR, 0xA1, LESS_6A);
            NoCurrent = 0;
        } else if (LoadBl) BroadcastCurrent();                                  // Master sends current to all connected EVSE's

        if ((State == STATE_B) || (State == STATE_C)) {
            // Set current for Master EVSE in Smart Mode
            SetCurrent(Balanced[0]);
        }
#ifdef LOG_DEBUG_EVSE
        printf("\nSTATE: %c Error: %u StartCurrent: -%i ImeasuredNegative: %.1f A ChargeDelay: %u SolarStopTimer: %u NoCurrent: %u Imeasured: %.1f A IsetBalanced: %.1f A", State +'A', Error, StartCurrent,
                                                                        (double)ImeasuredNegative/10, ChargeDelay, SolarStopTimer,  NoCurrent,
                                                                        (double)Imeasured/10,
                                                                        (double)IsetBalanced/10);

        printf("\nL1: %.1f A L2: %.1f A L3: %.1f A Isum: %.1f A", (double)Irms[0]/10, (double)Irms[1]/10, (double)Irms[2]/10, (double)Isum/10);
#endif
    } else Imeasured = 0; // In case Sensorbox is connected in Normal mode. Clear measurement.
}


void main(void) {
    unsigned char x, leftbutton, RB2low = 0;
    unsigned char pilot, count = 0, timeout = 5;
    unsigned char DiodeCheck = 0, ActivationMode = 0, ActivationTimer = 0;
    unsigned char Broadcast = 1, RB2count = 0, RB2last = 1;
    signed long CM[3]={0, 0, 0};
    signed long PV[3]={0, 0, 0};
    unsigned char PollEVNode = NR_EVSES;
    signed long EnergyEV = 0;
    unsigned long RB2Timer = 0;                                                 // 1500ms
    unsigned char ResetKwh = 2;                                                 // if set, reset EV kwh meter at state transition B->C
                                                                                // cleared when charging, reset to 1 when disconnected (state A)

    init();                                                                     // initialize ports, ADC, UARTs etc

    read_settings();                                                            // from EEprom
    IsetBalanced = MaxMains * 10;                                               // Initially set to MaxMains
    ReadRFIDlist();                                                             // Read all stored RFID's from eeprom

    BACKLIGHT_ON;                                                               // so we can see the version nr at powerup
    GLCD_init();
    GLCD_version();                                                             // Display Version

    RCONbits.POR = 1;                                                           // flag that future resets are not POR resets

    x = checkbootloader();                                                      // update the bootloader to v1.06?
    if (x == 2) Error = BL_FLASH;                                               // bootloader update flash write error!


    while (1)                                                                   // MAIN loop
    {

        if (TestState) TestIO();                                                // TestMode. Test all I/O of Module

        if (ISR2FLAG) RS232cli();                                               // RS232 command line interface

        if (DelayedRS485SendBuf && (ModbusTimer > 6)) {

            LATBbits.LATB5 = 1;                                                 // set RS485 transceiver to transmit
            delay(1);
            PIE1bits.TX1IE = 1;                                                 // enable transmit Interrupt for RS485
            DelayedRS485SendBuf = 0;                                            // reset delayed transmission flag
#ifdef LOG_INFO_MODBUS
            printf ("\nDelayed transmission");
#endif
        }

        if (!ISRTXFLAG && TXSTA1bits.TRMT) LATBbits.LATB5 = 0;                  // set RS485 transceiver to receive if the last character has been sent

        BlinkLed();                                                             // Handle the blinking of the 12V LED

        TRISC = 0b10100011;                                                     // Set RC5 and RC0 to input. Make sure there are pull-ups on these pins.
        NOP();
        NOP();
        x = (PORTC & 0b00100001);                                               // Read Two Button Inputs on RC5(>) and RC0(select)
        ButtonState = (x >> 3);
        ButtonState = ButtonState | ((x << 1) & 0x02);                          // arranged to lowest bits
        ButtonState = ButtonState | (PORTB & 0x01);                             // Read the state of the last button RB0(<).
        TRISC = 0b10000010;                                                     // RC1 and RC7 input (RX1), all other output

                                                                                // Any button pressed or just released?
        if ((ButtonState != 0x07) || (ButtonState != OldButtonState)) GLCDMenu(ButtonState);

        if (LCDNav > MENU_ENTER && LCDNav < MENU_EXIT && (ScrollTimer + 5000 < Timer) && (!SubMenu)) GLCDHelp(); // Update/Show Helpmenu

        // Left button pressed, Loadbalancing is Master or Disabled, switch is set to "Sma-Sol B" and Mode is Smart or Solar?
        if (!LCDNav && ButtonState == 0x6 && Mode && !leftbutton && (LoadBl < 2) && Switch == 3) {
                Mode = ~Mode & 0x3;                                             // Change from Solar to Smart mode and vice versa.
                Error &= ~(NO_SUN | LESS_6A);                                   // Clear All errors
                ChargeDelay = 0;                                                // Clear any Chargedelay
                setSolarStopTimer(0);                                           // Also make sure the SolarTimer is disabled.
                LCDTimer = 0;
                                                                                // Broadcast change of Charging mode (Solar/Smart) to node EVSE's
                if (LoadBl == 1) ModbusWriteSingleRequest(BROADCAST_ADR, 0xA8, Mode);
                leftbutton = 5;
        } else if (leftbutton && ButtonState == 0x7) leftbutton--;


        // External switch changed state?
        if (PORTBbits.RB2 != RB2last || RB2low) {
            // make sure that noise on the input does not switch
            if (RB2count++ > 5 || RB2low) {
                RB2last = PORTBbits.RB2;

                if (RB2last == 0) {
                    // Switch input pulled low
                    switch (Switch) {
                        case 1: // Access Button
                            if (Access_bit) {
                                Access_bit = 0;                                 // Toggle Access bit on/off
                                setState(STATE_A);                              // Switch back to state A
                            } else Access_bit = 1;
#ifdef LOG_DEBUG_EVSE
                            printf("\nAccess: %d ", Access_bit);
#endif
                            break;
                        case 2: // Access Switch
                            Access_bit = 1;
                            break;
                        case 3: // Smart-Solar Button or hold button for 1,5 second to STOP charging
                            if (RB2low == 0) {
                                RB2low = 1;
                                RB2Timer = Timer;
                            }
                            if (RB2low && Timer > RB2Timer + 1500) {
                                if (State == STATE_C) {
                                    setState(STATE_A);
                                    if (!TestState) ChargeDelay = 15;           // Keep in State A for 15 seconds, so the Charge cable can be removed.
                                RB2low = 2;
                                }
                            }
                            break;
                        case 4: // Smart-Solar Switch
                            if (Mode == MODE_SOLAR) {
                                Mode = MODE_SMART;
                                setSolarStopTimer(0);                           // Also make sure the SolarTimer is disabled.
                            }                                                   // Broadcast change of Charging mode (Solar/Smart) to node EVSE's
                            if (LoadBl == 1 && Mode) ModbusWriteSingleRequest(BROADCAST_ADR, 0xA8, Mode);
                            break;
                        default:
                            if (State == STATE_C) {                             // Menu option Access is set to Disabled
                                setState(STATE_A);
                                if (!TestState) ChargeDelay = 15;               // Keep in State A for 15 seconds, so the Charge cable can be removed.
                            }
                            break;
                    }

                    // Reset RCD error when button is pressed
                    // RCD was tripped, but RCD level is back to normal
                    if (RCmon == 1 && (Error & RCD_TRIPPED) && PORTBbits.RB1 == 0) {
                        // Clear RCD error
                        Error &= ~RCD_TRIPPED;
                    }
                    // Also light up the LCD backlight
                    BacklightTimer = BACKLIGHT;                                 // Backlight ON
                    BACKLIGHT_ON;

                } else {
                    // Switch input released
                    switch (Switch) {
                        case 2: // Access Switch
                            Access_bit = 0;
                            setState(STATE_A);
                            break;
                        case 3: // Smart-Solar Button
                            if (RB2low != 2) {
                                if (Mode == MODE_SMART) {
                                    Mode = MODE_SOLAR;
                                } else if (Mode == MODE_SOLAR) {
                                    Mode = MODE_SMART;
                                }
                                Error &= ~(NO_SUN | LESS_6A);                   // Clear All errors
                                ChargeDelay = 0;                                // Clear any Chargedelay
                                setSolarStopTimer(0);                           // Also make sure the SolarTimer is disabled.
                                LCDTimer = 0;
                                                                                // Broadcast change of Charging mode (Solar/Smart) to node EVSE's
                                if (LoadBl == 1 && Mode) ModbusWriteSingleRequest(BROADCAST_ADR, 0xA8, Mode);
                            }
                            RB2low = 0;
                            break;
                        case 4: // Smart-Solar Switch
                            if (Mode == MODE_SMART) Mode = MODE_SOLAR;
                            if (LoadBl == 1 && Mode) ModbusWriteSingleRequest(BROADCAST_ADR, 0xA8, Mode);
                            break;
                        default:
                            break;
                    }
                }

                RB2count = 0;
            }
        } else RB2count = 0;


        if (RCmon == 1 && PORTBbits.RB1 == 1)                                   // RCD monitor active, and RCD DC current > 6mA ?
        {
           if (PORTBbits.RB1 == 1) {                                            // check again, to prevent voltage spikes from tripping the RCD detection (2.07)
                setState(STATE_A);
                Error = RCD_TRIPPED;
                LCDTimer = 0;                                                   // display the correct error message on the LCD
            }
        }

        // ############### EVSE State A #################

        if (State == STATE_A || State == STATE_COMM_B)
        {
            CCP1CON = 0;                                                        // PWM off
            PORTCbits.RC2 = 1;                                                  // Control pilot static +12V
            CONTACTOR_OFF;                                                      // Contactor OFF
            BalancedState[0] = STATE_A;                                         // Mark as inactive

            pilot = ReadPilot();

            if (pilot == PILOT_12V) {                                           // Check if we are disconnected, or forced to State A, but still connected to the EV

                if (State == STATE_COMM_B) setState(STATE_A);                   // reset state, incase we were stuck in STATE_COMM_B
                Error &= ~NO_SUN;
                Error &= ~LESS_6A;
                ChargeDelay = 0;                                                // Clear ChargeDelay when disconnected.
                NextState = NOSTATE;
                if (!ResetKwh) ResetKwh = 1;                                    // when set, reset EV kWh meter on state B->C change.
            } else if ( (pilot == PILOT_9V || pilot == STATE_A_TO_C)
                && Error == NO_ERROR && ChargeDelay == 0 && Access_bit
                && State != STATE_COMM_B) {                                     // switch to State B ?
                                                                                // Allow to switch to state C directly if STATE_A_TO_C is set to PILOT_6V (see EVSE.h)
                if (NextState == STATE_B)                                       // Access is permitted when Access_bit set
                {
                    if (count++ > 25)                                           // repeat 25 times (changed in v2.05)
                    {
                        DiodeCheck = 0;
                        ProximityPin();                                         // Sample Proximity Pin
#ifdef LOG_DEBUG_EVSE
                        printf("\nCable limit: %uA  Max: %uA", MaxCapacity, MaxCurrent);
#endif
                        if (MaxCurrent > MaxCapacity) ChargeCurrent = MaxCapacity * 10; // Do not modify Max Cable Capacity or MaxCurrent (fix 2.05)
                        else ChargeCurrent = MaxCurrent * 10;                   // Instead use new variable ChargeCurrent

                        if (LoadBl > 1)                                         // Load Balancing : Node
                        {                                                       // Send command to Master, followed by Max Charge Current
                            setState(STATE_COMM_B);                             // Node wants to switch to State B
                        } else {                                                // Load Balancing: Master or Disabled
                            BalancedMax[0] = MaxCapacity * 10;
                            Balanced[0] = ChargeCurrent;                        // Set pilot duty cycle to ChargeCurrent (v2.15)
                            BalancedState[0] = STATE_B;                         // Mark as active
                            setState(STATE_B);                                  // switch to State B
                            ActivationMode = 30;                                // Activation mode is triggered if state C is not entered in 30 seconds.
                            BacklightTimer = BACKLIGHT;                         // Backlight ON
                        }
                   }
                } else {
                    NextState = STATE_B;
                    count = 0;
                }
            } else NextState = NOSTATE;
        }

        if (State == STATE_COMM_B_OK) {
            setState(STATE_B);
            ActivationMode = 30;                                                // Activation mode is triggered if state C is not entered in 30 seconds.
            BacklightTimer = BACKLIGHT;                                         // Backlight ON
        }

        // ############### EVSE State B #################

        if (State == STATE_B || State == STATE_COMM_C)
        {                                                                       // measure voltage at ~5% and ~90% of PWM cycle
            if ((TMR2 > 7) && (TMR2 < 24))                                      // PWM cycle 3% - 9% (should be high)
            {
                pilot = ReadPilot();
                if (pilot == PILOT_12V)                                         // Disconnected?
                {
                    if (NextState == STATE_A) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            setState(STATE_A);                                  // switch to STATE_A
                            BacklightTimer = BACKLIGHT;                         // Switch on backlight when removing charging cable
                        }
                    } else {
                        NextState = STATE_A;
                        count = 0;
                    }
                } else if (pilot == PILOT_6V) {
                    if ((NextState == STATE_C) && (DiodeCheck == 1)) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            if ((Error == NO_ERROR) && (ChargeDelay == 0)) {
                                if (EVMeter && ResetKwh) {
                                    EnergyMeterStart = EnergyEV;                // store kwh measurement at start of charging.
                                    ResetKwh = 0;                               // clear flag, will be set when disconnected from EVSE (State A)
                                }
                                if (LoadBl > 1)                                 // Load Balancing : Node
                                {                                               // Send command to Master, followed by Charge Current
                                    if (State != STATE_COMM_C) setState(STATE_COMM_C);
                                } else {                                        // Load Balancing: Master or Disabled
                                    BalancedMax[0] = ChargeCurrent;
                                    if (IsCurrentAvailable()) {
                                        BalancedState[0] = STATE_C;                   // Mark as Charging
                                        Balanced[0] = 0;                        // For correct baseload calculation set current to zero
                                        CalcBalancedCurrent(1);                 // Calculate charge current for all connected EVSE's

                                        CONTACTOR_ON;                           // Contactor ON
                                        ActivationMode = 255;                   // Disable ActivationMode
                                        DiodeCheck = 0;
                                        setState(STATE_C);                      // switch to STATE_C
                                        LCDTimer = 0;
                                        Timer = 0;                              // reset msTimer and ChargeTimer
                                        if (!LCDNav) GLCD();                    // Don't update the LCD if we are navigating the menu
                                                                                // immediately update LCD (20ms)
                                    }
                                    else Error |= LESS_6A;//NOCURRENT;
                                }
                            }
                        }
                    } else {
                        NextState = STATE_C;
                        count = 0;
                    }
                } else {                                                        // PILOT_9V

                    if (ActivationMode == 0) {
                        setState(STATE_ACTSTART);
                        ActivationTimer = 3;
                        CCP1CON = 0;                                            // PWM off
                        PORTCbits.RC2 = 0;                                      // Control pilot static -12V
                    }
                    NextState = NOSTATE;                                        // no State to switch to
                }
            }
            if (TMR2 > 230)                                                     // PWM > 92%
            {
                while (TMR2 < 242);                                             // wait till TMR2 is in range, otherwise we'll miss it (blocking)
                if ((TMR2 > 241) && (TMR2 < 249))                               // PWM cycle >= 96% (should be low)
                {
                    pilot = ReadPilot();
                    if (pilot == PILOT_DIODE) DiodeCheck = 1;                   // Diode found, OK
                    else DiodeCheck = 0;
                }
            }
        }

        if (State == STATE_ACTSTART && ActivationTimer == 0) {
            setState(STATE_B);                                                  // Switch back to State B
            PORTCbits.RC2 = 1;                                                  // Control pilot static +12V
            ActivationMode = 255;                                               // Disable ActivationMode
        }

        if (State == STATE_COMM_C_OK) {
            CONTACTOR_ON;                                                       // Contactor ON
            DiodeCheck = 0;
            setState(STATE_C);                                                  // switch to STATE_C
            ActivationMode = 255;                                               // Disable ActivationMode
            NextState = NOSTATE;                                                // no State to switch to
            LCDTimer = 0;
            Timer = 0;                                                          // reset msTimer and ChargeTimer
                                                                                // Don't update the LCD if we are navigating the menu
            if (!LCDNav) GLCD();                                                // immediately update LCD
        }

        // ############### EVSE State C #################

        if (State == STATE_C)
        {                                                                       // measure voltage at ~5% of PWM cycle
            if ((TMR2 > 7) && (TMR2 < 24))                                      // cycle 3% - 9% (should be high)
            {
                pilot = ReadPilot();
                if ((pilot == PILOT_12V) || (pilot == PILOT_NOK))               // Disconnected or Error?
                {
                    if (NextState == STATE_A) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            CONTACTOR_OFF;                                      // Contactor OFF
                            setState(STATE_A);                                  // switch back to STATE_A
                            GLCD_init();                                        // Re-init LCD
                            if (LoadBl < 2) BalancedState[0] = STATE_A;         // Load Balancing : Master or Disabled
                                                                                // Mark EVSE as disconnected
                        }
                    } else {
                        NextState = STATE_A;
                        count = 0;
                    }
                } else if (pilot == PILOT_9V) {
                    if (NextState == STATE_B) {
                        if (count++ > 25)                                       // repeat 25 times
                        {
                            CONTACTOR_OFF;                                      // Contactor OFF
                            setState(STATE_B);                                  // switch back to STATE_B
                            GLCD_init();                                        // Re-init LCD (200ms delay)
                            DiodeCheck = 0;
                            if (LoadBl < 2) BalancedState[0] = STATE_B;         // Load Balancing : Master or Disabled
                                                                                // Mark EVSE as inactive (still State B)
                        }
                    } else {
                        NextState = STATE_B;
                        count = 0;
                    }
                } else {                                                        // PILOT_6V
                    NextState = NOSTATE;                                        // no State to switch to
                }
            }
        } // end of State C code


        if (RCSTA1bits.OERR)                                                    // Uart1 Overrun Error?
        {
            RCSTA1bits.CREN = 0;
            RCSTA1bits.CREN = 1;                                                // Restart Uart
        }
        if (RCSTA2bits.OERR)                                                    // Uart2 Overrun Error?
        {
            RCSTA2bits.CREN = 0;
            RCSTA2bits.CREN = 1;                                                // Restart Uart
        }

        // The following code will be executed every second, except when there is a state change C->B happening
        x = TMR0L;
        if (TMR0H >= 0x3d &&  (NextState == NOSTATE || State != STATE_C) )      // 1 second timer
        {
            TMR0H = 0;
            TMR0L = 0;

            Temp();                                                             // once a second, measure temperature

//            printf("locktimer: %lu timer: %lu\n lockstatus: %u", locktimer, Timer, lockstatus);

            // When RFID is enabled, a OneWire RFID reader is expected on the SW input
            if (RFIDReader) {                                                   // RFID Reader set to Enabled, Learn or Delete
                if (OneWireReadCardId() ) {                                     // Read card ID
                    switch (RFIDReader) {
                        case 1:                                                 // Enabled
                            x = MatchRFID();
                            if (x && !RFIDstatus) {
                                //printf("RFID card found!\n");
                                if (Access_bit) {
                                    Access_bit = 0;                             // Toggle Access bit on/off
                                    setState(STATE_A);                          // Switch back to state A
                                } else Access_bit = 1;

                                RFIDstatus = 1;
                            }  else if (!x) RFIDstatus = 7;                     // invalid card
                            BacklightTimer = BACKLIGHT;
                            break;
                        case 2:                                                 // Learn Card
                            x = StoreRFID();
                            if (x == 1) {
                                printf("\nRFID card stored!");
                                RFIDstatus = 2;
                            } else if (x == 2 && !RFIDstatus) {
                                printf("\nRFID card was already stored!");
                                RFIDstatus = 4;
                            } else if (!RFIDstatus) {
                                printf("\nRFID storage full! Delete card first");
                                RFIDstatus = 6;
                            }
                            break;
                        case 3:                                                 // Delete Card
                            x = DeleteRFID();
                            if (x) {
                                printf("\nRFID card deleted!");
                                RFIDstatus = 3;
                            } else if (!RFIDstatus) {
                                printf("\nRFID card not in list!");
                                RFIDstatus = 5;
                            }
                            break;
                        default:
                            break;
                    }
                } else RFIDstatus = 0;
            }

            if (State == STATE_B && ActivationMode < 255) ActivationMode--;     // decrease 30 sec counter when in State B
            if (State == STATE_ACTSTART && ActivationTimer) ActivationTimer--;

            // When Solar Charging, once the current drops to MINcurrent a timer is started.
            // Charging is stopped when the timer reaches the time set in 'StopTime' (in minutes)
            // Except when Stoptime =0, then charging will continue.

            if (SolarStopTimer) {
                SolarStopTimer--;
                if (SolarStopTimer == 0) {
                     setState(STATE_A);                                         // switch back to state A
                     Error |= NO_SUN;                                           // Set error: NO_SUN

                     ResetBalancedStates();                                     // reset all states
                }
            }

            if (ChargeDelay) ChargeDelay--;                                     // Decrease Charge Delay counter

            if ((TempEVSE < 55) && (Error & TEMP_HIGH)) // Temperature below limit?
            {
                Error &= ~TEMP_HIGH; // clear Error
            }

            if ( (Error & (LESS_6A|NO_SUN) ) && (LoadBl < 2) && (IsCurrentAvailable())) {
                Error &= ~LESS_6A;                                              // Clear Errors if there is enough current available, and Load Balancing is disabled or we are Master
                Error &= ~NO_SUN;
#ifdef LOG_DEBUG_EVSE
                printf("\nNo sun/current Errors Cleared.");
#endif
                ModbusWriteSingleRequest(BROADCAST_ADR, 0xA1, Error);           // Broadcast
            }

            if ((timeout == 0) && !(Error & CT_NOCOMM))                         // timeout if CT current measurement takes > 10 secs
            {
                Error |= CT_NOCOMM;
                setState(STATE_A);                                              // switch back to state A
#ifdef LOG_WARN_EVSE
                printf("\nError, communication error!");
#endif
                ResetBalancedStates();
            } else if (timeout) timeout--;

            if (TempEVSE >= 65 && !(Error & TEMP_HIGH))                         // Temperature too High?
            {
                Error |= TEMP_HIGH;
                setState(STATE_A);                                              // ERROR, switch back to STATE_A
#ifdef LOG_WARN_EVSE
                printf("\nError, temperature %i C !", TempEVSE);
#endif
                ResetBalancedStates();
            }

            if (Error & (NO_SUN | LESS_6A)) {
#ifdef LOG_INFO_EVSE
                if (Mode == MODE_SOLAR) {
                    if (ChargeDelay == 0) printf("\nWaiting for Solar power...");
                } else {
                    if (ChargeDelay == 0) printf("\nNot enough current available!");
                }
#endif
                setState(STATE_A);
                ChargeDelay = CHARGEDELAY;                                      // Set Chargedelay
            }

            // once a second, update LCD
            GLCD();

            // Every two seconds request measurement data from sensorbox/kwh meters.
            // and send broadcast to Node controllers.
            if (LoadBl < 2 && !Broadcast--) {                                   // Load Balancing mode: Master or Disabled
                if (Mode) {                                                     // Smart or Solar mode
                    ModbusRequest = 1;                                          // Start with state 1
                } else {                                                        // Normal mode
                    Imeasured = 0;                                              // No measurements, so we set it to zero
                    ModbusRequest = 5;                                          // Start with state 5 (poll Nodes)
                    timeout = 10;                                               // reset timeout counter (not checked for Master)
                }
                Broadcast = 1;                                                  // repeat every two seconds
            }

        } // end 1 second timer


        // Every 2 seconds, request measurements from modbus meters
        if (ModbusRequest && ModbusTimer >= 100 ) {
#ifdef LOG_DEBUG_MODBUS
            printf("\nModbusRequest %u", ModbusRequest);
#endif
            switch (ModbusRequest++) {                                          // State
                case 1:                                                         // PV kwh meter
                    if (PVMeter) {
                        requestCurrentMeasurement(PVMeter, PVMeterAddress);
                        break;
                    }
                    ModbusRequest++;
                case 2:                                                         // Sensorbox or kWh meter that measures -all- currents
                    requestCurrentMeasurement(MainsMeter, MainsMeterAddress);
                    break;
                case 3:                                                         // EV kWh meter, Energy measurement (total charged kWh)
                    // Find next online SmartEVSE
                    EVSEOnline[0] = true;
                    Node[0].EVMeter = EVMeter;
                    Node[0].EVAddress = EVMeterAddress;
                    do {
                        PollEVNode ++;
                        if (PollEVNode >= NR_EVSES) PollEVNode = 0;
                    } while(EVSEOnline[PollEVNode] == false);
                    // Request Energy
                    if (Node[PollEVNode].EVMeter) {
                        requestEnergyMeasurement(Node[PollEVNode].EVMeter, Node[PollEVNode].EVAddress);
                        break;
                    }
                    ModbusRequest++;
                case 4:                                                         // EV kWh meter, Power measurement (momentary power in Watt)
                    if (Node[PollEVNode].EVMeter) {
                        requestPowerMeasurement(Node[PollEVNode].EVMeter, Node[PollEVNode].EVAddress);
                        break;
                    }
                    ModbusRequest++;
                case 5:                                                         // Node 1
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    if (LoadBl == 1) {
                        requestNodeStatus(ModbusRequest - 5);                   // Master, Request Node 1-8 status
                        break;
                    }
                    ModbusRequest = 11;
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                    if (LoadBl == 1) {
                        processAllNodeStates(ModbusRequest - 12);
                        break;
                    }
                default:
                    if (Mode) {                                                 // Smart/Solar mode
                        if ((Error & CT_NOCOMM) == 0) UpdateCurrentData();      // No communication error with Sensorbox /Kwh meter?
                                                                                // then update the data and send broadcast to all connected EVSE's
                    } else {                                                    // Normal Mode
                        CalcBalancedCurrent(0);                                 // Calculate charge current for connected EVSE's
                        if (LoadBl == 1) BroadcastCurrent();                    // Send to all EVSE's (only in Master mode)
                        if ((State == STATE_B) || (State == STATE_C)) SetCurrent(Balanced[0]); // set PWM output for Master
                    }
                    ModbusRequest = 0;
                    break;
            }
        }


        /*  RS485 serial data is received by the ISR routine, and processed here..
            Reads serial packet with Raw Current values, measured from 1-3 CT's, over a RS485 serial line
        */

        // Receive data from modbus
        // last reception more then 3ms ago? // complete packet detected?

        if (idx && (ModbusTimer > 3) ) {                                        // if (idx && Timer > (ModbusTimer + 3)) {
            memcpy(U1packet, U1buffer, idx);                                    // store received data packet
            ISRFLAG = idx;                                                      // set flag to length of data packet
            idx = 0;                                                            // ready to receive a new packet

            ModbusDecode(U1packet, ISRFLAG);

            // Data received is a response to an earlier request from the master.
            if (Modbus.Type == MODBUS_RESPONSE) {
                //printf("\nModbus Response Address %i / Function %02x / Register %02x",Modbus.Address,Modbus.Function,Modbus.Register);
                switch (Modbus.Function) {
                    case 0x03: // (Read holding register)
                    case 0x04: // (Read input register)
                        if (PVMeter && Modbus.Address == PVMeterAddress && Modbus.Register == EMConfig[PVMeter].IRegister) {
                            // packet from PV electric meter
                            receiveCurrentMeasurement(Modbus.Data, PVMeter, PV);

                        } else if (Modbus.Address == MainsMeterAddress && Modbus.Register == EMConfig[MainsMeter].IRegister) {
                            // packet from Mains electric meter
                            x = receiveCurrentMeasurement(Modbus.Data, MainsMeter, CM);
                            if (x && LoadBl <2) timeout = 10;                   // only reset timeout when data is ok, and Master/Disabled

                            // Calculate Isum (for nodes and master)
                            Isum = 0;
                            for (x = 0; x < 3; x++) {
                                // Calculate difference of Mains and PV electric meter
                                if (PVMeter) CM[x] = CM[x] - PV[x];             // CurrentMeter and PV resolution are 1mA
                                Irms[x] = CM[x]/100;                            // reduce resolution of Irms to 100mA
                                Isum = Isum + Irms[x];                          // Isum has a resolution of 100mA
                            }

                        } else if (EVMeter && Modbus.Address == EVMeterAddress && Modbus.Register == EMConfig[EVMeter].ERegister) {
                            // packet from EV kWh meter
                            EnergyEV = receiveEnergyMeasurement(Modbus.Data, EVMeter);
                            if (ResetKwh == 2) EnergyMeterStart = EnergyEV;     // At powerup, set EnergyEV to kwh meter value
                            EnergyCharged = EnergyEV - EnergyMeterStart;        // Calculate Energy
                        } else if (EVMeter && Modbus.Address == EVMeterAddress && Modbus.Register == EMConfig[EVMeter].PRegister) {
                            // packet from EV kWh meter
                            PowerMeasured = receivePowerMeasurement(Modbus.Data, EVMeter);
                        }  else if (Modbus.Address > 1 && Modbus.Address <= NR_EVSES && Modbus.Register == 0xA0) {
                            // Status packet from Node EVSE received
                            receiveNodeStatus(Modbus.Data, Modbus.Address - 1);
                        }
                        break;
                    default:
                        break;
                }
            // Data received is a request from the master to a device on the bus.
            } else if (Modbus.Type == MODBUS_REQUEST) {
                //printf("\nModbus Request Address %i / Function %02x / Register %02x",Modbus.Address,Modbus.Function,Modbus.Register);
                                                                                // No timeout reset here, as it is a request, no response!!!!
                switch (Modbus.Function) {
                    case 0x03: // (Read holding register)
                    case 0x04: // (Read input register)
                        // Addressed to this device
                        if (Modbus.Address == LoadBl) {
                            ReadItemValueResponse();
                        }
                        break;
                    case 0x06: // (Write single register)
                        // Special TestIO message?
                        if (Modbus.Address == 0x0a && Modbus.Register == 0xa8 && Modbus.Value == 0x494f && !TestState) {
                            TestState = 1;
                            break;
                        }
                        // Broadcast or addressed to this device
                        if (Modbus.Address == BROADCAST_ADR || Modbus.Address == LoadBl) {
                            WriteItemValueResponse();
                        }
                        break;
                    case 0x10: // (Write multiple register))
                        // Broadcast or addressed to this device
                        if (Modbus.Address == BROADCAST_ADR || Modbus.Address == LoadBl) {
                            // 0x01: Balance currents
                            if (Modbus.Register == 0x01 && LoadBl > 1) {        // Message for Node(s)
                                Balanced[0] = (Modbus.Data[(LoadBl - 1) * 2] <<8) | Modbus.Data[(LoadBl - 1) * 2 + 1];
                                if (Balanced[0] == 0 && State == STATE_C) setState(STATE_A);                // Stop charging if charge current is zero
                                else if ((State == STATE_B) || (State == STATE_C)) SetCurrent(Balanced[0]); // Set charge current, and PWM output
#ifdef LOG_DEBUG_MODBUS
                                printf("\nBroadcast received, Node %u.%1u A", Balanced[0]/10, Balanced[0]%10);
#endif
                                timeout = 10;                                   // reset 10 second timeout
                            }
                            WriteMultipleItemValueResponse();
                        }
                        break;
                    default:
                        break;
                }
            } else if (Modbus.Type == MODBUS_EXCEPTION) {
#ifdef LOG_DEBUG_MODBUS
                printf("\nModbus Address %02x exception %u received", Modbus.Address, Modbus.Exception);
#endif
#ifdef LOG_WARN_MODBUS
            } else {
                printf("\nCRC invalid\n");
#endif
            }
        } // (ISRFLAG > 1) 	 complete packet detected?

        if ((Error & CT_NOCOMM) && timeout == 10) Error &= ~CT_NOCOMM;          // Clear communication error, if present
    } // end of while(1) loop
}
